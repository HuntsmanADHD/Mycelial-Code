# x86-64 ELF Linker Agent
#
# Owner: Opus (Claude Opus 4.5)
# Purpose: Convert machine code and relocations into ELF64 executable binary
# Input: machine_code, relocation, symbol_def signals from Assembler Agent
# Output: Complete ELF64 executable file
#
# Reference: /docs/knowledge-base/elf-format.md
#
# ELF64 Structure:
#   - ELF Header (64 bytes)
#   - Program Headers (56 bytes each)
#   - Sections (.text, .rodata, .data)
#   - Section Headers (64 bytes each)
#   - String Tables

network linker {

  # ═══════════════════════════════════════════════════════════════════════════
  # FREQUENCY DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  frequencies {
    # Input signals (from Assembler)
    machine_code {
      section: string
      offset: u32
      bytes: vec<u8>
    }

    relocation {
      section: string
      offset: u32
      symbol: string
      reloc_type: RelocationType
      addend: i64
    }

    symbol_def {
      name: string
      section: string
      offset: u32
      is_global: boolean
    }

    section_info {
      name: string
      size: u32
      flags: u32
    }

    asm_complete {
      total_bytes: u32
      symbol_count: u32
      relocation_count: u32
    }

    # Output signals
    link_complete {
      output_file: string
      file_size: u32
      entry_point: u64
    }

    link_error {
      message: string
      symbol: string
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TYPE DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  types {
    # ─────────────────────────────────────────────────────────────────────────
    # Relocation Types (from Assembler)
    # ─────────────────────────────────────────────────────────────────────────

    enum RelocationType {
      R_X86_64_NONE,        # No relocation
      R_X86_64_64,          # 64-bit absolute
      R_X86_64_PC32,        # 32-bit PC-relative
      R_X86_64_GOT32,       # GOT entry
      R_X86_64_PLT32,       # PLT entry
      R_X86_64_32,          # 32-bit absolute
      R_X86_64_32S          # 32-bit signed
    }

    # ─────────────────────────────────────────────────────────────────────────
    # ELF Constants
    # ─────────────────────────────────────────────────────────────────────────

    # ELF Header Constants
    const ELF_MAGIC: vec<u8> = [0x7F, 0x45, 0x4C, 0x46]  # \x7FELF
    const ELFCLASS64: u8 = 2
    const ELFDATA2LSB: u8 = 1   # Little-endian
    const EV_CURRENT: u8 = 1
    const ELFOSABI_SYSV: u8 = 0
    const ET_EXEC: u16 = 2      # Executable file
    const EM_X86_64: u16 = 62   # x86-64 machine

    # Program Header Types
    const PT_NULL: u32 = 0
    const PT_LOAD: u32 = 1
    const PT_DYNAMIC: u32 = 2
    const PT_INTERP: u32 = 3
    const PT_NOTE: u32 = 4

    # Program Header Flags
    const PF_X: u32 = 1         # Executable
    const PF_W: u32 = 2         # Writable
    const PF_R: u32 = 4         # Readable

    # Section Header Types
    const SHT_NULL: u32 = 0
    const SHT_PROGBITS: u32 = 1
    const SHT_SYMTAB: u32 = 2
    const SHT_STRTAB: u32 = 3
    const SHT_RELA: u32 = 4
    const SHT_NOBITS: u32 = 8

    # Section Header Flags
    const SHF_WRITE: u64 = 1
    const SHF_ALLOC: u64 = 2
    const SHF_EXECINSTR: u64 = 4

    # Symbol Binding
    const STB_LOCAL: u8 = 0
    const STB_GLOBAL: u8 = 1

    # Symbol Types
    const STT_NOTYPE: u8 = 0
    const STT_OBJECT: u8 = 1
    const STT_FUNC: u8 = 2

    # Layout Constants
    const BASE_ADDRESS: u64 = 0x400000
    const PAGE_SIZE: u64 = 0x1000
    const ELF_HEADER_SIZE: u32 = 64
    const PROGRAM_HEADER_SIZE: u32 = 56
    const SECTION_HEADER_SIZE: u32 = 64
    const SYMBOL_ENTRY_SIZE: u32 = 24

    # ─────────────────────────────────────────────────────────────────────────
    # Internal Structures
    # ─────────────────────────────────────────────────────────────────────────

    struct SectionData {
      name: string
      data: vec<u8>
      file_offset: u64
      vaddr: u64
      flags: u64
      section_type: u32
    }

    struct SymbolEntry {
      name: string
      section: string
      offset: u32
      is_global: boolean
      vaddr: u64
    }

    struct RelocationEntry {
      section: string
      offset: u32
      symbol: string
      reloc_type: RelocationType
      addend: i64
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # LINKER AGENT
  # ═══════════════════════════════════════════════════════════════════════════

  hyphae {
    hyphal linker {
      frequency tidal_cycle

      state {
        # Section data
        text_data: vec<u8>
        rodata_data: vec<u8>
        data_data: vec<u8>
        bss_size: u32

        # Symbols and relocations
        symbols: vec<SymbolEntry>
        relocations: vec<RelocationEntry>

        # Layout information
        text_vaddr: u64
        rodata_vaddr: u64
        data_vaddr: u64
        bss_vaddr: u64

        text_file_offset: u64
        rodata_file_offset: u64
        data_file_offset: u64

        # String tables
        shstrtab: vec<u8>       # Section name string table
        strtab: vec<u8>         # Symbol string table

        # Output
        output_buffer: vec<u8>
        output_file: string
        entry_point: u64

        # Counters
        error_count: u32
      }

      # ─────────────────────────────────────────────────────────────────────────
      # INITIALIZATION
      # ─────────────────────────────────────────────────────────────────────────

      on rest {
        if vec_len(state.text_data) == 0 {
          init_state()
        }
      }

      rule init_state() {
        state.text_data = vec_new()
        state.rodata_data = vec_new()
        state.data_data = vec_new()
        state.bss_size = 0

        state.symbols = vec_new()
        state.relocations = vec_new()

        state.shstrtab = vec_new()
        state.strtab = vec_new()
        state.output_buffer = vec_new()
        state.output_file = "a.out"
      }

      # ─────────────────────────────────────────────────────────────────────────
      # SIGNAL HANDLERS - SENSE PHASE
      # ─────────────────────────────────────────────────────────────────────────

      on signal(machine_code, mc) {
        # Collect machine code by section
        match mc.section {
          ".text" => {
            for byte in mc.bytes {
              vec_push(state.text_data, byte)
            }
          }
          ".rodata" => {
            for byte in mc.bytes {
              vec_push(state.rodata_data, byte)
            }
          }
          ".data" => {
            for byte in mc.bytes {
              vec_push(state.data_data, byte)
            }
          }
          ".bss" => {
            state.bss_size = state.bss_size + vec_len(mc.bytes)
          }
          _ => {}
        }
      }

      on signal(relocation, rel) {
        let entry = RelocationEntry {
          section: rel.section,
          offset: rel.offset,
          symbol: rel.symbol,
          reloc_type: rel.reloc_type,
          addend: rel.addend
        }
        vec_push(state.relocations, entry)
      }

      on signal(symbol_def, sym) {
        let entry = SymbolEntry {
          name: sym.name,
          section: sym.section,
          offset: sym.offset,
          is_global: sym.is_global,
          vaddr: 0  # Calculated during layout
        }
        vec_push(state.symbols, entry)
      }

      on signal(section_info, info) {
        # Section info received (used for validation)
        if info.name == ".bss" {
          state.bss_size = info.size
        }
      }

      on signal(asm_complete, done) {
        # All input received - perform linking
        link_executable()
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MAIN LINKING PROCESS
      # ─────────────────────────────────────────────────────────────────────────

      rule link_executable() {
        # Step 1: Calculate section layout
        calculate_layout()

        # Step 2: Finalize symbol addresses
        finalize_symbol_addresses()

        # Step 3: Apply relocations
        apply_relocations()

        # Step 4: Build string tables
        build_string_tables()

        # Step 5: Generate ELF binary
        generate_elf_binary()

        # Step 6: Write to file
        write_output_file()

        if state.error_count == 0 {
          emit link_complete {
            output_file: state.output_file,
            file_size: vec_len(state.output_buffer),
            entry_point: state.entry_point
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STEP 1: CALCULATE LAYOUT
      # ─────────────────────────────────────────────────────────────────────────

      rule calculate_layout() {
        # ELF Header at offset 0 (64 bytes)
        # Program Headers at offset 64 (2 headers * 56 bytes = 112 bytes)
        # Total headers: 64 + 112 = 176 bytes (0xB0)

        let headers_size = ELF_HEADER_SIZE + (2 * PROGRAM_HEADER_SIZE)

        # .text section starts at page boundary after headers
        state.text_file_offset = align_up(headers_size as u64, PAGE_SIZE)
        state.text_vaddr = BASE_ADDRESS + state.text_file_offset

        # Entry point is start of .text
        state.entry_point = state.text_vaddr

        # .rodata follows .text, aligned to 16 bytes
        let text_end = state.text_file_offset + (vec_len(state.text_data) as u64)
        state.rodata_file_offset = align_up(text_end, 16)
        state.rodata_vaddr = BASE_ADDRESS + state.rodata_file_offset

        # .data follows .rodata, aligned to 8 bytes
        let rodata_end = state.rodata_file_offset + (vec_len(state.rodata_data) as u64)
        state.data_file_offset = align_up(rodata_end, 8)
        state.data_vaddr = BASE_ADDRESS + state.data_file_offset

        # .bss follows .data (not in file, only in memory)
        let data_end = state.data_file_offset + (vec_len(state.data_data) as u64)
        state.bss_vaddr = BASE_ADDRESS + align_up(data_end, 8)
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STEP 2: FINALIZE SYMBOL ADDRESSES
      # ─────────────────────────────────────────────────────────────────────────

      rule finalize_symbol_addresses() {
        for i in 0..vec_len(state.symbols) {
          let sym = state.symbols[i]

          # Calculate virtual address based on section
          let base_vaddr = match sym.section {
            ".text" => state.text_vaddr
            ".rodata" => state.rodata_vaddr
            ".data" => state.data_vaddr
            ".bss" => state.bss_vaddr
            _ => state.text_vaddr  # Default to .text
          }

          sym.vaddr = base_vaddr + (sym.offset as u64)
          state.symbols[i] = sym
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STEP 3: APPLY RELOCATIONS
      # ─────────────────────────────────────────────────────────────────────────

      rule apply_relocations() {
        for reloc in state.relocations {
          # Find symbol address
          let symbol_vaddr = find_symbol_address(reloc.symbol)
          if symbol_vaddr == 0 {
            emit link_error {
              message: format("Undefined symbol: {}", reloc.symbol),
              symbol: reloc.symbol
            }
            state.error_count = state.error_count + 1
            continue
          }

          # Calculate relocation address
          let reloc_section_vaddr = match reloc.section {
            ".text" => state.text_vaddr
            ".rodata" => state.rodata_vaddr
            ".data" => state.data_vaddr
            _ => state.text_vaddr
          }

          let reloc_vaddr = reloc_section_vaddr + (reloc.offset as u64)

          # Apply relocation based on type
          match reloc.reloc_type {
            RelocationType::R_X86_64_PC32 => {
              # PC-relative 32-bit: S + A - P
              # P = address of next instruction (reloc_vaddr + 4)
              let next_instr = reloc_vaddr + 4
              let value = (symbol_vaddr as i64) + reloc.addend - (next_instr as i64)

              # Patch in .text section
              if reloc.section == ".text" {
                patch_i32(state.text_data, reloc.offset, value as i32)
              }
            }
            RelocationType::R_X86_64_64 => {
              # 64-bit absolute: S + A
              let value = (symbol_vaddr as i64) + reloc.addend

              if reloc.section == ".text" {
                patch_i64(state.text_data, reloc.offset, value)
              } else if reloc.section == ".data" {
                patch_i64(state.data_data, reloc.offset, value)
              }
            }
            RelocationType::R_X86_64_32 => {
              # 32-bit absolute: S + A
              let value = (symbol_vaddr as i64) + reloc.addend

              if reloc.section == ".text" {
                patch_i32(state.text_data, reloc.offset, value as i32)
              }
            }
            RelocationType::R_X86_64_32S => {
              # 32-bit signed: S + A
              let value = (symbol_vaddr as i64) + reloc.addend

              if reloc.section == ".text" {
                patch_i32(state.text_data, reloc.offset, value as i32)
              }
            }
            _ => {
              # Unsupported relocation type
            }
          }
        }
      }

      rule find_symbol_address(name: string) -> u64 {
        for sym in state.symbols {
          if sym.name == name {
            return sym.vaddr
          }
        }
        # Symbol not found
        return 0
      }

      rule patch_i32(data: vec<u8>, offset: u32, value: i32) {
        data[offset] = (value & 0xFF) as u8
        data[offset + 1] = ((value >> 8) & 0xFF) as u8
        data[offset + 2] = ((value >> 16) & 0xFF) as u8
        data[offset + 3] = ((value >> 24) & 0xFF) as u8
      }

      rule patch_i64(data: vec<u8>, offset: u32, value: i64) {
        data[offset] = (value & 0xFF) as u8
        data[offset + 1] = ((value >> 8) & 0xFF) as u8
        data[offset + 2] = ((value >> 16) & 0xFF) as u8
        data[offset + 3] = ((value >> 24) & 0xFF) as u8
        data[offset + 4] = ((value >> 32) & 0xFF) as u8
        data[offset + 5] = ((value >> 40) & 0xFF) as u8
        data[offset + 6] = ((value >> 48) & 0xFF) as u8
        data[offset + 7] = ((value >> 56) & 0xFF) as u8
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STEP 4: BUILD STRING TABLES
      # ─────────────────────────────────────────────────────────────────────────

      rule build_string_tables() {
        # Build section name string table (.shstrtab)
        # Format: \0.text\0.rodata\0.data\0.bss\0.symtab\0.strtab\0.shstrtab\0

        state.shstrtab = vec_new()
        vec_push(state.shstrtab, 0u8)  # Index 0: empty string

        # Add section names
        add_string_to_table(state.shstrtab, ".text")      # Offset 1
        add_string_to_table(state.shstrtab, ".rodata")    # Offset 7
        add_string_to_table(state.shstrtab, ".data")      # Offset 15
        add_string_to_table(state.shstrtab, ".bss")       # Offset 21
        add_string_to_table(state.shstrtab, ".symtab")    # Offset 26
        add_string_to_table(state.shstrtab, ".strtab")    # Offset 34
        add_string_to_table(state.shstrtab, ".shstrtab")  # Offset 42

        # Build symbol string table (.strtab)
        state.strtab = vec_new()
        vec_push(state.strtab, 0u8)  # Index 0: empty string

        for sym in state.symbols {
          add_string_to_table(state.strtab, sym.name)
        }
      }

      rule add_string_to_table(table: vec<u8>, s: string) {
        for i in 0..string_len(s) {
          vec_push(table, char_at(s, i) as u8)
        }
        vec_push(table, 0u8)  # Null terminator
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STEP 5: GENERATE ELF BINARY
      # ─────────────────────────────────────────────────────────────────────────

      rule generate_elf_binary() {
        state.output_buffer = vec_new()

        # Generate ELF header
        generate_elf_header()

        # Generate program headers
        generate_program_headers()

        # Pad to .text file offset
        pad_to_offset(state.text_file_offset as u32)

        # Write .text section
        for byte in state.text_data {
          vec_push(state.output_buffer, byte)
        }

        # Pad to .rodata file offset
        pad_to_offset(state.rodata_file_offset as u32)

        # Write .rodata section
        for byte in state.rodata_data {
          vec_push(state.output_buffer, byte)
        }

        # Pad to .data file offset (if we have data)
        if vec_len(state.data_data) > 0 {
          pad_to_offset(state.data_file_offset as u32)

          # Write .data section
          for byte in state.data_data {
            vec_push(state.output_buffer, byte)
          }
        }

        # Note: .bss is not written to file (only takes memory at runtime)

        # For a minimal executable, we can skip section headers
        # They're only needed for debugging/linking, not execution
      }

      rule generate_elf_header() {
        # ELF Header: 64 bytes

        # e_ident[0..4]: Magic number
        vec_push(state.output_buffer, 0x7F)
        vec_push(state.output_buffer, 0x45)  # 'E'
        vec_push(state.output_buffer, 0x4C)  # 'L'
        vec_push(state.output_buffer, 0x46)  # 'F'

        # e_ident[4]: Class (64-bit)
        vec_push(state.output_buffer, 0x02)

        # e_ident[5]: Data (little-endian)
        vec_push(state.output_buffer, 0x01)

        # e_ident[6]: Version
        vec_push(state.output_buffer, 0x01)

        # e_ident[7]: OS/ABI (SYSV)
        vec_push(state.output_buffer, 0x00)

        # e_ident[8..16]: Padding
        for i in 0..8 {
          vec_push(state.output_buffer, 0x00)
        }

        # e_type: ET_EXEC (executable)
        write_u16_le(state.output_buffer, 0x0002)

        # e_machine: x86-64
        write_u16_le(state.output_buffer, 0x003E)

        # e_version: 1
        write_u32_le(state.output_buffer, 0x00000001)

        # e_entry: Entry point address
        write_u64_le(state.output_buffer, state.entry_point)

        # e_phoff: Program header offset (64 = right after ELF header)
        write_u64_le(state.output_buffer, 64)

        # e_shoff: Section header offset (0 = no section headers for minimal)
        write_u64_le(state.output_buffer, 0)

        # e_flags: 0
        write_u32_le(state.output_buffer, 0)

        # e_ehsize: ELF header size (64)
        write_u16_le(state.output_buffer, 64)

        # e_phentsize: Program header entry size (56)
        write_u16_le(state.output_buffer, 56)

        # e_phnum: Number of program headers (2: code + data)
        let phnum = if vec_len(state.data_data) > 0 || state.bss_size > 0 { 2 } else { 1 }
        write_u16_le(state.output_buffer, phnum as u16)

        # e_shentsize: Section header entry size (64)
        write_u16_le(state.output_buffer, 64)

        # e_shnum: Number of section headers (0 for minimal)
        write_u16_le(state.output_buffer, 0)

        # e_shstrndx: Section name string table index (0)
        write_u16_le(state.output_buffer, 0)
      }

      rule generate_program_headers() {
        # Program Header 1: Code segment (PT_LOAD, R+X)
        # Covers ELF header + program headers + .text + .rodata

        let code_segment_end = state.rodata_file_offset + (vec_len(state.rodata_data) as u64)
        let code_filesz = code_segment_end
        let code_memsz = code_filesz

        # p_type: PT_LOAD
        write_u32_le(state.output_buffer, 1)

        # p_flags: PF_R | PF_X (readable + executable)
        write_u32_le(state.output_buffer, 5)

        # p_offset: File offset (0 - include headers)
        write_u64_le(state.output_buffer, 0)

        # p_vaddr: Virtual address
        write_u64_le(state.output_buffer, BASE_ADDRESS)

        # p_paddr: Physical address (same as vaddr)
        write_u64_le(state.output_buffer, BASE_ADDRESS)

        # p_filesz: Size in file
        write_u64_le(state.output_buffer, code_filesz)

        # p_memsz: Size in memory
        write_u64_le(state.output_buffer, code_memsz)

        # p_align: Page alignment
        write_u64_le(state.output_buffer, PAGE_SIZE)

        # Program Header 2: Data segment (PT_LOAD, R+W) - if we have data
        if vec_len(state.data_data) > 0 || state.bss_size > 0 {
          let data_filesz = vec_len(state.data_data) as u64
          let data_memsz = data_filesz + (state.bss_size as u64)

          # p_type: PT_LOAD
          write_u32_le(state.output_buffer, 1)

          # p_flags: PF_R | PF_W (readable + writable)
          write_u32_le(state.output_buffer, 6)

          # p_offset: File offset
          write_u64_le(state.output_buffer, state.data_file_offset)

          # p_vaddr: Virtual address
          write_u64_le(state.output_buffer, state.data_vaddr)

          # p_paddr: Physical address
          write_u64_le(state.output_buffer, state.data_vaddr)

          # p_filesz: Size in file
          write_u64_le(state.output_buffer, data_filesz)

          # p_memsz: Size in memory (includes .bss)
          write_u64_le(state.output_buffer, data_memsz)

          # p_align: Page alignment
          write_u64_le(state.output_buffer, PAGE_SIZE)
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STEP 6: WRITE OUTPUT FILE
      # ─────────────────────────────────────────────────────────────────────────

      rule write_output_file() {
        # Write the output buffer to file
        # In a real implementation, this would use a file I/O system
        # For now, we emit the binary data as a signal

        # The runtime would handle:
        # write_file(state.output_file, state.output_buffer)
        # chmod(state.output_file, 0o755)
      }

      # ─────────────────────────────────────────────────────────────────────────
      # HELPER FUNCTIONS
      # ─────────────────────────────────────────────────────────────────────────

      rule align_up(value: u64, alignment: u64) -> u64 {
        if alignment == 0 {
          return value
        }
        return ((value + alignment - 1) / alignment) * alignment
      }

      rule pad_to_offset(target_offset: u32) {
        while vec_len(state.output_buffer) < target_offset {
          vec_push(state.output_buffer, 0u8)
        }
      }

      rule write_u16_le(buffer: vec<u8>, value: u16) {
        vec_push(buffer, (value & 0xFF) as u8)
        vec_push(buffer, ((value >> 8) & 0xFF) as u8)
      }

      rule write_u32_le(buffer: vec<u8>, value: u32) {
        vec_push(buffer, (value & 0xFF) as u8)
        vec_push(buffer, ((value >> 8) & 0xFF) as u8)
        vec_push(buffer, ((value >> 16) & 0xFF) as u8)
        vec_push(buffer, ((value >> 24) & 0xFF) as u8)
      }

      rule write_u64_le(buffer: vec<u8>, value: u64) {
        vec_push(buffer, (value & 0xFF) as u8)
        vec_push(buffer, ((value >> 8) & 0xFF) as u8)
        vec_push(buffer, ((value >> 16) & 0xFF) as u8)
        vec_push(buffer, ((value >> 24) & 0xFF) as u8)
        vec_push(buffer, ((value >> 32) & 0xFF) as u8)
        vec_push(buffer, ((value >> 40) & 0xFF) as u8)
        vec_push(buffer, ((value >> 48) & 0xFF) as u8)
        vec_push(buffer, ((value >> 56) & 0xFF) as u8)
      }

      rule get_section_name_offset(name: string) -> u32 {
        # Return offset of section name in .shstrtab
        match name {
          ".text" => 1
          ".rodata" => 7
          ".data" => 15
          ".bss" => 21
          ".symtab" => 26
          ".strtab" => 34
          ".shstrtab" => 42
          _ => 0
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # OPTIONAL: FULL ELF WITH SECTION HEADERS
      # ─────────────────────────────────────────────────────────────────────────

      rule generate_full_elf_binary() {
        # This generates a complete ELF with section headers
        # Useful for debugging with objdump, readelf, etc.

        state.output_buffer = vec_new()

        # Calculate section header table offset
        let data_end = state.data_file_offset + (vec_len(state.data_data) as u64)
        let symtab_offset = align_up(data_end, 8)
        let symtab_size = vec_len(state.symbols) * SYMBOL_ENTRY_SIZE
        let strtab_offset = symtab_offset + (symtab_size as u64)
        let strtab_size = vec_len(state.strtab)
        let shstrtab_offset = strtab_offset + (strtab_size as u64)
        let shstrtab_size = vec_len(state.shstrtab)
        let shdr_offset = align_up(shstrtab_offset + (shstrtab_size as u64), 8)

        # Number of sections: null + .text + .rodata + .data + .bss + .symtab + .strtab + .shstrtab = 8
        let section_count = 8u16

        # Generate ELF header with section headers
        generate_elf_header_full(shdr_offset, section_count)

        # Generate program headers
        generate_program_headers()

        # Write sections
        pad_to_offset(state.text_file_offset as u32)
        for byte in state.text_data {
          vec_push(state.output_buffer, byte)
        }

        pad_to_offset(state.rodata_file_offset as u32)
        for byte in state.rodata_data {
          vec_push(state.output_buffer, byte)
        }

        if vec_len(state.data_data) > 0 {
          pad_to_offset(state.data_file_offset as u32)
          for byte in state.data_data {
            vec_push(state.output_buffer, byte)
          }
        }

        # Write symbol table
        pad_to_offset(symtab_offset as u32)
        generate_symbol_table()

        # Write string table
        pad_to_offset(strtab_offset as u32)
        for byte in state.strtab {
          vec_push(state.output_buffer, byte)
        }

        # Write section name string table
        pad_to_offset(shstrtab_offset as u32)
        for byte in state.shstrtab {
          vec_push(state.output_buffer, byte)
        }

        # Write section headers
        pad_to_offset(shdr_offset as u32)
        generate_section_headers(symtab_offset, strtab_offset, shstrtab_offset)
      }

      rule generate_elf_header_full(shdr_offset: u64, section_count: u16) {
        # Same as generate_elf_header but with section headers

        # e_ident[0..4]: Magic number
        vec_push(state.output_buffer, 0x7F)
        vec_push(state.output_buffer, 0x45)
        vec_push(state.output_buffer, 0x4C)
        vec_push(state.output_buffer, 0x46)

        # e_ident[4..16]
        vec_push(state.output_buffer, 0x02)  # 64-bit
        vec_push(state.output_buffer, 0x01)  # Little-endian
        vec_push(state.output_buffer, 0x01)  # Version
        vec_push(state.output_buffer, 0x00)  # OS/ABI
        for i in 0..8 {
          vec_push(state.output_buffer, 0x00)
        }

        write_u16_le(state.output_buffer, 0x0002)  # ET_EXEC
        write_u16_le(state.output_buffer, 0x003E)  # x86-64
        write_u32_le(state.output_buffer, 0x00000001)  # Version
        write_u64_le(state.output_buffer, state.entry_point)  # Entry
        write_u64_le(state.output_buffer, 64)  # Program header offset
        write_u64_le(state.output_buffer, shdr_offset)  # Section header offset
        write_u32_le(state.output_buffer, 0)  # Flags
        write_u16_le(state.output_buffer, 64)  # ELF header size
        write_u16_le(state.output_buffer, 56)  # Program header size
        write_u16_le(state.output_buffer, 2)   # Number of program headers
        write_u16_le(state.output_buffer, 64)  # Section header size
        write_u16_le(state.output_buffer, section_count)  # Number of section headers
        write_u16_le(state.output_buffer, 7)   # Section name string table index (.shstrtab)
      }

      rule generate_symbol_table() {
        # First entry: null symbol
        for i in 0..24 {
          vec_push(state.output_buffer, 0u8)
        }

        # Symbol entries
        let strtab_offset = 1u32  # Start after null byte
        for sym in state.symbols {
          # st_name: Offset in string table
          write_u32_le(state.output_buffer, strtab_offset)
          strtab_offset = strtab_offset + (string_len(sym.name) as u32) + 1

          # st_info: Binding and type
          let binding = if sym.is_global { STB_GLOBAL } else { STB_LOCAL }
          let stype = STT_FUNC  # Assume functions for now
          vec_push(state.output_buffer, (binding << 4) | stype)

          # st_other: 0 (default visibility)
          vec_push(state.output_buffer, 0u8)

          # st_shndx: Section index
          let shndx = match sym.section {
            ".text" => 1u16
            ".rodata" => 2u16
            ".data" => 3u16
            ".bss" => 4u16
            _ => 0u16
          }
          write_u16_le(state.output_buffer, shndx)

          # st_value: Symbol address
          write_u64_le(state.output_buffer, sym.vaddr)

          # st_size: 0 (unknown)
          write_u64_le(state.output_buffer, 0)
        }
      }

      rule generate_section_headers(symtab_offset: u64, strtab_offset: u64, shstrtab_offset: u64) {
        # Section 0: NULL
        generate_null_section_header()

        # Section 1: .text
        generate_section_header(
          get_section_name_offset(".text"),
          SHT_PROGBITS,
          SHF_ALLOC | SHF_EXECINSTR,
          state.text_vaddr,
          state.text_file_offset,
          vec_len(state.text_data) as u64,
          0, 0, 16, 0
        )

        # Section 2: .rodata
        generate_section_header(
          get_section_name_offset(".rodata"),
          SHT_PROGBITS,
          SHF_ALLOC,
          state.rodata_vaddr,
          state.rodata_file_offset,
          vec_len(state.rodata_data) as u64,
          0, 0, 8, 0
        )

        # Section 3: .data
        generate_section_header(
          get_section_name_offset(".data"),
          SHT_PROGBITS,
          SHF_ALLOC | SHF_WRITE,
          state.data_vaddr,
          state.data_file_offset,
          vec_len(state.data_data) as u64,
          0, 0, 8, 0
        )

        # Section 4: .bss
        generate_section_header(
          get_section_name_offset(".bss"),
          SHT_NOBITS,
          SHF_ALLOC | SHF_WRITE,
          state.bss_vaddr,
          0,  # No file offset for .bss
          state.bss_size as u64,
          0, 0, 8, 0
        )

        # Section 5: .symtab
        generate_section_header(
          get_section_name_offset(".symtab"),
          SHT_SYMTAB,
          0,
          0,
          symtab_offset,
          ((vec_len(state.symbols) + 1) * SYMBOL_ENTRY_SIZE) as u64,
          6,  # Link to .strtab
          1,  # First global symbol index
          8,
          SYMBOL_ENTRY_SIZE as u64
        )

        # Section 6: .strtab
        generate_section_header(
          get_section_name_offset(".strtab"),
          SHT_STRTAB,
          0,
          0,
          strtab_offset,
          vec_len(state.strtab) as u64,
          0, 0, 1, 0
        )

        # Section 7: .shstrtab
        generate_section_header(
          get_section_name_offset(".shstrtab"),
          SHT_STRTAB,
          0,
          0,
          shstrtab_offset,
          vec_len(state.shstrtab) as u64,
          0, 0, 1, 0
        )
      }

      rule generate_null_section_header() {
        for i in 0..64 {
          vec_push(state.output_buffer, 0u8)
        }
      }

      rule generate_section_header(
        sh_name: u32,
        sh_type: u32,
        sh_flags: u64,
        sh_addr: u64,
        sh_offset: u64,
        sh_size: u64,
        sh_link: u32,
        sh_info: u32,
        sh_addralign: u64,
        sh_entsize: u64
      ) {
        write_u32_le(state.output_buffer, sh_name)
        write_u32_le(state.output_buffer, sh_type)
        write_u64_le(state.output_buffer, sh_flags)
        write_u64_le(state.output_buffer, sh_addr)
        write_u64_le(state.output_buffer, sh_offset)
        write_u64_le(state.output_buffer, sh_size)
        write_u32_le(state.output_buffer, sh_link)
        write_u32_le(state.output_buffer, sh_info)
        write_u64_le(state.output_buffer, sh_addralign)
        write_u64_le(state.output_buffer, sh_entsize)
      }
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TOPOLOGY
  # ═══════════════════════════════════════════════════════════════════════════

  topology {
    spawn linker as Linker

    # Input: Receive from Assembler
    socket machine_code_in -> Linker (frequency: machine_code)
    socket reloc_in -> Linker (frequency: relocation)
    socket symbol_in -> Linker (frequency: symbol_def)
    socket section_in -> Linker (frequency: section_info)
    socket asm_done -> Linker (frequency: asm_complete)

    # Output: Linking results
    socket Linker -> link_done (frequency: link_complete)
    socket Linker -> link_errors (frequency: link_error)
  }
}
