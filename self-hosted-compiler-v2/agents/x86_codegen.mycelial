    hyphal x86_codegen {
      frequency tidal_cycle

      state {
        # Buffered input
        ir_instructions: vec<IRInstruction>
        current_function: string
        current_params: vec<Parameter>
        current_return_type: Type

        # Register allocation state
        live_intervals: vec<LiveInterval>
        active_intervals: vec<LiveInterval>
        allocation: map<string, string>      # vreg -> physical reg
        spill_slots: map<string, i32>        # vreg -> stack offset
        next_spill_offset: i32

        # Output tracking
        asm_count: u32
        function_count: u32

        # Physical register pool (System V AMD64 allocatable)
        available_regs: vec<string>
        callee_saved_regs: vec<string>
        caller_saved_regs: vec<string>

        # Argument registers
        arg_regs: vec<string>

        # Buffered LIR function names (received via signals)
        lir_function_names: vec<string>

        # Label counter for generating unique labels
        label_counter: u32

        # String literal tracking
        string_literals: vec<string>
        string_count: u32

        # Rest handler tracking (for scheduler_run to call)
        rest_handlers: vec<string>

        # Startup signal handler tracking (called from main after init)
        startup_handlers: vec<string>

        # Current context for name resolution
        current_network: string
        current_hyphal: string

        # State field tracking for current hyphal
        # Maps field name -> offset in state struct
        state_field_offsets: map<string, u32>
        state_struct_size: u32

        # Track all hyphals for init_agents generation
        hyphal_names: vec<string>
        hyphal_init_funcs: vec<string>
      }

      # -------------------------------------------------------------------------
      # INITIALIZATION
      # -------------------------------------------------------------------------

      on rest {
        # Initialize register pools (run once on first cycle)
        if vec_len(state.available_regs) == 0 {
          # Allocatable registers (10 total)
          state.available_regs = vec_from(
            "r10", "r11",     # Scratch (prefer these first)
            "rbx", "r15",     # Callee-saved
            "rax", "rcx", "rdx", "rsi", "rdi",  # Caller-saved
            "r8", "r9"        # More caller-saved
          )

          # Callee-saved (must preserve)
          state.callee_saved_regs = vec_from("rbx", "r12", "r13", "r14", "r15")

          # Caller-saved (can clobber)
          state.caller_saved_regs = vec_from(
            "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
          )

          # Argument passing order (System V AMD64)
          state.arg_regs = vec_from("rdi", "rsi", "rdx", "rcx", "r8", "r9")

          # Initialize rest handler tracking
          state.rest_handlers = vec_new()

          # Initialize startup handler tracking
          state.startup_handlers = vec_new()

          # Initialize state field tracking
          state.state_field_offsets = map_new()
          state.state_struct_size = 0

          # Initialize hyphal tracking
          state.hyphal_names = vec_new()
          state.hyphal_init_funcs = vec_new()
        }
      }

      # -------------------------------------------------------------------------
      # SIGNAL HANDLERS - SENSE PHASE
      # -------------------------------------------------------------------------

      on signal(ir_function_start, func) {
        # New function starting
        state.current_function = func.name
        state.current_params = func.params
        state.current_return_type = func.return_type

        # Reset per-function state
        vec_clear(state.ir_instructions)
        vec_clear(state.live_intervals)
        vec_clear(state.active_intervals)
        map_clear(state.allocation)
        map_clear(state.spill_slots)
        state.next_spill_offset = -8  # First spill slot at [rbp-8]
      }

      on signal(ir_node, node) {
        # Buffer IR instruction
        vec_push(state.ir_instructions, node.instruction)
      }

      on signal(ir_function_end, func) {
        # Function complete - generate code
        generate_function(func.name)
        state.function_count = state.function_count + 1
      }

      on signal(lir_function, func) {
        # Buffer the function name for later code generation
        vec_push(state.lir_function_names, func.name)
      }

      # Direct AST → x86 code generation
      on signal(ast_complete, ast) {
        # Walk the AST directly and generate code
        let items: vec<ProgramItem> = ast.items
        let i: u32 = 0
        let item_count: u32 = vec_len(items)

        while i < item_count {
          let item: ProgramItem = vec_get(items, i)
          match item {
            ProgramItem::Network(net_def) => {
              # Generate code for each hyphal in the network
              generate_network_code(net_def)
            }
            _ => {
              # Skip other items
            }
          }
          i = i + 1
        }

        # Generate init_agents and num_agents for this program
        generate_num_agents()
        generate_init_agents()

        # Generate the basic stubs
        generate_runtime_stubs()
        generate_builtins()
        generate_start_function()
        generate_main_function()

        emit codegen_complete {
          instruction_count: state.asm_count,
          function_count: state.function_count
        }
      }

      on signal(ir_complete, irc) {
        # Legacy IR path - kept for compatibility but bypassed by direct AST path
        # Do nothing here since ast_complete handles code generation
      }

      # -------------------------------------------------------------------------
      # CODE GENERATION - ACT PHASE
      # -------------------------------------------------------------------------

      rule generate_function_stub(func_name: string) {
        # Generate a simple stub function that just returns
        # Using AT&T syntax: mnemonic src, dest with % prefixes
        emit asm_instruction { label: func_name, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbp", "%rsp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        state.function_count = state.function_count + 1
      }

      # -------------------------------------------------------------------------
      # DIRECT AST → x86 CODE GENERATION
      # -------------------------------------------------------------------------

      rule generate_network_code(net_def: NetworkDef) {
        # Generate code for each hyphal in the network
        let net_name: string = net_def.name
        let hyphae: vec<HyphalDef> = net_def.hyphae
        let h: u32 = 0
        let hyphal_count: u32 = vec_len(hyphae)

        while h < hyphal_count {
          let hyphal: HyphalDef = vec_get(hyphae, h)
          generate_hyphal_code(net_name, hyphal)
          h = h + 1
        }
      }

      rule build_state_layout(state_fields: vec<StateField>) {
        # Build a map of field name -> offset for the hyphal's state struct
        # All fields are 8 bytes (pointers/u64) for simplicity
        state.state_field_offsets = map_new()
        state.state_struct_size = 0

        # Note: state_fields is passed directly to avoid nested struct access bug
        let fields: vec<StateField> = state_fields
        let f: u32 = 0
        let field_count: u32 = vec_len(fields)

        while f < field_count {
          let field: StateField = vec_get(fields, f)
          map_set(state.state_field_offsets, field.name, state.state_struct_size)
          # All fields are 8 bytes (u64/pointer)
          state.state_struct_size = state.state_struct_size + 8
          f = f + 1
        }

        # Minimum size of 8 bytes (for empty state)
        if state.state_struct_size == 0 {
          state.state_struct_size = 8
        }
      }

      rule generate_state_data(state_label: string) {
        # Generate a .bss section entry for the state struct
        emit asm_section { name: ".bss" }

        # Generate space for the state struct
        # Using .space directive with size
        let size_str: string = u32_to_string(state.state_struct_size)
        emit asm_data {
          label: state_label,
          data_type: "space",
          value: size_str,
          section: ".bss"
        }

        # Switch back to .text
        emit asm_section { name: ".text" }
      }

      rule generate_hyphal_code(net_name: string, hyphal: HyphalDef) {
        # Generate init, dispatch, rule, and method functions
        let hyphal_name: string = hyphal.name

        # Set current context for name resolution in nested calls
        state.current_network = net_name
        state.current_hyphal = hyphal_name

        # Build state field layout
        # Access state.fields directly to work around embedded struct access bug
        let hyphal_state: StateBlock = hyphal.state
        build_state_layout(hyphal_state.fields)

        # Generate state data symbol (global storage for this hyphal's state)
        let state_label: string = net_name
        state_label = string_concat(state_label, "_")
        state_label = string_concat(state_label, hyphal_name)
        state_label = string_concat(state_label, "_state")
        generate_state_data(state_label)

        # Track hyphal for init_agents
        vec_push(state.hyphal_names, hyphal_name)

        # Generate init function
        let init_name: string = net_name
        init_name = string_concat(init_name, "_")
        init_name = string_concat(init_name, hyphal_name)
        init_name = string_concat(init_name, "_init")
        vec_push(state.hyphal_init_funcs, init_name)
        generate_hyphal_init(init_name, hyphal)

        # Generate dispatch function
        let dispatch_name: string = net_name
        dispatch_name = string_concat(dispatch_name, "_")
        dispatch_name = string_concat(dispatch_name, hyphal_name)
        dispatch_name = string_concat(dispatch_name, "_dispatch")
        generate_hyphal_dispatch(dispatch_name, hyphal)

        # Generate code for each rule
        let rules: vec<Rule> = hyphal.rules
        let r: u32 = 0
        let rule_count: u32 = vec_len(rules)
        while r < rule_count {
          let rule_def: Rule = vec_get(rules, r)
          generate_rule_code(net_name, hyphal_name, rule_def, r)
          r = r + 1
        }

        # Generate code for each method
        let methods: vec<MethodDef> = hyphal.methods
        let m: u32 = 0
        let method_count: u32 = vec_len(methods)
        while m < method_count {
          let method: MethodDef = vec_get(methods, m)
          generate_method_code(net_name, hyphal_name, method)
          m = m + 1
        }
      }

      rule generate_hyphal_init(func_name: string, hyphal: HyphalDef) {
        # Generate function that initializes hyphal state
        # For maps and vectors, call constructor and store to state field
        emit asm_instruction { label: func_name, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        state.asm_count = state.asm_count + 1

        # Get state label for this hyphal
        let state_label: string = state.current_network
        state_label = string_concat(state_label, "_")
        state_label = string_concat(state_label, state.current_hyphal)
        state_label = string_concat(state_label, "_state")

        # Initialize each field based on type
        let state_block: StateBlock = hyphal.state
        let fields: vec<StateField> = state_block.fields
        let f: u32 = 0
        let field_count: u32 = vec_len(fields)

        while f < field_count {
          let field: StateField = vec_get(fields, f)
          let field_type: TypeRef = field.field_type
          let offset: u32 = 0
          if map_has(state.state_field_offsets, field.name) {
            offset = map_get(state.state_field_offsets, field.name)
          }

          # Generate store address: offset+state_label(%rip)
          let offset_label: string = ""
          if offset > 0 {
            offset_label = u32_to_string(offset)
            offset_label = string_concat(offset_label, "+")
          }
          offset_label = string_concat(offset_label, state_label)
          offset_label = string_concat(offset_label, "(%rip)")

          # Check type and generate initialization
          let type_name: string = get_type_name(field_type)
          if type_name == "map<>" {
            # Call map_new() and store result
            emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("builtin_map_new") }
            emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", offset_label) }
            state.asm_count = state.asm_count + 2
          } else if type_name == "vec<>" {
            # Call vec_new() and store result
            emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("builtin_vec_new") }
            emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", offset_label) }
            state.asm_count = state.asm_count + 2
          }
          # For primitives (u32, i32, etc.), BSS zero-init is sufficient

          f = f + 1
        }

        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbp", "%rsp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        state.function_count = state.function_count + 1
      }

      rule get_type_name(type_ref: TypeRef) -> string {
        # Extract the type name from a TypeRef
        match type_ref {
          TypeRef::Primitive(_prim) => "primitive"
          TypeRef::Vec(_inner) => "vec<>"
          TypeRef::Queue(_inner) => "queue<>"
          TypeRef::Map(_k, _v) => "map<>"
          TypeRef::Custom(name) => name
          TypeRef::None => "none"
        }
      }

      rule generate_hyphal_dispatch(func_name: string, hyphal: HyphalDef) {
        # Generate function that dispatches signals to handlers
        # rdi = pointer to state struct
        # rsi = signal type (enum value)
        # rdx = pointer to signal data
        emit asm_instruction { label: func_name, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        state.asm_count = state.asm_count + 1

        # For now, just return 0 (no signal handled)
        # Full implementation would check signal type and call appropriate handler
        emit asm_instruction { label: "", mnemonic: "xorl", operands: vec_from("%eax", "%eax") }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbp", "%rsp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        state.function_count = state.function_count + 1
      }

      rule generate_rule_code(net_name: string, hyphal_name: string, rule_def: Rule, rule_idx: u32) {
        # Generate function for a rule (signal handler)
        let func_name: string = net_name
        func_name = string_concat(func_name, "_")
        func_name = string_concat(func_name, hyphal_name)
        func_name = string_concat(func_name, "_rule_")
        func_name = string_concat(func_name, u32_to_string(rule_idx))

        # Track handlers so scheduler_run can call them
        let trigger: RuleTrigger = rule_def.trigger
        match trigger {
          RuleTrigger::Rest => {
            vec_push(state.rest_handlers, func_name)
          }
          RuleTrigger::Signal(signal_match) => {
            # Track startup signal handlers to call from main()
            if signal_match.frequency == "startup" {
              vec_push(state.startup_handlers, func_name)
            }
          }
          RuleTrigger::Cycle(_n) => {
            # Cycle handlers - not tracked for simple bootstrap
          }
        }

        emit asm_instruction { label: func_name, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        state.asm_count = state.asm_count + 1

        # Generate code for rule body statements
        let body: vec<Statement> = rule_def.body
        generate_statements(body)

        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbp", "%rsp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        state.function_count = state.function_count + 1
      }

      rule generate_method_code(net_name: string, hyphal_name: string, method: MethodDef) {
        # Generate function for a method (rule with parameters)
        let func_name: string = net_name
        func_name = string_concat(func_name, "_")
        func_name = string_concat(func_name, hyphal_name)
        func_name = string_concat(func_name, "_")
        func_name = string_concat(func_name, method.name)

        emit asm_instruction { label: func_name, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        state.asm_count = state.asm_count + 1

        # Generate code for method body statements
        let body: vec<Statement> = method.body
        generate_statements(body)

        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbp", "%rsp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        state.function_count = state.function_count + 1
      }

      rule generate_statements(stmts: vec<Statement>) {
        let s: u32 = 0
        let stmt_count: u32 = vec_len(stmts)
        while s < stmt_count {
          let stmt: Statement = vec_get(stmts, s)
          generate_statement(stmt)
          s = s + 1
        }
      }

      rule generate_statement(stmt: Statement) {
        match stmt {
          Statement::Let(let_stmt) => {
            generate_let_statement(let_stmt)
          }
          Statement::Assignment(assign) => {
            generate_assignment(assign)
          }
          Statement::Conditional(cond_stmt) => {
            generate_if_statement(cond_stmt)
          }
          Statement::WhileLoop(while_stmt) => {
            generate_while_statement(while_stmt)
          }
          Statement::ForLoop(for_stmt) => {
            generate_for_statement(for_stmt)
          }
          Statement::Return(ret_stmt) => {
            generate_return_statement(ret_stmt)
          }
          Statement::Emit(emit_stmt) => {
            generate_emit_statement(emit_stmt)
          }
          Statement::Report(report_stmt) => {
            generate_report_statement(report_stmt)
          }
          Statement::Expression(expr_stmt) => {
            # Expression as statement (e.g., function calls like print("hello"))
            generate_expression(expr_stmt.expression)
          }
          _ => {
            # Unknown statement type - skip for now
          }
        }
      }

      rule generate_let_statement(let_stmt: LetStatement) {
        # Allocate stack space and initialize
        # For now, just generate placeholder
        emit asm_instruction { label: "", mnemonic: "subq", operands: vec_from("$8", "%rsp") }
        state.asm_count = state.asm_count + 1
        # TODO: Generate code to evaluate init_value and store on stack
      }

      rule generate_assignment(assign: AssignmentStatement) {
        # Generate assignment code
        # First evaluate the RHS - result goes in rax
        generate_expression(assign.value)

        # Then store to the target
        let target: AssignmentTarget = assign.target
        match target {
          AssignmentTarget::StateField(field_name) => {
            # Assignment to state field: state.field = value
            # Get the state label for current hyphal
            let state_label: string = state.current_network
            state_label = string_concat(state_label, "_")
            state_label = string_concat(state_label, state.current_hyphal)
            state_label = string_concat(state_label, "_state")

            # Get field offset
            let offset: u32 = 0
            if map_has(state.state_field_offsets, field_name) {
              offset = map_get(state.state_field_offsets, field_name)
            }

            # Generate store: mov %rax, offset+state_label(%rip)
            let offset_label: string = ""
            if offset > 0 {
              offset_label = u32_to_string(offset)
              offset_label = string_concat(offset_label, "+")
            }
            offset_label = string_concat(offset_label, state_label)
            offset_label = string_concat(offset_label, "(%rip)")

            emit asm_instruction {
              label: "",
              mnemonic: "movq",
              operands: vec_from("%rax", offset_label)
            }
            state.asm_count = state.asm_count + 1
          }
          AssignmentTarget::Variable(var_name) => {
            # Assignment to local variable
            # For now, just NOP - proper local var handling needs stack management
            emit asm_instruction { label: "", mnemonic: "nop", operands: vec_new() }
            state.asm_count = state.asm_count + 1
          }
          AssignmentTarget::FieldAccess(object_expr, field_name) => {
            # Assignment to nested field: obj.field = value
            # For state.context.field, we need to:
            # 1. Load the pointer from state.context
            # 2. Store value to offset within that struct

            # Save value (in rax) to r10
            emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%r10") }
            state.asm_count = state.asm_count + 1

            # Load object pointer - evaluate object expression
            generate_expression(object_expr)
            # Now rax has the pointer

            # Get field offset (simplified - assumes 8-byte aligned fields)
            let field_offset: u32 = get_field_offset_for_codegen(object_expr, field_name)

            # Store value to pointer + offset
            let offset_str: string = ""
            if field_offset > 0 {
              offset_str = u32_to_string(field_offset)
              offset_str = string_concat(offset_str, "(%rax)")
            } else {
              offset_str = "(%rax)"
            }

            emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%r10", offset_str) }
            state.asm_count = state.asm_count + 1
          }
          _ => {
            # Other targets not yet implemented
            emit asm_instruction { label: "", mnemonic: "nop", operands: vec_new() }
            state.asm_count = state.asm_count + 1
          }
        }
      }

      rule get_field_offset_for_codegen(object_expr: Expression, field_name: string) -> u32 {
        # Get the field offset for a nested field access
        # For state.X.field, determine the struct type of X and get field offset
        # Simplified: use state.struct_field_offsets map if available
        let key = string_concat(field_name, "")
        if map_has(state.struct_field_offsets, key) {
          return map_get(state.struct_field_offsets, key)
        }
        # Default: assume 8-byte aligned sequential fields
        # This is a fallback - proper implementation needs struct layout info
        return 0
      }

      rule generate_if_statement(if_stmt: ConditionalStatement) {
        # Generate if/else code
        let else_label: string = generate_label("else")
        let end_label: string = generate_label("endif")

        # Evaluate condition (result in rax)
        generate_expression(if_stmt.condition)

        # Test and jump
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rax", "%rax") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(else_label) }
        state.asm_count = state.asm_count + 1

        # Then branch
        generate_statements(if_stmt.then_body)

        # Jump to end
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(end_label) }
        state.asm_count = state.asm_count + 1

        # Else label and branch
        emit asm_instruction { label: else_label, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1
        generate_statements(if_stmt.else_body)

        # End label
        emit asm_instruction { label: end_label, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1
      }

      rule generate_while_statement(while_stmt: WhileLoopStatement) {
        let loop_label: string = generate_label("while")
        let end_label: string = generate_label("endwhile")

        # Loop label
        emit asm_instruction { label: loop_label, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        # Evaluate condition
        generate_expression(while_stmt.condition)

        # Test and jump if false
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rax", "%rax") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(end_label) }
        state.asm_count = state.asm_count + 1

        # Loop body
        generate_statements(while_stmt.body)

        # Jump back to loop
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(loop_label) }
        state.asm_count = state.asm_count + 1

        # End label
        emit asm_instruction { label: end_label, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1
      }

      rule generate_for_statement(for_stmt: ForLoopStatement) {
        # For loops: for i in start..end { body }
        let loop_label: string = generate_label("for")
        let end_label: string = generate_label("endfor")

        # Initialize loop variable (stored on stack)
        emit asm_instruction { label: "", mnemonic: "subq", operands: vec_from("$8", "%rsp") }
        state.asm_count = state.asm_count + 1
        # TODO: Store start value at [rsp]

        # Loop label
        emit asm_instruction { label: loop_label, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1

        # Check if counter < end
        # TODO: Compare [rsp] with end value
        emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("%rbx", "%rax") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "jge", operands: vec_from(end_label) }
        state.asm_count = state.asm_count + 1

        # Loop body
        generate_statements(for_stmt.body)

        # Increment counter
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("(%rsp)") }
        state.asm_count = state.asm_count + 1

        # Jump back
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(loop_label) }
        state.asm_count = state.asm_count + 1

        # End label and cleanup
        emit asm_instruction { label: end_label, mnemonic: "", operands: vec_new() }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("$8", "%rsp") }
        state.asm_count = state.asm_count + 1
      }

      rule generate_return_statement(ret_stmt: ReturnStatement) {
        # Generate return value in rax
        generate_expression(ret_stmt.value)
        # Epilogue handled by caller
      }

      rule generate_emit_statement(emit_stmt: EmitStatement) {
        # Generate emit signal call
        # For bootstrap, emit is a no-op that just evaluates the signal data
        emit asm_instruction { label: "", mnemonic: "nop", operands: vec_new() }
        state.asm_count = state.asm_count + 1
      }

      rule generate_report_statement(report_stmt: ReportStatement) {
        # Generate report output - extract message and call println
        # report status { message: "Hello" } -> println("Hello")

        let val: Expression = report_stmt.value
        match val {
          Expression::StructLiteral(struct_lit) => {
            # Extract the first field value (typically "message")
            let fields: vec<FieldInit> = struct_lit.fields
            if vec_len(fields) > 0 {
              let first_field: FieldInit = vec_get(fields, 0)
              generate_expression(first_field.value)
              # Result in rax, move to rdi for println call
              emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%rdi") }
              emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("println") }
              state.asm_count = state.asm_count + 2
            }
          }
          _ => {
            # Simple expression - evaluate and print
            generate_expression(val)
            emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%rdi") }
            emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("println") }
            state.asm_count = state.asm_count + 2
          }
        }
      }

      rule generate_match_statement(match_stmt: MatchStatement) {
        # Generate match/switch statement
        # For now, just generate placeholder
        emit asm_instruction { label: "", mnemonic: "nop", operands: vec_new() }
        state.asm_count = state.asm_count + 1
      }

      rule generate_expression(expr: Expression) {
        match expr {
          Expression::Literal(lit) => {
            generate_literal(lit)
          }
          Expression::Identifier(id) => {
            generate_identifier(id)
          }
          Expression::BinaryOp(bin) => {
            generate_binary(bin)
          }
          Expression::Call(call) => {
            generate_call(call)
          }
          Expression::FieldAccess(field) => {
            generate_field_access(field)
          }
          Expression::IndexAccess(idx) => {
            generate_index(idx)
          }
          Expression::StateAccess(sa) => {
            generate_state_access(sa)
          }
          _ => {
            # Unknown expression - load 0
            emit asm_instruction { label: "", mnemonic: "xorl", operands: vec_from("%eax", "%eax") }
            state.asm_count = state.asm_count + 1
          }
        }
      }

      rule generate_state_access(sa: StateAccessExpr) {
        # Load value from state field: state.field
        let field_name: string = sa.field

        # Get the state label for current hyphal
        let state_label: string = state.current_network
        state_label = string_concat(state_label, "_")
        state_label = string_concat(state_label, state.current_hyphal)
        state_label = string_concat(state_label, "_state")

        # Get field offset
        let offset: u32 = 0
        if map_has(state.state_field_offsets, field_name) {
          offset = map_get(state.state_field_offsets, field_name)
        }

        # Generate load: mov offset+state_label(%rip), %rax
        let offset_label: string = ""
        if offset > 0 {
          offset_label = u32_to_string(offset)
          offset_label = string_concat(offset_label, "+")
        }
        offset_label = string_concat(offset_label, state_label)
        offset_label = string_concat(offset_label, "(%rip)")

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(offset_label, "%rax")
        }
        state.asm_count = state.asm_count + 1
      }

      rule generate_literal(lit: LiteralExpr) {
        let val: Literal = lit.value
        match val {
          Literal::Number(n) => {
            let imm: string = "$"
            imm = string_concat(imm, i64_to_string(n))
            emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from(imm, "%rax") }
            state.asm_count = state.asm_count + 1
          }
          Literal::String(s) => {
            # Generate unique label for this string
            let str_label: string = format("str_{}", state.string_count)
            state.string_count = state.string_count + 1

            # Store string for later emission to .rodata
            vec_push(state.string_literals, s)

            # Emit the string data immediately to .rodata section
            emit asm_data {
              label: str_label,
              data_type: "asciz",
              value: s,
              section: ".rodata"
            }

            # Load string address
            let addr: string = format("{}(%rip)", str_label)
            emit asm_instruction { label: "", mnemonic: "leaq", operands: vec_from(addr, "%rax") }
            state.asm_count = state.asm_count + 1
          }
          Literal::Bool(b) => {
            if b {
              emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
            } else {
              emit asm_instruction { label: "", mnemonic: "xorl", operands: vec_from("%eax", "%eax") }
            }
            state.asm_count = state.asm_count + 1
          }
          _ => {
            emit asm_instruction { label: "", mnemonic: "xorl", operands: vec_from("%eax", "%eax") }
            state.asm_count = state.asm_count + 1
          }
        }
      }

      rule generate_identifier(id: IdentifierExpr) {
        # Load variable value - for now just load from fixed stack offset
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("-8(%rbp)", "%rax") }
        state.asm_count = state.asm_count + 1
      }

      rule generate_binary(bin: BinaryOpExpr) {
        # Evaluate left operand (result in rax)
        generate_expression(bin.left)
        # Save to stack
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rax") }
        state.asm_count = state.asm_count + 1
        # Evaluate right operand (result in rax)
        generate_expression(bin.right)
        # Move right result to rbx, pop left into rax
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%rbx") }
        state.asm_count = state.asm_count + 1
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rax") }
        state.asm_count = state.asm_count + 1

        # Perform operation based on operator
        match bin.op {
          BinaryOperator::Add => {
            emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
          }
          BinaryOperator::Sub => {
            emit asm_instruction { label: "", mnemonic: "subq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
          }
          BinaryOperator::Mul => {
            emit asm_instruction { label: "", mnemonic: "imulq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
          }
          BinaryOperator::Div => {
            emit asm_instruction { label: "", mnemonic: "xorl", operands: vec_from("%edx", "%edx") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "idivq", operands: vec_from("%rbx") }
            state.asm_count = state.asm_count + 1
          }
          BinaryOperator::Lt => {
            emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "setl", operands: vec_from("%al") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "movzbl", operands: vec_from("%al", "%eax") }
            state.asm_count = state.asm_count + 1
          }
          BinaryOperator::Gt => {
            emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "setg", operands: vec_from("%al") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "movzbl", operands: vec_from("%al", "%eax") }
            state.asm_count = state.asm_count + 1
          }
          BinaryOperator::Eq => {
            emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "sete", operands: vec_from("%al") }
            state.asm_count = state.asm_count + 1
            emit asm_instruction { label: "", mnemonic: "movzbl", operands: vec_from("%al", "%eax") }
            state.asm_count = state.asm_count + 1
          }
          _ => {
            # Unknown op - just add
            emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("%rbx", "%rax") }
            state.asm_count = state.asm_count + 1
          }
        }
      }

      rule generate_call(call: CallExpr) {
        # Generate function call with arguments
        # System V AMD64 ABI: rdi, rsi, rdx, rcx, r8, r9, then stack

        # Determine function name with proper prefixing
        let func_name: string = call.name
        if is_builtin(call.name) {
          # Builtin: prefix with builtin_
          func_name = "builtin_"
          func_name = string_concat(func_name, call.name)
        } else {
          # Non-builtin: prefix with network_hyphal_
          func_name = state.current_network
          func_name = string_concat(func_name, "_")
          func_name = string_concat(func_name, state.current_hyphal)
          func_name = string_concat(func_name, "_")
          func_name = string_concat(func_name, call.name)
        }

        let args: vec<Expression> = call.args
        let arg_count: u32 = vec_len(args)

        # Evaluate arguments in reverse order, push to stack, then pop to registers
        # This handles the case where evaluation might clobber registers
        let i: u32 = 0
        while i < arg_count {
          let arg: Expression = vec_get(args, i)
          generate_expression(arg)
          # Push result to stack temporarily
          emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rax") }
          state.asm_count = state.asm_count + 1
          i = i + 1
        }

        # Pop arguments into correct registers (in reverse order of push)
        # arg0 -> rdi, arg1 -> rsi, arg2 -> rdx, arg3 -> rcx, arg4 -> r8, arg5 -> r9
        if arg_count > 0 {
          # Pop in reverse order of evaluation (LIFO)
          if arg_count >= 6 {
            emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r9") }
            state.asm_count = state.asm_count + 1
          }
          if arg_count >= 5 {
            emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r8") }
            state.asm_count = state.asm_count + 1
          }
          if arg_count >= 4 {
            emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rcx") }
            state.asm_count = state.asm_count + 1
          }
          if arg_count >= 3 {
            emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rdx") }
            state.asm_count = state.asm_count + 1
          }
          if arg_count >= 2 {
            emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rsi") }
            state.asm_count = state.asm_count + 1
          }
          if arg_count >= 1 {
            emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rdi") }
            state.asm_count = state.asm_count + 1
          }
        }

        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from(func_name) }
        state.asm_count = state.asm_count + 1
      }

      rule generate_field_access(field: FieldAccessExpr) {
        # Generate field access (e.g., state.x)
        # For now, load from fixed offset
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rdi)", "%rax") }
        state.asm_count = state.asm_count + 1
      }

      rule generate_index(idx: IndexAccessExpr) {
        # Generate array/vec index access: obj[index]
        # Vec struct: { void** data, u64 len, u64 cap }

        # Step 1: Evaluate object expression (vec pointer) - result in rax
        generate_expression(idx.object)

        # Step 2: Save vec pointer to r10
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%r10") }
        state.asm_count = state.asm_count + 1

        # Step 3: Evaluate index expression - result in rax
        generate_expression(idx.index)

        # Step 4: Move index to r11
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%r11") }
        state.asm_count = state.asm_count + 1

        # Step 5: Load data pointer from vec (offset 0 in Vec struct)
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%r10)", "%rax") }
        state.asm_count = state.asm_count + 1

        # Step 6: Calculate element address: data + (index * 8)
        # Multiply index by 8 (sizeof pointer)
        emit asm_instruction { label: "", mnemonic: "shlq", operands: vec_from("$3", "%r11") }
        state.asm_count = state.asm_count + 1

        # Add to data pointer
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("%r11", "%rax") }
        state.asm_count = state.asm_count + 1

        # Step 7: Load element value
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rax)", "%rax") }
        state.asm_count = state.asm_count + 1
      }

      rule generate_label(prefix: string) -> string {
        state.label_counter = state.label_counter + 1
        let label: string = ".L_"
        label = string_concat(label, prefix)
        label = string_concat(label, "_")
        label = string_concat(label, u32_to_string(state.label_counter))
        return label
      }

      # Legacy LIR function code generation removed - bypassed by direct AST path

      rule generate_function(func_name: string) {
        # Phase 1: Build live intervals
        build_live_intervals()

        # Phase 2: Register allocation (linear scan)
        allocate_registers()

        # Phase 3: Emit function prologue
        emit_prologue(func_name)

        # Phase 4: Translate each IR instruction to x86-64
        let position = 0u32
        for ir_inst: IRInstruction in state.ir_instructions {
          translate_instruction(ir_inst, position)
          position = position + 1
        }

        # Phase 5: Emit function epilogue (handled by RET instruction)
      }

      # -------------------------------------------------------------------------
      # LIVE INTERVAL CONSTRUCTION
      # -------------------------------------------------------------------------

      rule build_live_intervals() {
        let interval_map: map<string, LiveInterval> = map_new()
        let position = 0u32

        for ir_inst: IRInstruction in state.ir_instructions {
          # Record definition (dst)
          if ir_inst.dst != "" {
            if !map_has(interval_map, ir_inst.dst) {
              # First definition - create interval
              let interval = LiveInterval {
                vreg: ir_inst.dst,
                start: position,
                end: position,
                assigned: "",
                spill_slot: -1
              }
              map_set(interval_map, ir_inst.dst, interval)
            } else {
              # Update end position
              let interval: LiveInterval = map_get(interval_map, ir_inst.dst)
              interval.end = position
              map_set(interval_map, ir_inst.dst, interval)
            }
          }

          # Record uses (src1, src2)
          for src in vec_from(ir_inst.src1, ir_inst.src2) {
            if src != "" && !is_immediate(src) && !is_label(src) {
              if map_has(interval_map, src) {
                let interval: LiveInterval = map_get(interval_map, src)
                interval.end = position
                map_set(interval_map, src, interval)
              }
            }
          }

          position = position + 1
        }

        # Convert map to sorted vector (by start position)
        # TODO: Implement sorting - for now using unsorted values
        state.live_intervals = map_values(interval_map)
      }

      # -------------------------------------------------------------------------
      # REGISTER ALLOCATION (Linear Scan)
      # -------------------------------------------------------------------------

      rule allocate_registers() {
        vec_clear(state.active_intervals)

        for interval: LiveInterval in state.live_intervals {
          # Expire old intervals
          expire_old_intervals(interval.start)

          # Find a free register
          let free_reg = find_free_register()

          if free_reg != "" {
            # Assign register
            interval.assigned = free_reg
            map_set(state.allocation, interval.vreg, free_reg)
            vec_push(state.active_intervals, interval)
          } else {
            # Spill - no free registers
            spill_at_interval(interval)
          }
        }
      }

      rule expire_old_intervals(current_pos: u32) {
        let new_active: vec<LiveInterval> = vec_new()

        for interval: LiveInterval in state.active_intervals {
          if interval.end >= current_pos {
            vec_push(new_active, interval)
          }
          # Expired intervals release their registers automatically
          # (they're no longer in active, so their reg becomes free)
        }

        state.active_intervals = new_active
      }

      rule find_free_register() -> string {
        let used_regs: vec<string> = vec_new()

        for interval: LiveInterval in state.active_intervals {
          if interval.assigned != "" {
            vec_push(used_regs, interval.assigned)
          }
        }

        for reg in state.available_regs {
          if !vec_contains(used_regs, reg) {
            return reg
          }
        }

        return ""  # No free register
      }

      rule spill_at_interval(interval: LiveInterval) {
        # Check if we should spill this interval or an active one
        if vec_len(state.active_intervals) == 0 {
          # Must spill current interval
          do_spill(interval)
          return
        }

        # Find the active interval that ends latest
        let spill_candidate: LiveInterval = vec_get(state.active_intervals, 0)
        for active: LiveInterval in state.active_intervals {
          if active.end > spill_candidate.end {
            spill_candidate = active
          }
        }

        if spill_candidate.end > interval.end {
          # Spill the longer-living active interval
          # Give its register to current interval
          interval.assigned = spill_candidate.assigned
          map_set(state.allocation, interval.vreg, interval.assigned)

          # Spill the old one
          do_spill(spill_candidate)

          # Remove old from active, add new
          vec_remove(state.active_intervals, spill_candidate)
          vec_push(state.active_intervals, interval)
        } else {
          # Spill current interval
          do_spill(interval)
        }
      }

      rule do_spill(interval: LiveInterval) {
        interval.spill_slot = state.next_spill_offset
        state.next_spill_offset = state.next_spill_offset - 8
        map_set(state.spill_slots, interval.vreg, interval.spill_slot)
      }

      # -------------------------------------------------------------------------
      # FUNCTION PROLOGUE / EPILOGUE
      # -------------------------------------------------------------------------

      rule emit_prologue(func_name: string) {
        # Function label
        emit asm_instruction {
          label: func_name,
          mnemonic: "",
          operands: vec_new()
        }

        # Push frame pointer
        emit asm_instruction {
          label: "",
          mnemonic: "pushq",
          operands: vec_from("%rbp")
        }

        # Set up frame pointer
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rsp", "%rbp")
        }

        # Allocate stack space (aligned to 16 bytes)
        let frame_size = calculate_frame_size()
        if frame_size > 0 {
          emit asm_instruction {
            label: "",
            mnemonic: "subq",
            operands: vec_from(format("${}", frame_size), "%rsp")
          }
        }

        # Save callee-saved registers we're using
        let used_callee_saved = get_used_callee_saved()
        for reg in used_callee_saved {
          let offset = get_callee_save_offset(reg)
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(format("%{}", reg), format("{}(%rbp)", offset))
          }
        }

        # Move arguments from registers to local storage if needed
        let param_idx = 0u32
        for param in state.current_params {
          if param_idx < 6 {
            let arg_reg = vec_get(state.arg_regs, param_idx)
            let dst = get_operand(param.name)
            if dst != format("%{}", arg_reg) {
              emit asm_instruction {
                label: "",
                mnemonic: "movq",
                operands: vec_from(format("%{}", arg_reg), dst)
              }
            }
          }
          param_idx = param_idx + 1
        }

        state.asm_count = state.asm_count + 4 + vec_len(used_callee_saved)
      }

      rule emit_epilogue() {
        # Restore callee-saved registers
        let used_callee_saved = get_used_callee_saved()
        for reg in vec_reverse(used_callee_saved) {
          let offset = get_callee_save_offset(reg)
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(format("{}(%rbp)", offset), format("%{}", reg))
          }
        }

        # Restore stack pointer
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rbp", "%rsp")
        }

        # Restore frame pointer
        emit asm_instruction {
          label: "",
          mnemonic: "popq",
          operands: vec_from("%rbp")
        }

        # Return
        emit asm_instruction {
          label: "",
          mnemonic: "ret",
          operands: vec_new()
        }

        state.asm_count = state.asm_count + 3 + vec_len(used_callee_saved)
      }

      rule calculate_frame_size() -> i32 {
        # Calculate space needed:
        # - Spill slots
        # - Callee-saved registers
        # - Local variables
        # - Align to 16 bytes

        let spill_space = -(state.next_spill_offset + 8)  # Total spill bytes
        let callee_save_space = vec_len(get_used_callee_saved()) * 8
        let total = spill_space + callee_save_space

        # Align to 16 bytes
        return ((total + 15) / 16) * 16
      }

      rule get_used_callee_saved() -> vec<string> {
        let used: vec<string> = vec_new()
        for vreg, preg in state.allocation {
          if vec_contains(state.callee_saved_regs, preg) {
            if !vec_contains(used, preg) {
              vec_push(used, preg)
            }
          }
        }
        return used
      }

      rule get_callee_save_offset(reg: string) -> i32 {
        # Callee-saved registers stored after spill slots
        let used = get_used_callee_saved()
        let idx = vec_index_of(used, reg)
        return state.next_spill_offset - (idx * 8) - 8
      }

      # -------------------------------------------------------------------------
      # INSTRUCTION TRANSLATION
      # -------------------------------------------------------------------------

      rule translate_instruction(ir: IRInstruction, pos: u32) {
        # Emit label if present
        if ir.label != "" {
          emit asm_instruction {
            label: ir.label,
            mnemonic: "",
            operands: vec_new()
          }
        }

        # Translate based on opcode
        match ir.op {
          IROpcode::LABEL => {
            # Already handled above
          }

          IROpcode::MOVE => {
            translate_move(ir)
          }

          IROpcode::CONST => {
            translate_const(ir)
          }

          IROpcode::LOAD => {
            translate_load(ir)
          }

          IROpcode::STORE => {
            translate_store(ir)
          }

          IROpcode::LOAD_FIELD => {
            translate_load_field(ir)
          }

          IROpcode::STORE_FIELD => {
            translate_store_field(ir)
          }

          IROpcode::ADD => {
            translate_binop(ir, "addq")
          }

          IROpcode::SUB => {
            translate_binop(ir, "subq")
          }

          IROpcode::MUL => {
            translate_mul(ir)
          }

          IROpcode::DIV => {
            translate_div(ir, false)  # Quotient
          }

          IROpcode::MOD => {
            translate_div(ir, true)   # Remainder
          }

          IROpcode::NEG => {
            translate_neg(ir)
          }

          IROpcode::AND => {
            translate_binop(ir, "andq")
          }

          IROpcode::OR => {
            translate_binop(ir, "orq")
          }

          IROpcode::XOR => {
            translate_binop(ir, "xorq")
          }

          IROpcode::NOT => {
            translate_not(ir)
          }

          IROpcode::SHL => {
            translate_shift(ir, "shlq")
          }

          IROpcode::SHR => {
            translate_shift(ir, "shrq")
          }

          IROpcode::CMP_EQ => {
            translate_cmp(ir, "sete")
          }

          IROpcode::CMP_NE => {
            translate_cmp(ir, "setne")
          }

          IROpcode::CMP_LT => {
            translate_cmp(ir, "setl")
          }

          IROpcode::CMP_LE => {
            translate_cmp(ir, "setle")
          }

          IROpcode::CMP_GT => {
            translate_cmp(ir, "setg")
          }

          IROpcode::CMP_GE => {
            translate_cmp(ir, "setge")
          }

          IROpcode::JUMP => {
            translate_jump(ir)
          }

          IROpcode::BRANCH => {
            translate_branch(ir)
          }

          IROpcode::RET => {
            translate_ret(ir)
          }

          IROpcode::CALL => {
            translate_call(ir)
          }

          IROpcode::ALLOC => {
            translate_alloc(ir)
          }

          IROpcode::FREE => {
            translate_free(ir)
          }

          IROpcode::GET_FIELD_ADDR => {
            translate_get_field_addr(ir)
          }

          IROpcode::BITCAST => {
            # Bitcast is a no-op (same bits, different type)
            translate_move(ir)
          }

          IROpcode::PHI => {
            # PHI nodes handled during register allocation
            # Should have been resolved already
          }

          # M2 Phase 2: Signal operation handlers
          IROpcode::SIGNAL_ALLOC => {
            translate_signal_alloc(ir)
          }

          IROpcode::SIGNAL_SET_PAYLOAD => {
            translate_signal_set_payload(ir)
          }

          IROpcode::SIGNAL_SET_FIELD => {
            translate_signal_set_field(ir)
          }

          IROpcode::SIGNAL_EMIT => {
            translate_signal_emit(ir)
          }
        }
      }

      # -------------------------------------------------------------------------
      # INDIVIDUAL INSTRUCTION TRANSLATIONS
      # -------------------------------------------------------------------------

      rule translate_move(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let src = get_operand(ir.src1)

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(src, dst)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_const(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let imm = ir.src1  # Immediate value

        # Check if 64-bit immediate (needs movabs)
        if is_large_immediate(imm) {
          emit asm_instruction {
            label: "",
            mnemonic: "movabsq",
            operands: vec_from(format("${}", imm), dst)
          }
        } else {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(format("${}", imm), dst)
          }
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_load(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let addr = get_operand(ir.src1)

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(format("({})", addr), dst)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_store(ir: IRInstruction) {
        let addr = get_operand(ir.dst)  # dst is actually the address
        let src = get_operand(ir.src1)

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(src, format("({})", addr))
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_load_field(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let base = get_operand(ir.src1)
        let offset = ir.src2  # Numeric offset

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(format("{}({})", offset, base), dst)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_store_field(ir: IRInstruction) {
        let base = get_operand(ir.dst)
        let offset = ir.src1  # Numeric offset
        let src = get_operand(ir.src2)

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(src, format("{}({})", offset, base))
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_binop(ir: IRInstruction, mnemonic: string) {
        let dst = get_operand(ir.dst)
        let lhs = get_operand(ir.src1)
        let rhs = get_operand(ir.src2)

        # x86-64 is two-address: dst = dst op src
        # So we need: mov dst, lhs; op dst, rhs
        if dst != lhs {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(lhs, dst)
          }
          state.asm_count = state.asm_count + 1
        }

        emit asm_instruction {
          label: "",
          mnemonic: mnemonic,
          operands: vec_from(rhs, dst)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_mul(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let lhs = get_operand(ir.src1)
        let rhs = get_operand(ir.src2)

        # imul can use 3-operand form: imul src, dst
        # Or we use: mov rax, lhs; imul rhs; mov dst, rax
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(lhs, "%rax")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "imulq",
          operands: vec_from(rhs)
        }

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rax", dst)
        }
        state.asm_count = state.asm_count + 3
      }

      rule translate_div(ir: IRInstruction, get_remainder: boolean) {
        let dst = get_operand(ir.dst)
        let lhs = get_operand(ir.src1)
        let rhs = get_operand(ir.src2)

        # idiv uses rax:rdx / src -> quotient in rax, remainder in rdx
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(lhs, "%rax")
        }

        # Sign-extend rax to rdx:rax
        emit asm_instruction {
          label: "",
          mnemonic: "cqo",
          operands: vec_new()
        }

        emit asm_instruction {
          label: "",
          mnemonic: "idivq",
          operands: vec_from(rhs)
        }

        if get_remainder {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from("%rdx", dst)
          }
        } else {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from("%rax", dst)
          }
        }
        state.asm_count = state.asm_count + 4
      }

      rule translate_neg(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let src = get_operand(ir.src1)

        if dst != src {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(src, dst)
          }
          state.asm_count = state.asm_count + 1
        }

        emit asm_instruction {
          label: "",
          mnemonic: "negq",
          operands: vec_from(dst)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_not(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let src = get_operand(ir.src1)

        if dst != src {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(src, dst)
          }
          state.asm_count = state.asm_count + 1
        }

        emit asm_instruction {
          label: "",
          mnemonic: "notq",
          operands: vec_from(dst)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_shift(ir: IRInstruction, mnemonic: string) {
        let dst = get_operand(ir.dst)
        let src = get_operand(ir.src1)
        let amt = ir.src2  # Shift amount

        if dst != src {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(src, dst)
          }
          state.asm_count = state.asm_count + 1
        }

        # Shift amount must be in cl or immediate
        if is_immediate(amt) {
          emit asm_instruction {
            label: "",
            mnemonic: mnemonic,
            operands: vec_from(format("${}", amt), dst)
          }
        } else {
          let amt_op = get_operand(amt)
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from(amt_op, "%rcx")
          }
          emit asm_instruction {
            label: "",
            mnemonic: mnemonic,
            operands: vec_from("%cl", dst)
          }
          state.asm_count = state.asm_count + 1
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_cmp(ir: IRInstruction, set_instr: string) {
        let dst = get_operand(ir.dst)
        let lhs = get_operand(ir.src1)
        let rhs = get_operand(ir.src2)

        # Compare
        emit asm_instruction {
          label: "",
          mnemonic: "cmpq",
          operands: vec_from(rhs, lhs)
        }

        # Set byte based on condition
        emit asm_instruction {
          label: "",
          mnemonic: set_instr,
          operands: vec_from("%al")
        }

        # Zero-extend to 64-bit
        emit asm_instruction {
          label: "",
          mnemonic: "movzbq",
          operands: vec_from("%al", dst)
        }
        state.asm_count = state.asm_count + 3
      }

      rule translate_jump(ir: IRInstruction) {
        let target = ir.src1  # Label name

        emit asm_instruction {
          label: "",
          mnemonic: "jmp",
          operands: vec_from(target)
        }
        state.asm_count = state.asm_count + 1
      }

      rule translate_branch(ir: IRInstruction) {
        let cond = get_operand(ir.src1)
        let true_label = ir.src2
        let false_label = ir.dst  # Overloaded: dst holds false label

        # Test condition
        emit asm_instruction {
          label: "",
          mnemonic: "testq",
          operands: vec_from(cond, cond)
        }

        # Jump if not zero (condition true)
        emit asm_instruction {
          label: "",
          mnemonic: "jnz",
          operands: vec_from(true_label)
        }

        # Fall through or jump to false
        emit asm_instruction {
          label: "",
          mnemonic: "jmp",
          operands: vec_from(false_label)
        }
        state.asm_count = state.asm_count + 3
      }

      rule translate_ret(ir: IRInstruction) {
        # Move return value to rax if present
        if ir.src1 != "" {
          let ret_val = get_operand(ir.src1)
          if ret_val != "%rax" {
            emit asm_instruction {
              label: "",
              mnemonic: "movq",
              operands: vec_from(ret_val, "%rax")
            }
            state.asm_count = state.asm_count + 1
          }
        }

        # Emit epilogue
        emit_epilogue()
      }

      rule translate_call(ir: IRInstruction) {
        let dst = ir.dst
        let func_name = ir.src1
        let args = parse_args(ir.src2)  # src2 contains comma-separated args

        # Set up arguments in registers
        let arg_idx = 0u32
        for arg: Expression in args {
          if arg_idx < 6 {
            let arg_op = get_operand(arg)
            let reg = vec_get(state.arg_regs, arg_idx)
            if arg_op != format("%{}", reg) {
              emit asm_instruction {
                label: "",
                mnemonic: "movq",
                operands: vec_from(arg_op, format("%{}", reg))
              }
              state.asm_count = state.asm_count + 1
            }
          } else {
            # Stack argument
            let arg_op = get_operand(arg)
            emit asm_instruction {
              label: "",
              mnemonic: "pushq",
              operands: vec_from(arg_op)
            }
            state.asm_count = state.asm_count + 1
          }
          arg_idx = arg_idx + 1
        }

        # Call function
        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from(func_name)
        }
        state.asm_count = state.asm_count + 1

        # Clean up stack args if any
        if arg_idx > 6 {
          let stack_bytes = (arg_idx - 6) * 8
          emit asm_instruction {
            label: "",
            mnemonic: "addq",
            operands: vec_from(format("${}", stack_bytes), "%rsp")
          }
          state.asm_count = state.asm_count + 1
        }

        # Move result to destination
        if dst != "" {
          let dst_op = get_operand(dst)
          if dst_op != "%rax" {
            emit asm_instruction {
              label: "",
              mnemonic: "movq",
              operands: vec_from("%rax", dst_op)
            }
            state.asm_count = state.asm_count + 1
          }
        }
      }

      rule translate_alloc(ir: IRInstruction) {
        let dst = ir.dst
        let size = ir.src1

        # Call runtime_alloc(size)
        let size_op = get_operand(size)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(size_op, "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("runtime_alloc")
        }

        let dst_op = get_operand(dst)
        if dst_op != "%rax" {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from("%rax", dst_op)
          }
          state.asm_count = state.asm_count + 1
        }
        state.asm_count = state.asm_count + 2
      }

      rule translate_free(ir: IRInstruction) {
        let ptr = get_operand(ir.src1)

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(ptr, "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("runtime_free")
        }
        state.asm_count = state.asm_count + 2
      }

      rule translate_get_field_addr(ir: IRInstruction) {
        let dst = get_operand(ir.dst)
        let base = get_operand(ir.src1)
        let offset = ir.src2

        emit asm_instruction {
          label: "",
          mnemonic: "leaq",
          operands: vec_from(format("{}({})", offset, base), dst)
        }
        state.asm_count = state.asm_count + 1
      }

      # -------------------------------------------------------------------------
      # M2 PHASE 2: SIGNAL OPERATION TRANSLATIONS
      # -------------------------------------------------------------------------

      rule translate_signal_alloc(ir: IRInstruction) {
        # SIGNAL_ALLOC: Allocate 32-byte signal header
        # dst = signal variable
        # src1 = frequency_id
        # src2 = source_agent_id

        let dst = ir.dst
        let freq_id = ir.src1
        let agent_id = ir.src2

        # Allocate 32 bytes for signal struct (M2 Signal Runtime Spec)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("$32", "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("heap_allocate")
        }

        # Save signal pointer to destination
        let dst_op = get_operand(dst)
        if dst_op != "%rax" {
          emit asm_instruction {
            label: "",
            mnemonic: "movq",
            operands: vec_from("%rax", dst_op)
          }
          state.asm_count = state.asm_count + 1
        }

        # Store frequency_id at offset 0 (u16)
        emit asm_instruction {
          label: "",
          mnemonic: "movw",
          operands: vec_from(format("${}", freq_id), format("0({})", dst_op))
        }

        # Store source_agent_id at offset 2 (u16)
        emit asm_instruction {
          label: "",
          mnemonic: "movw",
          operands: vec_from(format("${}", agent_id), format("2({})", dst_op))
        }

        # Initialize ref_count to 1 at offset 6 (u16)
        emit asm_instruction {
          label: "",
          mnemonic: "movw",
          operands: vec_from("$1", format("6({})", dst_op))
        }

        # Get timestamp (RDTSC)
        emit asm_instruction {
          label: "",
          mnemonic: "rdtsc",
          operands: vec_new()
        }

        # Combine EDX:EAX into RAX
        emit asm_instruction {
          label: "",
          mnemonic: "shlq",
          operands: vec_from("$32", "%rdx")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "orq",
          operands: vec_from("%rdx", "%rax")
        }

        # Store timestamp at offset 24 (u64)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rax", format("24({})", dst_op))
        }

        state.asm_count = state.asm_count + 9
      }

      rule translate_signal_set_payload(ir: IRInstruction) {
        # SIGNAL_SET_PAYLOAD: Attach payload to signal
        # src1 = signal variable
        # src2 = payload variable
        # type_size = payload size (stored in type_size field)

        let signal = get_operand(ir.src1)
        let payload = get_operand(ir.src2)
        let payload_size = ir.type_size

        # Store payload_ptr at signal offset 8 (u64)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(payload, format("8({})", signal))
        }

        # Store payload_size at signal offset 16 (u32)
        emit asm_instruction {
          label: "",
          mnemonic: "movl",
          operands: vec_from(format("${}", payload_size), format("16({})", signal))
        }

        # Store payload_capacity at signal offset 20 (u32)
        emit asm_instruction {
          label: "",
          mnemonic: "movl",
          operands: vec_from(format("${}", payload_size), format("20({})", signal))
        }

        state.asm_count = state.asm_count + 3
      }

      rule translate_signal_set_field(ir: IRInstruction) {
        # SIGNAL_SET_FIELD: Store field value in payload struct
        # src1 = payload variable
        # src2 = value variable
        # type_size = field offset

        let payload = get_operand(ir.src1)
        let value = get_operand(ir.src2)
        let offset = ir.type_size

        # Store value at payload + offset
        # Use 8-byte mov (assuming pointer/u64 for now)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(value, format("{}({})", offset, payload))
        }

        state.asm_count = state.asm_count + 1
      }

      rule translate_signal_emit(ir: IRInstruction) {
        # SIGNAL_EMIT: Route and broadcast signal
        # src1 = signal variable
        # src2 = frequency_id

        let signal = get_operand(ir.src1)
        let freq_id = ir.src2

        # Load routing table pointer into RDI (1st arg)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("routing_table(%rip)", "%rdi")
        }

        # Load signal pointer into RSI (2nd arg)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from(signal, "%rsi")
        }

        # Load agent registry pointer into RDX (3rd arg)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("agent_registry(%rip)", "%rdx")
        }

        # Call routing_broadcast(routing_table, signal, agents)
        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("routing_broadcast")
        }

        state.asm_count = state.asm_count + 4
      }

      # -------------------------------------------------------------------------
      # RUNTIME STUB GENERATION
      # Generate minimal implementations of runtime functions so the linker can resolve them
      # -------------------------------------------------------------------------

      rule generate_num_agents() {
        # Generate the num_agents global variable with the actual count
        emit asm_section { name: ".data" }

        let count: u32 = vec_len(state.hyphal_names)
        let count_str: string = u32_to_string(count)

        emit asm_data {
          label: "num_agents",
          data_type: "quad",
          value: count_str,
          section: ".data"
        }

        emit asm_section { name: ".text" }
      }

      rule generate_init_agents() {
        # Generate init_agents function that calls each hyphal's init function
        emit asm_instruction { label: "init_agents", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        state.asm_count = state.asm_count + 3

        # Call each hyphal's init function
        let i: u32 = 0
        let count: u32 = vec_len(state.hyphal_init_funcs)
        while i < count {
          let init_func: string = vec_get(state.hyphal_init_funcs, i)
          emit asm_instruction { label: "", mnemonic: "call", operands: vec_from(init_func) }
          state.asm_count = state.asm_count + 1
          i = i + 1
        }

        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 2

        state.function_count = state.function_count + 1
      }

      rule generate_runtime_stubs() {
        # NOTE: Global variables (global_registry, global_routing_table,
        # global_scheduler) are provided by complete-builtins.o when linking.
        # num_agents is generated by generate_num_agents().
        # We only generate scheduler_run_local which calls rest handlers.

        emit asm_section { name: ".text" }

        # NOTE: We no longer generate stub functions for heap_init, registry_create, etc.
        # These are provided by complete-builtins.o when linking.
        # Only scheduler_run_local is generated because it must call this program's
        # specific rest handlers.

        # Generate scheduler_run_local - calls all rest handlers once
        # This is called from our main() instead of the generic scheduler_run
        emit asm_instruction { label: "scheduler_run_local", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }

        # Call each rest handler
        let h: u32 = 0
        let handler_count: u32 = vec_len(state.rest_handlers)
        while h < handler_count {
          let handler_name: string = vec_get(state.rest_handlers, h)
          emit asm_instruction { label: "", mnemonic: "call", operands: vec_from(handler_name) }
          h = h + 1
        }

        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }

        state.asm_count = state.asm_count + 4
        state.function_count = state.function_count + 1
      }

      # -------------------------------------------------------------------------
      # BUILTIN FUNCTIONS - Self-hosted implementations
      # -------------------------------------------------------------------------

      rule generate_builtins() {
        # Generate all builtin function implementations in x86-64 assembly
        # These are the runtime primitives needed for self-hosting

        generate_string_builtins()
        generate_vector_builtins()
        generate_map_builtins()
        generate_memory_builtins()
        generate_parsing_builtins()
        generate_io_builtins()
      }

      rule generate_string_builtins() {
        # ============================================================
        # string_len(str: *u8) -> u64
        # Returns length of null-terminated string
        # ============================================================
        emit asm_instruction { label: "string_len", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".strlen_done") }
        emit asm_instruction { label: ".strlen_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%cl") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%cl", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".strlen_done") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rax") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".strlen_loop") }
        emit asm_instruction { label: ".strlen_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 16
        state.function_count = state.function_count + 1

        # ============================================================
        # str_data(str: string) -> *u8
        # Returns pointer to string data (identity for C strings)
        # ============================================================
        emit asm_instruction { label: "str_data", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 2
        state.function_count = state.function_count + 1

        # ============================================================
        # starts_with(str: *u8, prefix: *u8) -> bool
        # Checks if string starts with prefix
        # ============================================================
        emit asm_instruction { label: "starts_with", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".sw_false") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rsi", "%rsi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".sw_true") }
        emit asm_instruction { label: ".sw_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rsi)", "%al") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%al", "%al") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".sw_true") }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%cl") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("%al", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".sw_false") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rsi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".sw_loop") }
        emit asm_instruction { label: ".sw_true", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".sw_done") }
        emit asm_instruction { label: ".sw_false", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".sw_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 24
        state.function_count = state.function_count + 1

        # ============================================================
        # contains(str: *u8, substr: *u8) -> bool
        # Checks if string contains substring
        # ============================================================
        emit asm_instruction { label: "contains", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rbx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsi", "%r12") }
        emit asm_instruction { label: ".contains_outer", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rbx)", "%al") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%al", "%al") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".contains_false") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbx", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%r12", "%rsi") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("starts_with") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jnz", operands: vec_from(".contains_true") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".contains_outer") }
        emit asm_instruction { label: ".contains_true", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".contains_done") }
        emit asm_instruction { label: ".contains_false", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".contains_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 28
        state.function_count = state.function_count + 1

        # string_contains is alias for contains
        emit asm_instruction { label: "string_contains", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from("contains") }
        state.asm_count = state.asm_count + 1
        state.function_count = state.function_count + 1

        # ============================================================
        # string_char_at(str: *u8, index: u64) -> u8
        # Returns character at index
        # ============================================================
        emit asm_instruction { label: "string_char_at", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movzbq", operands: vec_from("(%rdi,%rsi)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 2
        state.function_count = state.function_count + 1

        # ============================================================
        # format - stub that returns first argument
        # Full implementation would need varargs support
        # ============================================================
        emit asm_instruction { label: "format", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 2
        state.function_count = state.function_count + 1

        # ============================================================
        # string_split - stub (returns empty vec for now)
        # ============================================================
        emit asm_instruction { label: "string_split", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("vec_new") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 2
        state.function_count = state.function_count + 1
      }

      rule generate_vector_builtins() {
        # ============================================================
        # vec_new() -> *vec
        # Creates a new empty vector
        # Vector layout: [capacity:8][length:8][data_ptr:8]
        # ============================================================
        emit asm_instruction { label: "vec_new", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$24", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("heap_alloc") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$8", "(%rax)") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$0", "8(%rax)") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$64", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("heap_alloc") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "16(%rbx)") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rbx", "%rax") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 15
        state.function_count = state.function_count + 1

        # ============================================================
        # vec_len(vec: *vec) -> u64
        # Returns length of vector
        # ============================================================
        emit asm_instruction { label: "vec_len", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".veclen_zero") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("8(%rdi)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        emit asm_instruction { label: ".veclen_zero", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 8
        state.function_count = state.function_count + 1

        # ============================================================
        # vec_get(vec: *vec, index: u64) -> element
        # Returns element at index
        # ============================================================
        emit asm_instruction { label: "vec_get", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("16(%rdi)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rax,%rsi,8)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 3
        state.function_count = state.function_count + 1

        # ============================================================
        # vec_push(vec: *vec, element: any) -> void
        # Pushes element to end of vector
        # ============================================================
        emit asm_instruction { label: "vec_push", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rbx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsi", "%r12") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("8(%rbx)", "%rcx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("16(%rbx)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%r12", "(%rax,%rcx,8)") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("8(%rbx)") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 15
        state.function_count = state.function_count + 1

        # ============================================================
        # vec_contains(vec: *vec, element: any) -> bool
        # Checks if vector contains element
        # ============================================================
        emit asm_instruction { label: "vec_contains", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rbx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsi", "%r12") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rcx", "%rcx") }
        emit asm_instruction { label: ".vc_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("8(%rbx)", "%rcx") }
        emit asm_instruction { label: "", mnemonic: "jge", operands: vec_from(".vc_false") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("16(%rbx)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rax,%rcx,8)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("%r12", "%rax") }
        emit asm_instruction { label: "", mnemonic: "je", operands: vec_from(".vc_true") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".vc_loop") }
        emit asm_instruction { label: ".vc_true", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".vc_done") }
        emit asm_instruction { label: ".vc_false", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".vc_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 27
        state.function_count = state.function_count + 1
      }

      rule generate_map_builtins() {
        # ============================================================
        # map_has(map: *map, key: any) -> bool
        # Checks if map contains key (linear search for now)
        # Map layout: [capacity:8][length:8][keys_ptr:8][values_ptr:8]
        # ============================================================
        emit asm_instruction { label: "map_has", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".mh_false") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rbx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsi", "%r12") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rcx", "%rcx") }
        emit asm_instruction { label: ".mh_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("8(%rbx)", "%rcx") }
        emit asm_instruction { label: "", mnemonic: "jge", operands: vec_from(".mh_notfound") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("16(%rbx)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rax,%rcx,8)", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%r12", "%rsi") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("string_eq") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jnz", operands: vec_from(".mh_found") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".mh_loop") }
        emit asm_instruction { label: ".mh_found", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".mh_cleanup") }
        emit asm_instruction { label: ".mh_notfound", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".mh_cleanup", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        emit asm_instruction { label: ".mh_false", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 38
        state.function_count = state.function_count + 1

        # map_contains and map_contains_key are aliases
        emit asm_instruction { label: "map_contains", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from("map_has") }
        emit asm_instruction { label: "map_contains_key", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from("map_has") }
        state.asm_count = state.asm_count + 2
        state.function_count = state.function_count + 2

        # ============================================================
        # map_get(map: *map, key: any) -> value
        # Gets value for key (returns 0 if not found)
        # ============================================================
        emit asm_instruction { label: "map_get", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".mg_zero") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rdi", "%rbx") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsi", "%r12") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rcx", "%rcx") }
        emit asm_instruction { label: ".mg_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "cmpq", operands: vec_from("8(%rbx)", "%rcx") }
        emit asm_instruction { label: "", mnemonic: "jge", operands: vec_from(".mg_notfound") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("16(%rbx)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rax,%rcx,8)", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%r12", "%rsi") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("string_eq") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jnz", operands: vec_from(".mg_found") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rcx") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".mg_loop") }
        emit asm_instruction { label: ".mg_found", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("24(%rbx)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("(%rax,%rcx,8)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".mg_cleanup") }
        emit asm_instruction { label: ".mg_notfound", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".mg_cleanup", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%r12") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbx") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        emit asm_instruction { label: ".mg_zero", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 38
        state.function_count = state.function_count + 1

        # ============================================================
        # map_len(map: *map) -> u64
        # Returns number of entries in map
        # ============================================================
        emit asm_instruction { label: "map_len", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".ml_zero") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("8(%rdi)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        emit asm_instruction { label: ".ml_zero", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 8
        state.function_count = state.function_count + 1
      }

      rule generate_memory_builtins() {
        # Define heap_ptr in .bss section (uninitialized data)
        # This will be initialized by _start to point to end of BSS
        emit asm_data {
          label: "heap_ptr",
          data_type: "quad",
          value: "0",
          section: ".bss"
        }

        # ============================================================
        # heap_alloc(size: u64) -> *void
        # Allocates memory from heap (bump allocator)
        # ============================================================
        emit asm_instruction { label: "heap_alloc", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("heap_ptr(%rip)", "%rax") }
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("$7", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "andq", operands: vec_from("$-8", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("%rdi", "heap_ptr(%rip)") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 5
        state.function_count = state.function_count + 1

        # ============================================================
        # string_eq(s1: *u8, s2: *u8) -> bool
        # Compares two null-terminated strings
        # ============================================================
        emit asm_instruction { label: "string_eq", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: ".seq_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%al") }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rsi)", "%cl") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("%al", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".seq_false") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%al", "%al") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".seq_true") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rsi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".seq_loop") }
        emit asm_instruction { label: ".seq_true", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".seq_done") }
        emit asm_instruction { label: ".seq_false", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".seq_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 21
        state.function_count = state.function_count + 1
      }

      rule generate_parsing_builtins() {
        # ============================================================
        # parse_hex(str: *u8) -> u64
        # Parses hexadecimal string (with optional 0x prefix)
        # ============================================================
        emit asm_instruction { label: "parse_hex", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%cl") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$48", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".ph_loop") }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("1(%rdi)", "%cl") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$120", "%cl") }
        emit asm_instruction { label: "", mnemonic: "je", operands: vec_from(".ph_skip") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$88", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".ph_loop") }
        emit asm_instruction { label: ".ph_skip", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("$2", "%rdi") }
        emit asm_instruction { label: ".ph_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movzbq", operands: vec_from("(%rdi)", "%rcx") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%cl", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".ph_done") }
        emit asm_instruction { label: "", mnemonic: "shlq", operands: vec_from("$4", "%rax") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$57", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jle", operands: vec_from(".ph_digit") }
        emit asm_instruction { label: "", mnemonic: "andb", operands: vec_from("$0xdf", "%cl") }
        emit asm_instruction { label: "", mnemonic: "subb", operands: vec_from("$55", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".ph_add") }
        emit asm_instruction { label: ".ph_digit", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "subb", operands: vec_from("$48", "%cl") }
        emit asm_instruction { label: ".ph_add", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("%rcx", "%rax") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".ph_loop") }
        emit asm_instruction { label: ".ph_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 33
        state.function_count = state.function_count + 1

        # ============================================================
        # parse_i64(str: *u8) -> i64
        # Parses signed decimal integer string
        # ============================================================
        emit asm_instruction { label: "parse_i64", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%r8", "%r8") }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%cl") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$45", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".pi_check_plus") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%r8") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".pi_loop") }
        emit asm_instruction { label: ".pi_check_plus", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$43", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".pi_loop") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: ".pi_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movzbq", operands: vec_from("(%rdi)", "%rcx") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%cl", "%cl") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".pi_done") }
        emit asm_instruction { label: "", mnemonic: "subb", operands: vec_from("$48", "%cl") }
        emit asm_instruction { label: "", mnemonic: "imulq", operands: vec_from("$10", "%rax", "%rax") }
        emit asm_instruction { label: "", mnemonic: "addq", operands: vec_from("%rcx", "%rax") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".pi_loop") }
        emit asm_instruction { label: ".pi_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%r8", "%r8") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".pi_positive") }
        emit asm_instruction { label: "", mnemonic: "negq", operands: vec_from("%rax") }
        emit asm_instruction { label: ".pi_positive", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 31
        state.function_count = state.function_count + 1

        # parse_u32 is alias for parse_i64 (same parsing, different semantics)
        emit asm_instruction { label: "parse_u32", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from("parse_i64") }
        state.asm_count = state.asm_count + 1
        state.function_count = state.function_count + 1

        # ============================================================
        # is_numeric(str: *u8) -> bool
        # Checks if string is numeric
        # ============================================================
        emit asm_instruction { label: "is_numeric", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "testq", operands: vec_from("%rdi", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".in_false") }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%al") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%al", "%al") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".in_false") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$45", "%al") }
        emit asm_instruction { label: "", mnemonic: "je", operands: vec_from(".in_skip") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$43", "%al") }
        emit asm_instruction { label: "", mnemonic: "jne", operands: vec_from(".in_loop") }
        emit asm_instruction { label: ".in_skip", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: ".in_loop", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movb", operands: vec_from("(%rdi)", "%al") }
        emit asm_instruction { label: "", mnemonic: "testb", operands: vec_from("%al", "%al") }
        emit asm_instruction { label: "", mnemonic: "jz", operands: vec_from(".in_true") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$48", "%al") }
        emit asm_instruction { label: "", mnemonic: "jl", operands: vec_from(".in_false") }
        emit asm_instruction { label: "", mnemonic: "cmpb", operands: vec_from("$57", "%al") }
        emit asm_instruction { label: "", mnemonic: "jg", operands: vec_from(".in_false") }
        emit asm_instruction { label: "", mnemonic: "incq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".in_loop") }
        emit asm_instruction { label: ".in_true", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from(".in_done") }
        emit asm_instruction { label: ".in_false", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "xorq", operands: vec_from("%rax", "%rax") }
        emit asm_instruction { label: ".in_done", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 31
        state.function_count = state.function_count + 1

        # is_numeric_string is alias
        emit asm_instruction { label: "is_numeric_string", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "jmp", operands: vec_from("is_numeric") }
        state.asm_count = state.asm_count + 1
        state.function_count = state.function_count + 1
      }

      rule generate_io_builtins() {
        # ============================================================
        # print(str: *u8) -> void
        # Writes string to stdout
        # ============================================================
        emit asm_instruction { label: "print", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rdi") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("string_len") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rax", "%rdx") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rsi") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rax") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("$1", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "syscall", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 12
        state.function_count = state.function_count + 1

        # ============================================================
        # println(str: *u8) -> void
        # Writes string and newline to stdout
        # ============================================================
        emit asm_instruction { label: "println", mnemonic: "", operands: vec_new() }
        emit asm_instruction { label: "", mnemonic: "pushq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "movq", operands: vec_from("%rsp", "%rbp") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("print") }
        emit asm_instruction { label: "", mnemonic: "leaq", operands: vec_from("newline_str(%rip)", "%rdi") }
        emit asm_instruction { label: "", mnemonic: "call", operands: vec_from("print") }
        emit asm_instruction { label: "", mnemonic: "popq", operands: vec_from("%rbp") }
        emit asm_instruction { label: "", mnemonic: "ret", operands: vec_new() }
        state.asm_count = state.asm_count + 7
        state.function_count = state.function_count + 1

        # Data for newline
        emit asm_data { label: "newline_str", data_type: "ascii", value: "\"\\n\"", section: ".rodata" }
      }

      # -------------------------------------------------------------------------
      # M2 PHASE 5: MAIN FUNCTION GENERATION
      # -------------------------------------------------------------------------

      rule generate_start_function() {
        # Generate _start entry point that extracts argc/argv from stack and calls main
        # Based on M3_COMMAND_LINE_ARGS_SONNET_PROMPT.md
        #
        # Linux x86-64 stack layout at program start:
        #   [rsp + 0]  = argc
        #   [rsp + 8]  = argv[0]
        #   [rsp + 16] = argv[1]
        #   ...

        # Switch to .data section for global variables
        # Declare global variables for argc and argv in .data section
        emit asm_data {
          label: "argc",
          data_type: "quad",
          value: "0",
          section: ".data"
        }

        emit asm_data {
          label: "argv",
          data_type: "quad",
          value: "0",
          section: ".data"
        }

        # Switch back to .text section for code
        emit asm_section { name: ".text" }

        # _start entry point label
        emit asm_instruction {
          label: "_start",
          mnemonic: "",
          operands: vec_new()
        }

        # Extract argc from stack (top of stack)
        emit asm_instruction {
          label: "",
          mnemonic: "popq",
          operands: vec_from("%rdi")
        }

        # rsp now points to argv[0], save it in %rsi
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rsp", "%rsi")
        }

        # Store argc in global variable
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rdi", "argc(%rip)")
        }

        # Store argv in global variable
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rsi", "argv(%rip)")
        }

        # Call main function
        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("main")
        }

        # Exit with return code from main (in %rax)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rax", "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("$60", "%rax")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "syscall",
          operands: vec_new()
        }

        state.asm_count = state.asm_count + 9
        state.function_count = state.function_count + 1
      }

      rule generate_main_function() {
        # Generate main() entry point that initializes runtime and starts scheduler
        # Based on M2_PHASE5_TIDAL_CYCLE_SCHEDULER_SPEC.md

        # Function label
        emit asm_instruction {
          label: "main",
          mnemonic: "",
          operands: vec_new()
        }

        # Prologue - set up stack frame
        emit asm_instruction {
          label: "",
          mnemonic: "pushq",
          operands: vec_from("%rbp")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rsp", "%rbp")
        }

        # Initialize heap allocator
        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("heap_init")
        }

        # Create agent registry
        # TODO: Get num_agents from topology compilation (Phase 4)
        # For now, assume global symbol provided by Phase 4
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("num_agents(%rip)", "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("registry_create")
        }

        # Save registry pointer to global
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rax", "global_registry(%rip)")
        }

        # Initialize all agents (function generated by Phase 4)
        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("init_agents")
        }

        # Initialize routing tables (function generated by Phase 4)
        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("init_routing_tables")
        }

        # Create scheduler
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("global_registry(%rip)", "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("global_routing_table(%rip)", "%rsi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("scheduler_create")
        }

        # Save scheduler pointer to global
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("%rax", "global_scheduler(%rip)")
        }

        # Call startup signal handlers (emit initial signals)
        # For bootstrap, we call them directly without signal routing
        let sh: u32 = 0
        let startup_count: u32 = vec_len(state.startup_handlers)
        while sh < startup_count {
          let startup_func: string = vec_get(state.startup_handlers, sh)
          emit asm_instruction {
            label: "",
            mnemonic: "call",
            operands: vec_from(startup_func)
          }
          sh = sh + 1
        }

        # Run scheduler (main event loop)
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("global_scheduler(%rip)", "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("scheduler_run_local")
        }

        # Clean up - destroy scheduler
        emit asm_instruction {
          label: "",
          mnemonic: "movq",
          operands: vec_from("global_scheduler(%rip)", "%rdi")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "call",
          operands: vec_from("scheduler_destroy")
        }

        # Return 0
        emit asm_instruction {
          label: "",
          mnemonic: "xorq",
          operands: vec_from("%rax", "%rax")
        }

        # Epilogue
        emit asm_instruction {
          label: "",
          mnemonic: "popq",
          operands: vec_from("%rbp")
        }

        emit asm_instruction {
          label: "",
          mnemonic: "ret",
          operands: vec_new()
        }

        state.asm_count = state.asm_count + 20
        state.function_count = state.function_count + 1
      }

      # -------------------------------------------------------------------------
      # HELPER FUNCTIONS
      # -------------------------------------------------------------------------

      rule get_operand(vreg: string) -> string {
        # Check if it's a parameter (special handling)
        if starts_with(vreg, "%param") {
          let idx = parse_param_index(vreg)
          if idx < 6 {
            return format("%{}", vec_get(state.arg_regs, idx))
          } else {
            # Stack parameter
            let offset = 16 + (idx - 6) * 8
            return format("{}(%rbp)", offset)
          }
        }

        # Check if allocated to a register
        if map_has(state.allocation, vreg) {
          return format("%{}", map_get(state.allocation, vreg))
        }

        # Check if spilled to stack
        if map_has(state.spill_slots, vreg) {
          let offset = map_get(state.spill_slots, vreg)
          return format("{}(%rbp)", offset)
        }

        # Unknown - return as-is (might be a label or immediate)
        return vreg
      }

      rule is_immediate(s: string) -> boolean {
        return starts_with(s, "$") || is_numeric(s)
      }

      rule is_label(s: string) -> boolean {
        return starts_with(s, ".") || starts_with(s, "_")
      }

      rule is_large_immediate(s: string) -> boolean {
        let val = parse_i64(s)
        return val > 2147483647 || val < -2147483648
      }

      rule parse_args(args_str: string) -> vec<string> {
        if args_str == "" {
          return vec_new()
        }
        return string_split(args_str, ",")
      }

      rule parse_param_index(param: string) -> u32 {
        # %param0 -> 0, %param1 -> 1, etc.
        let suffix = string_slice(param, 6, string_len(param))
        return parse_u32(suffix)
      }

      # -------------------------------------------------------------------------
      # BUILTIN FUNCTION DETECTION
      # -------------------------------------------------------------------------

      rule is_builtin(name: string) -> bool {
        # Check if function is a known builtin (provided by runtime)
        # Vector operations
        if name == "vec_new" { return true }
        if name == "vec_len" { return true }
        if name == "vec_push" { return true }
        if name == "vec_get" { return true }
        if name == "vec_set" { return true }
        if name == "vec_clear" { return true }
        if name == "vec_pop" { return true }
        if name == "vec_from" { return true }
        if name == "vec_contains" { return true }
        if name == "vec_remove" { return true }
        # Map operations
        if name == "map_new" { return true }
        if name == "map_get" { return true }
        if name == "map_set" { return true }
        if name == "map_insert" { return true }
        if name == "map_has" { return true }
        if name == "map_keys" { return true }
        if name == "map_len" { return true }
        if name == "map_clear" { return true }
        if name == "map_contains" { return true }
        if name == "map_contains_key" { return true }
        # String operations
        if name == "string_eq" { return true }
        if name == "string_len" { return true }
        if name == "string_concat" { return true }
        if name == "string_split" { return true }
        if name == "string_slice" { return true }
        if name == "string_trim" { return true }
        if name == "string_char_at" { return true }
        if name == "len" { return true }
        if name == "starts_with" { return true }
        if name == "ends_with" { return true }
        if name == "contains" { return true }
        if name == "substring" { return true }
        if name == "char_at" { return true }
        if name == "char_code_at" { return true }
        if name == "index_of" { return true }
        # I/O operations
        if name == "print" { return true }
        if name == "println" { return true }
        if name == "format" { return true }
        if name == "read_file" { return true }
        if name == "write_file" { return true }
        if name == "chmod" { return true }
        # Memory operations
        if name == "heap_alloc" { return true }
        if name == "heap_free" { return true }
        if name == "is_numeric" { return true }
        if name == "string_contains" { return true }
        # Parsing/conversion
        if name == "parse_hex" { return true }
        if name == "parse_int" { return true }
        if name == "parse_u32" { return true }
        if name == "parse_i64" { return true }
        if name == "int_to_string" { return true }
        if name == "u32_to_string" { return true }
        if name == "i64_to_string" { return true }
        if name == "json_encode" { return true }
        if name == "json_decode" { return true }
        # Math
        if name == "max" { return true }
        if name == "min" { return true }
        if name == "abs" { return true }
        # Time
        if name == "time_now" { return true }
        # Runtime
        if name == "runtime_init" { return true }
        if name == "scheduler_run" { return true }
        if name == "scheduler_destroy" { return true }
        return false
      }
    }

