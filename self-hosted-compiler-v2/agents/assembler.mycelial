    hyphal assembler {
      frequency tidal_cycle

      state {
        # Input buffers
        asm_lines: vec<AsmLine>
        data_lines: vec<DataLine>
        current_section: string

        # Symbol table
        symbols: map<string, Symbol>

        # Section data
        text_section: Section
        rodata_section: Section
        data_section: Section
        bss_section: Section

        # Counters
        line_num: u32
        error_count: u32

        # Register encoding tables (initialized on first use)
        reg_codes: map<string, u8>
        reg_extended: map<string, boolean>
        reg_sizes: map<string, u8>
      }

      # -------------------------------------------------------------------------
      # INITIALIZATION
      # -------------------------------------------------------------------------

      on rest {
        if map_len(state.reg_codes) == 0 {
          init_register_tables()
          init_sections()
        }
      }

      rule init_register_tables() {
        # 64-bit registers (code, is_extended)
        state.reg_codes["rax"] = 0; state.reg_extended["rax"] = false; state.reg_sizes["rax"] = 64
        state.reg_codes["rcx"] = 1; state.reg_extended["rcx"] = false; state.reg_sizes["rcx"] = 64
        state.reg_codes["rdx"] = 2; state.reg_extended["rdx"] = false; state.reg_sizes["rdx"] = 64
        state.reg_codes["rbx"] = 3; state.reg_extended["rbx"] = false; state.reg_sizes["rbx"] = 64
        state.reg_codes["rsp"] = 4; state.reg_extended["rsp"] = false; state.reg_sizes["rsp"] = 64
        state.reg_codes["rbp"] = 5; state.reg_extended["rbp"] = false; state.reg_sizes["rbp"] = 64
        state.reg_codes["rsi"] = 6; state.reg_extended["rsi"] = false; state.reg_sizes["rsi"] = 64
        state.reg_codes["rdi"] = 7; state.reg_extended["rdi"] = false; state.reg_sizes["rdi"] = 64

        # Extended 64-bit registers (r8-r15)
        state.reg_codes["r8"]  = 0; state.reg_extended["r8"]  = true; state.reg_sizes["r8"]  = 64
        state.reg_codes["r9"]  = 1; state.reg_extended["r9"]  = true; state.reg_sizes["r9"]  = 64
        state.reg_codes["r10"] = 2; state.reg_extended["r10"] = true; state.reg_sizes["r10"] = 64
        state.reg_codes["r11"] = 3; state.reg_extended["r11"] = true; state.reg_sizes["r11"] = 64
        state.reg_codes["r12"] = 4; state.reg_extended["r12"] = true; state.reg_sizes["r12"] = 64
        state.reg_codes["r13"] = 5; state.reg_extended["r13"] = true; state.reg_sizes["r13"] = 64
        state.reg_codes["r14"] = 6; state.reg_extended["r14"] = true; state.reg_sizes["r14"] = 64
        state.reg_codes["r15"] = 7; state.reg_extended["r15"] = true; state.reg_sizes["r15"] = 64

        # 32-bit registers
        state.reg_codes["eax"] = 0; state.reg_extended["eax"] = false; state.reg_sizes["eax"] = 32
        state.reg_codes["ecx"] = 1; state.reg_extended["ecx"] = false; state.reg_sizes["ecx"] = 32
        state.reg_codes["edx"] = 2; state.reg_extended["edx"] = false; state.reg_sizes["edx"] = 32
        state.reg_codes["ebx"] = 3; state.reg_extended["ebx"] = false; state.reg_sizes["ebx"] = 32
        state.reg_codes["esp"] = 4; state.reg_extended["esp"] = false; state.reg_sizes["esp"] = 32
        state.reg_codes["ebp"] = 5; state.reg_extended["ebp"] = false; state.reg_sizes["ebp"] = 32
        state.reg_codes["esi"] = 6; state.reg_extended["esi"] = false; state.reg_sizes["esi"] = 32
        state.reg_codes["edi"] = 7; state.reg_extended["edi"] = false; state.reg_sizes["edi"] = 32

        # Extended 32-bit registers
        state.reg_codes["r8d"]  = 0; state.reg_extended["r8d"]  = true; state.reg_sizes["r8d"]  = 32
        state.reg_codes["r9d"]  = 1; state.reg_extended["r9d"]  = true; state.reg_sizes["r9d"]  = 32
        state.reg_codes["r10d"] = 2; state.reg_extended["r10d"] = true; state.reg_sizes["r10d"] = 32
        state.reg_codes["r11d"] = 3; state.reg_extended["r11d"] = true; state.reg_sizes["r11d"] = 32
        state.reg_codes["r12d"] = 4; state.reg_extended["r12d"] = true; state.reg_sizes["r12d"] = 32
        state.reg_codes["r13d"] = 5; state.reg_extended["r13d"] = true; state.reg_sizes["r13d"] = 32
        state.reg_codes["r14d"] = 6; state.reg_extended["r14d"] = true; state.reg_sizes["r14d"] = 32
        state.reg_codes["r15d"] = 7; state.reg_extended["r15d"] = true; state.reg_sizes["r15d"] = 32

        # 8-bit registers (low byte)
        state.reg_codes["al"] = 0; state.reg_extended["al"] = false; state.reg_sizes["al"] = 8
        state.reg_codes["cl"] = 1; state.reg_extended["cl"] = false; state.reg_sizes["cl"] = 8
        state.reg_codes["dl"] = 2; state.reg_extended["dl"] = false; state.reg_sizes["dl"] = 8
        state.reg_codes["bl"] = 3; state.reg_extended["bl"] = false; state.reg_sizes["bl"] = 8
        state.reg_codes["spl"] = 4; state.reg_extended["spl"] = false; state.reg_sizes["spl"] = 8
        state.reg_codes["bpl"] = 5; state.reg_extended["bpl"] = false; state.reg_sizes["bpl"] = 8
        state.reg_codes["sil"] = 6; state.reg_extended["sil"] = false; state.reg_sizes["sil"] = 8
        state.reg_codes["dil"] = 7; state.reg_extended["dil"] = false; state.reg_sizes["dil"] = 8
      }

      rule init_sections() {
        state.text_section = Section {
          name: ".text",
          data: vec_new(),
          relocations: vec_new()
        }
        state.rodata_section = Section {
          name: ".rodata",
          data: vec_new(),
          relocations: vec_new()
        }
        state.data_section = Section {
          name: ".data",
          data: vec_new(),
          relocations: vec_new()
        }
        state.bss_section = Section {
          name: ".bss",
          data: vec_new(),
          relocations: vec_new()
        }
        state.current_section = ".text"
      }

      # -------------------------------------------------------------------------
      # SIGNAL HANDLERS - SENSE PHASE
      # -------------------------------------------------------------------------

      on signal(asm_section, sect) {
        state.current_section = sect.name
      }

      on signal(asm_instruction, instr) {
        state.line_num = state.line_num + 1

        # Parse operands
        let parsed_operands: vec<Operand> = vec_new()
        for op_str in instr.operands {
          let op = parse_operand(op_str)
          vec_push(parsed_operands, op)
        }

        # Record label if present
        if instr.label != "" {
          let offset = get_current_section_offset()
          let sym = Symbol {
            name: instr.label,
            section: state.current_section,
            offset: offset,
            is_global: should_be_global(instr.label),
            is_defined: true
          }
          map_set(state.symbols, instr.label, sym)
        }

        # Buffer the instruction
        let line = AsmLine {
          label: instr.label,
          mnemonic: string_lower(instr.mnemonic),
          operands: parsed_operands,
          line_num: state.line_num
        }
        vec_push(state.asm_lines, line)
      }

      on signal(asm_data, data) {
        state.line_num = state.line_num + 1

        # Use section from signal, fallback to current if empty
        let target_section = if data.section != "" { data.section } else { state.current_section }

        # Record label if present
        if data.label != "" {
          let sym = Symbol {
            name: data.label,
            section: target_section,
            offset: 0,  # Will be updated during encode_data_sections
            is_global: should_be_global(data.label),
            is_defined: true
          }
          map_set(state.symbols, data.label, sym)
        }

        # Buffer the data
        let line = DataLine {
          label: data.label,
          data_type: data.data_type,
          value: data.value,
          line_num: state.line_num,
          section: target_section
        }
        vec_push(state.data_lines, line)
      }

      on signal(codegen_complete, done) {
        # All input received - perform two-pass assembly
        assemble_all()
      }

      # -------------------------------------------------------------------------
      # TWO-PASS ASSEMBLY
      # -------------------------------------------------------------------------

      rule assemble_all() {
        # Pass 1: Calculate instruction sizes, finalize symbol offsets
        pass1_calculate_sizes()

        # Pass 2: Encode all instructions, resolve labels
        pass2_encode_instructions()

        # Encode data sections
        encode_data_sections()

        # Emit results to Linker
        emit_results()
      }

      rule pass1_calculate_sizes() {
        let offset = 0u32

        for line in state.asm_lines {
          # Update label offset if present
          if line.label != "" && map_has(state.symbols, line.label) {
            let old_sym: Symbol = map_get(state.symbols, line.label)
            let sym = Symbol {
              name: old_sym.name,
              section: old_sym.section,
              offset: offset,
              is_global: old_sym.is_global,
              is_defined: old_sym.is_defined
            }
            map_set(state.symbols, line.label, sym)
          }

          # Calculate instruction size (conservative estimate)
          let size = estimate_instruction_size(line.mnemonic, line.operands)
          offset = offset + size
        }
      }

      rule pass2_encode_instructions() {
        for line in state.asm_lines {
          # Update symbol offset BEFORE encoding (label points to next instruction)
          if line.label != "" && map_has(state.symbols, line.label) {
            let old_sym: Symbol = map_get(state.symbols, line.label)
            let sym = Symbol {
              name: old_sym.name,
              section: old_sym.section,
              offset: vec_len(state.text_section.data),
              is_global: old_sym.is_global,
              is_defined: old_sym.is_defined
            }
            map_set(state.symbols, line.label, sym)
          }

          let encoded = encode_instruction(line.mnemonic, line.operands, line.line_num)

          # Add bytes to .text section (all instructions go to .text)
          for byte in encoded.bytes {
            vec_push(state.text_section.data, byte)
          }

          # Add relocations
          for reloc: InstrRelocation in encoded.relocations {
            let section_reloc = SectionRelocation {
              offset: vec_len(state.text_section.data) - vec_len(encoded.bytes) + reloc.offset,
              symbol: reloc.symbol,
              reloc_type: reloc.reloc_type,
              addend: reloc.addend
            }
            vec_push(state.text_section.relocations, section_reloc)
          }
        }
      }

      rule encode_data_sections() {
        for data in state.data_lines {
          # Update symbol offset and encode data based on section
          match data.section {
            ".text" => {
              if data.label != "" && map_has(state.symbols, data.label) {
                let old_sym: Symbol = map_get(state.symbols, data.label)
                let sym = Symbol {
                  name: old_sym.name,
                  section: old_sym.section,
                  offset: vec_len(state.text_section.data),
                  is_global: old_sym.is_global,
                  is_defined: old_sym.is_defined
                }
                map_set(state.symbols, data.label, sym)
              }
              encode_data_to_section_text(data)
            }
            ".rodata" => {
              if data.label != "" && map_has(state.symbols, data.label) {
                let old_sym: Symbol = map_get(state.symbols, data.label)
                let sym = Symbol {
                  name: old_sym.name,
                  section: old_sym.section,
                  offset: vec_len(state.rodata_section.data),
                  is_global: old_sym.is_global,
                  is_defined: old_sym.is_defined
                }
                map_set(state.symbols, data.label, sym)
              }
              encode_data_to_section_rodata(data)
            }
            ".data" => {
              if data.label != "" && map_has(state.symbols, data.label) {
                let old_sym: Symbol = map_get(state.symbols, data.label)
                let sym = Symbol {
                  name: old_sym.name,
                  section: old_sym.section,
                  offset: vec_len(state.data_section.data),
                  is_global: old_sym.is_global,
                  is_defined: old_sym.is_defined
                }
                map_set(state.symbols, data.label, sym)
              }
              encode_data_to_section_data(data)
            }
            ".bss" => {
              if data.label != "" && map_has(state.symbols, data.label) {
                let old_sym: Symbol = map_get(state.symbols, data.label)
                let sym = Symbol {
                  name: old_sym.name,
                  section: old_sym.section,
                  offset: vec_len(state.bss_section.data),
                  is_global: old_sym.is_global,
                  is_defined: old_sym.is_defined
                }
                map_set(state.symbols, data.label, sym)
              }
              encode_data_to_section_bss(data)
            }
            _ => {
              # Default to .text
              encode_data_to_section_text(data)
            }
          }
        }
      }

      rule encode_data_to_section_data(data: DataLine) {
        match data.data_type {
          "asciz" | "ascii" => {
            let bytes = string_to_bytes(data.value)
            for byte in bytes {
              vec_push(state.data_section.data, byte)
            }
            if data.data_type == "asciz" {
              vec_push(state.data_section.data, 0u8)
            }
          }
          "quad" => {
            let val = parse_i64(data.value)
            let bytes = i64_to_le_bytes(val)
            for byte in bytes {
              vec_push(state.data_section.data, byte)
            }
          }
          "byte" => {
            let val = parse_u8(data.value)
            vec_push(state.data_section.data, val)
          }
          "align" => {
            let alignment = parse_u32(data.value)
            let current = vec_len(state.data_section.data)
            let padding = (alignment - (current % alignment)) % alignment
            for i in 0..padding {
              vec_push(state.data_section.data, 0u8)
            }
          }
          _ => {}
        }
      }

      rule encode_data_to_section_rodata(data: DataLine) {
        match data.data_type {
          "asciz" | "ascii" => {
            let bytes = string_to_bytes(data.value)
            for byte in bytes {
              vec_push(state.rodata_section.data, byte)
            }
            if data.data_type == "asciz" {
              vec_push(state.rodata_section.data, 0u8)
            }
          }
          "quad" => {
            let val = parse_i64(data.value)
            let bytes = i64_to_le_bytes(val)
            for byte in bytes {
              vec_push(state.rodata_section.data, byte)
            }
          }
          "byte" => {
            let val = parse_u8(data.value)
            vec_push(state.rodata_section.data, val)
          }
          "align" => {
            let alignment = parse_u32(data.value)
            let current = vec_len(state.rodata_section.data)
            let padding = (alignment - (current % alignment)) % alignment
            for i in 0..padding {
              vec_push(state.rodata_section.data, 0u8)
            }
          }
          _ => {}
        }
      }

      rule encode_data_to_section_text(data: DataLine) {
        match data.data_type {
          "asciz" | "ascii" => {
            let bytes = string_to_bytes(data.value)
            for byte in bytes {
              vec_push(state.text_section.data, byte)
            }
            if data.data_type == "asciz" {
              vec_push(state.text_section.data, 0u8)
            }
          }
          "quad" => {
            let val = parse_i64(data.value)
            let bytes = i64_to_le_bytes(val)
            for byte in bytes {
              vec_push(state.text_section.data, byte)
            }
          }
          "byte" => {
            let val = parse_u8(data.value)
            vec_push(state.text_section.data, val)
          }
          "align" => {
            let alignment = parse_u32(data.value)
            let current = vec_len(state.text_section.data)
            let padding = (alignment - (current % alignment)) % alignment
            for i in 0..padding {
              vec_push(state.text_section.data, 0u8)
            }
          }
          _ => {}
        }
      }

      rule encode_data_to_section_bss(data: DataLine) {
        # BSS section - just track size, data is zero-filled at runtime
        match data.data_type {
          "space" => {
            # Reserve N bytes (value is the size)
            let size = parse_u32(data.value)
            let i: u32 = 0
            while i < size {
              # Add placeholder bytes to track size (won't be written to file)
              vec_push(state.bss_section.data, 0u8)
              i = i + 1
            }
          }
          "quad" => {
            # Reserve 8 bytes
            for i in 0..8 {
              vec_push(state.bss_section.data, 0u8)
            }
          }
          "align" => {
            let alignment = parse_u32(data.value)
            let current = vec_len(state.bss_section.data)
            let padding = (alignment - (current % alignment)) % alignment
            for i in 0..padding {
              vec_push(state.bss_section.data, 0u8)
            }
          }
          _ => {}
        }
      }

      rule emit_results() {
        # Emit text section
        if vec_len(state.text_section.data) > 0 {
          emit machine_code {
            section: ".text",
            offset: 0,
            bytes: state.text_section.data
          }

          for reloc: SectionRelocation in state.text_section.relocations {
            emit relocation {
              section: ".text",
              offset: reloc.offset,
              symbol: reloc.symbol,
              reloc_type: reloc.reloc_type,
              addend: reloc.addend
            }
          }

          emit section_info {
            name: ".text",
            size: vec_len(state.text_section.data),
            flags: 0x6  # 0x2 | 0x4
          }
        }

        # Emit rodata section
        if vec_len(state.rodata_section.data) > 0 {
          emit machine_code {
            section: ".rodata",
            offset: 0,
            bytes: state.rodata_section.data
          }

          emit section_info {
            name: ".rodata",
            size: vec_len(state.rodata_section.data),
            flags: 0x2  # 0x2
          }
        }

        # Emit data section
        if vec_len(state.data_section.data) > 0 {
          emit machine_code {
            section: ".data",
            offset: 0,
            bytes: state.data_section.data
          }

          for reloc: SectionRelocation in state.data_section.relocations {
            emit relocation {
              section: ".data",
              offset: reloc.offset,
              symbol: reloc.symbol,
              reloc_type: reloc.reloc_type,
              addend: reloc.addend
            }
          }

          emit section_info {
            name: ".data",
            size: vec_len(state.data_section.data),
            flags: 0x3  # SHF_WRITE | SHF_ALLOC
          }
        }

        # Emit BSS section (no data bytes, just size info)
        if vec_len(state.bss_section.data) > 0 {
          # BSS doesn't emit machine_code, just section info with size
          emit section_info {
            name: ".bss",
            size: vec_len(state.bss_section.data),
            flags: 0x3  # SHF_WRITE | SHF_ALLOC
          }
        }

        # Emit symbols
        for name: string, sym: Symbol in state.symbols {
          emit symbol_def {
            name: sym.name,
            section: sym.section,
            offset: sym.offset,
            is_global: sym.is_global
          }
        }

        # Emit completion
        let total_relocs = vec_len(state.text_section.relocations) +
                           vec_len(state.rodata_section.relocations) +
                           vec_len(state.data_section.relocations)

        emit asm_complete {
          total_bytes: vec_len(state.text_section.data) +
                       vec_len(state.rodata_section.data) +
                       vec_len(state.data_section.data),
          symbol_count: map_len(state.symbols),
          relocation_count: total_relocs
        }
      }

      # -------------------------------------------------------------------------
      # OPERAND PARSING
      # -------------------------------------------------------------------------

      rule parse_operand(op_str: string) -> Operand {
        let s = string_trim(op_str)

        # Check for register (with or without % prefix)
        let reg_name = if starts_with(s, "%") { string_slice(s, 1, string_len(s)) } else { s }
        if map_has(state.reg_codes, reg_name) {
          return Operand::Reg(RegisterInfo {
            name: reg_name,
            code: map_get(state.reg_codes, reg_name),
            is_extended: map_get(state.reg_extended, reg_name),
            size: map_get(state.reg_sizes, reg_name)
          })
        }

        # Check for immediate (with $ prefix or plain number)
        if starts_with(s, "$") {
          let val_str = string_slice(s, 1, string_len(s))
          let val = parse_number_value(val_str)
          return Operand::Imm(val)
        }
        if is_numeric_string(s) {
          return Operand::Imm(parse_number_value(s))
        }

        # Check for memory operand: [base + index*scale + disp] or offset(base, index, scale)
        if starts_with(s, "(") || contains(s, "(") {
          return Operand::Mem(parse_memory_operand(s))
        }

        # Otherwise, it's a label reference
        return Operand::Label(s)
      }

      rule parse_memory_operand(s: string) -> MemoryOperand {
        # Parse AT&T syntax: disp(base, index, scale) or (base)
        # Also handle: offset(%reg) or (%reg) or symbol(%rip)

        let base = ""
        let index = ""
        let scale = 1u8
        let displacement = 0i32
        let is_rip = false
        let symbol = ""

        # Find displacement/symbol (before parenthesis)
        let paren_pos = string_index_of(s, "(")
        if paren_pos > 0 {
          let disp_str = string_slice(s, 0, paren_pos)
          if disp_str != "" {
            if is_numeric_string(disp_str) {
              displacement = parse_i32(disp_str)
            } else {
              # It's a symbol name
              symbol = disp_str
            }
          }
        }

        # Extract content inside parentheses
        let start = paren_pos + 1
        let end = string_index_of(s, ")")
        let inner = string_slice(s, start, end)

        # Parse base, index, scale
        let parts = string_split(inner, ",")
        if vec_len(parts) >= 1 && vec_get(parts, 0) != "" {
          base = string_trim(vec_get(parts, 0))
          if starts_with(base, "%") {
            base = string_slice(base, 1, string_len(base))
          }
          if base == "rip" {
            is_rip = true
          }
        }
        if vec_len(parts) >= 2 && vec_get(parts, 1) != "" {
          index = string_trim(vec_get(parts, 1))
          if starts_with(index, "%") {
            index = string_slice(index, 1, string_len(index))
          }
        }
        if vec_len(parts) >= 3 && vec_get(parts, 2) != "" {
          scale = parse_u8(string_trim(vec_get(parts, 2)))
        }

        return MemoryOperand {
          base: base,
          index: index,
          scale: scale,
          displacement: displacement,
          is_rip_relative: is_rip,
          symbol: symbol
        }
      }

      # -------------------------------------------------------------------------
      # INSTRUCTION ENCODING
      # -------------------------------------------------------------------------

      rule encode_instruction(mnemonic: string, operands: vec<Operand>, line: u32) -> EncodedInstruction {
        let bytes: vec<u8> = vec_new()
        let relocs: vec<InstrRelocation> = vec_new()

        match mnemonic {
          # Empty mnemonic - label-only pseudo-instruction
          "" => {
            # Just a label, no actual instruction bytes
          }

          # --- DATA MOVEMENT ---
          "mov" | "movq" | "movl" | "movw" => {
            encode_mov(operands, bytes, relocs)
          }
          "movabs" | "movabsq" => {
            encode_movabs(operands, bytes, relocs)
          }
          "lea" | "leaq" => {
            encode_lea(operands, bytes, relocs)
          }
          "push" | "pushq" => {
            encode_push(operands, bytes)
          }
          "pop" | "popq" => {
            encode_pop(operands, bytes)
          }

          # --- ARITHMETIC ---
          "add" | "addq" | "addl" => {
            encode_alu(operands, bytes, relocs, 0x01, 0x03, 0x81, 0x83, 0)
          }
          "sub" | "subq" | "subl" => {
            encode_alu(operands, bytes, relocs, 0x29, 0x2B, 0x81, 0x83, 5)
          }
          "imul" | "imulq" => {
            encode_imul(operands, bytes)
          }
          "idiv" | "idivq" => {
            encode_idiv(operands, bytes)
          }
          "neg" | "negq" => {
            encode_unary(operands, bytes, 0xF7, 3)
          }
          "inc" | "incq" => {
            encode_unary(operands, bytes, 0xFF, 0)
          }
          "dec" | "decq" => {
            encode_unary(operands, bytes, 0xFF, 1)
          }

          # --- BITWISE LOGIC ---
          "and" | "andq" | "andl" => {
            encode_alu(operands, bytes, relocs, 0x21, 0x23, 0x81, 0x83, 4)
          }
          "or" | "orq" | "orl" => {
            encode_alu(operands, bytes, relocs, 0x09, 0x0B, 0x81, 0x83, 1)
          }
          "xor" | "xorq" | "xorl" => {
            encode_alu(operands, bytes, relocs, 0x31, 0x33, 0x81, 0x83, 6)
          }
          "not" | "notq" => {
            encode_unary(operands, bytes, 0xF7, 2)
          }
          "shl" | "shlq" | "sal" | "salq" => {
            encode_shift(operands, bytes, 4)
          }
          "shr" | "shrq" => {
            encode_shift(operands, bytes, 5)
          }
          "sar" | "sarq" => {
            encode_shift(operands, bytes, 7)
          }

          # --- COMPARISON ---
          "cmp" | "cmpq" | "cmpl" => {
            encode_alu(operands, bytes, relocs, 0x39, 0x3B, 0x81, 0x83, 7)
          }
          "cmpb" => {
            encode_byte_cmp(operands, bytes)
          }
          "test" | "testq" | "testl" => {
            encode_test(operands, bytes)
          }
          "testb" => {
            encode_byte_test(operands, bytes)
          }

          # --- BYTE OPERATIONS ---
          "movb" => {
            encode_byte_mov(operands, bytes, relocs)
          }
          "andb" => {
            encode_byte_alu(operands, bytes, 4)  # AND = /4
          }
          "subb" => {
            encode_byte_alu(operands, bytes, 5)  # SUB = /5
          }

          # --- CONTROL FLOW ---
          "jmp" => {
            encode_jmp(operands, bytes, relocs)
          }
          "je" | "jz" => {
            encode_jcc(operands, bytes, relocs, 0x84, 0x74)
          }
          "jne" | "jnz" => {
            encode_jcc(operands, bytes, relocs, 0x85, 0x75)
          }
          "jl" | "jnge" => {
            encode_jcc(operands, bytes, relocs, 0x8C, 0x7C)
          }
          "jle" | "jng" => {
            encode_jcc(operands, bytes, relocs, 0x8E, 0x7E)
          }
          "jg" | "jnle" => {
            encode_jcc(operands, bytes, relocs, 0x8F, 0x7F)
          }
          "jge" | "jnl" => {
            encode_jcc(operands, bytes, relocs, 0x8D, 0x7D)
          }
          "ja" | "jnbe" => {
            encode_jcc(operands, bytes, relocs, 0x87, 0x77)
          }
          "jae" | "jnb" | "jnc" => {
            encode_jcc(operands, bytes, relocs, 0x83, 0x73)
          }
          "jb" | "jnae" | "jc" => {
            encode_jcc(operands, bytes, relocs, 0x82, 0x72)
          }
          "jbe" | "jna" => {
            encode_jcc(operands, bytes, relocs, 0x86, 0x76)
          }
          "call" => {
            encode_call(operands, bytes, relocs)
          }
          "ret" | "retq" => {
            vec_push(bytes, 0xC3)
          }

          # --- SET BYTE ---
          "sete" | "setz" => {
            encode_setcc(operands, bytes, 0x94)
          }
          "setne" | "setnz" => {
            encode_setcc(operands, bytes, 0x95)
          }
          "setl" | "setnge" => {
            encode_setcc(operands, bytes, 0x9C)
          }
          "setle" | "setng" => {
            encode_setcc(operands, bytes, 0x9E)
          }
          "setg" | "setnle" => {
            encode_setcc(operands, bytes, 0x9F)
          }
          "setge" | "setnl" => {
            encode_setcc(operands, bytes, 0x9D)
          }

          # --- ZERO/SIGN EXTEND ---
          "movzbq" | "movzbl" => {
            encode_movzx(operands, bytes)
          }
          "movsbq" | "movsbl" => {
            encode_movsx(operands, bytes)
          }
          "movsxd" | "movslq" => {
            encode_movsxd(operands, bytes)
          }
          "cqo" | "cqto" => {
            vec_push(bytes, 0x48)  # REX.W
            vec_push(bytes, 0x99)  # CQO
          }
          "cdq" | "cltd" => {
            vec_push(bytes, 0x99)  # CDQ
          }

          # --- EXCHANGE ---
          "xchg" | "xchgq" => {
            encode_xchg(operands, bytes)
          }

          # --- UNSIGNED MULTIPLY/DIVIDE ---
          "mul" | "mulq" => {
            encode_unary(operands, bytes, 0xF7, 4)  # MUL r/m64
          }
          "div" | "divq" => {
            encode_unary(operands, bytes, 0xF7, 6)  # DIV r/m64
          }

          # --- ADDITIONAL CONDITIONAL JUMPS ---
          "js" => {
            encode_jcc(operands, bytes, relocs, 0x88, 0x78)
          }
          "jns" => {
            encode_jcc(operands, bytes, relocs, 0x89, 0x79)
          }
          "jo" => {
            encode_jcc(operands, bytes, relocs, 0x80, 0x70)
          }
          "jno" => {
            encode_jcc(operands, bytes, relocs, 0x81, 0x71)
          }
          "jp" | "jpe" => {
            encode_jcc(operands, bytes, relocs, 0x8A, 0x7A)
          }
          "jnp" | "jpo" => {
            encode_jcc(operands, bytes, relocs, 0x8B, 0x7B)
          }

          # --- ADDITIONAL SET BYTE ---
          "seta" | "setnbe" => {
            encode_setcc(operands, bytes, 0x97)
          }
          "setae" | "setnb" | "setnc" => {
            encode_setcc(operands, bytes, 0x93)
          }
          "setb" | "setnae" | "setc" => {
            encode_setcc(operands, bytes, 0x92)
          }
          "setbe" | "setna" => {
            encode_setcc(operands, bytes, 0x96)
          }
          "sets" => {
            encode_setcc(operands, bytes, 0x98)
          }
          "setns" => {
            encode_setcc(operands, bytes, 0x99)
          }
          "seto" => {
            encode_setcc(operands, bytes, 0x90)
          }
          "setno" => {
            encode_setcc(operands, bytes, 0x91)
          }
          "setp" | "setpe" => {
            encode_setcc(operands, bytes, 0x9A)
          }
          "setnp" | "setpo" => {
            encode_setcc(operands, bytes, 0x9B)
          }

          # --- CONDITIONAL MOVE ---
          "cmove" | "cmovz" => {
            encode_cmovcc(operands, bytes, 0x44)
          }
          "cmovne" | "cmovnz" => {
            encode_cmovcc(operands, bytes, 0x45)
          }
          "cmovl" | "cmovnge" => {
            encode_cmovcc(operands, bytes, 0x4C)
          }
          "cmovle" | "cmovng" => {
            encode_cmovcc(operands, bytes, 0x4E)
          }
          "cmovg" | "cmovnle" => {
            encode_cmovcc(operands, bytes, 0x4F)
          }
          "cmovge" | "cmovnl" => {
            encode_cmovcc(operands, bytes, 0x4D)
          }
          "cmova" | "cmovnbe" => {
            encode_cmovcc(operands, bytes, 0x47)
          }
          "cmovae" | "cmovnb" | "cmovnc" => {
            encode_cmovcc(operands, bytes, 0x43)
          }
          "cmovb" | "cmovnae" | "cmovc" => {
            encode_cmovcc(operands, bytes, 0x42)
          }
          "cmovbe" | "cmovna" => {
            encode_cmovcc(operands, bytes, 0x46)
          }
          "cmovs" => {
            encode_cmovcc(operands, bytes, 0x48)
          }
          "cmovns" => {
            encode_cmovcc(operands, bytes, 0x49)
          }

          # --- SYSTEM ---
          "syscall" => {
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0x05)
          }
          "nop" => {
            vec_push(bytes, 0x90)
          }
          "hlt" => {
            vec_push(bytes, 0xF4)
          }
          "ud2" => {
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0x0B)
          }

          _ => {
            emit asm_error {
              message: format("Unknown instruction: {}", mnemonic),
              line: line,
              instruction: mnemonic
            }
            state.error_count = state.error_count + 1
          }
        }

        return EncodedInstruction {
          bytes: bytes,
          relocations: relocs
        }
      }

      # -------------------------------------------------------------------------
      # MOV ENCODING
      # -------------------------------------------------------------------------

      rule encode_mov(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 2 {
          return
        }

        let src = vec_get(operands, 0)
        let dst = vec_get(operands, 1)

        match (src, dst) {
          # mov reg, reg
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(dst_reg, src_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x89)  # MOV r/m64, r64
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }

          # mov imm, reg
          (Operand::Imm(val), Operand::Reg(dst_reg)) => {
            if val >= -2147483648 && val <= 2147483647 {
              # 32-bit immediate (sign-extended)
              let rex = build_rex_r(dst_reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0xC7)  # MOV r/m64, imm32
              vec_push(bytes, build_modrm(3, 0, dst_reg.code))
              append_imm32(bytes, val as i32)
            } else {
              # 64-bit immediate (movabs)
              let rex = 0x48 | (if dst_reg.is_extended { 0x01 } else { 0 })
              vec_push(bytes, rex)
              vec_push(bytes, 0xB8 + dst_reg.code)  # MOV r64, imm64
              append_imm64(bytes, val)
            }
          }

          # mov mem, reg (load)
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            encode_mem_reg(bytes, relocs, mem, dst_reg, 0x8B, true)
          }

          # mov reg, mem (store)
          (Operand::Reg(src_reg), Operand::Mem(mem)) => {
            encode_reg_mem(bytes, relocs, src_reg, mem, 0x89, true)
          }

          # mov label, reg
          (Operand::Label(label), Operand::Reg(dst_reg)) => {
            # lea with RIP-relative addressing
            let rex = build_rex_r(dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x8D)  # LEA
            vec_push(bytes, build_modrm(0, dst_reg.code, 5))  # RIP-relative
            # Add relocation
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }

          _ => {
            # Unsupported operand combination
          }
        }
      }

      # -------------------------------------------------------------------------
      # MOVABS ENCODING (64-bit immediate)
      # -------------------------------------------------------------------------

      rule encode_movabs(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Imm(val), Operand::Reg(dst_reg)) => {
            let rex = 0x48 | (if dst_reg.is_extended { 0x01 } else { 0 })
            vec_push(bytes, rex)
            vec_push(bytes, 0xB8 + dst_reg.code)  # MOV r64, imm64
            append_imm64(bytes, val)
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # LEA ENCODING
      # -------------------------------------------------------------------------

      rule encode_lea(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            encode_mem_reg(bytes, relocs, mem, dst_reg, 0x8D, true)
          }
          (Operand::Label(label), Operand::Reg(dst_reg)) => {
            # RIP-relative LEA
            let rex = build_rex_r(dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x8D)  # LEA
            vec_push(bytes, build_modrm(0, dst_reg.code, 5))  # RIP-relative
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # PUSH/POP ENCODING
      # -------------------------------------------------------------------------

      rule encode_push(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Reg(reg) => {
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0x50 + reg.code)
          }
          Operand::Imm(val) => {
            if val >= -128 && val <= 127 {
              vec_push(bytes, 0x6A)  # PUSH imm8
              vec_push(bytes, val as u8)
            } else {
              vec_push(bytes, 0x68)  # PUSH imm32
              append_imm32(bytes, val as i32)
            }
          }
          _ => {}
        }
      }

      rule encode_pop(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Reg(reg) => {
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0x58 + reg.code)
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # ALU OPERATIONS (add, sub, and, or, xor, cmp)
      # -------------------------------------------------------------------------

      rule encode_alu(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>,
                      opcode_rm_r: u8, opcode_r_rm: u8, opcode_rm_imm32: u8, opcode_rm_imm8: u8,
                      reg_opcode: u8) {
        if vec_len(operands) != 2 {
          return
        }

        let src = vec_get(operands, 0)
        let dst = vec_get(operands, 1)

        match (src, dst) {
          # alu reg, reg
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(dst_reg, src_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, opcode_rm_r)
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }

          # alu imm, reg
          (Operand::Imm(val), Operand::Reg(dst_reg)) => {
            let rex = build_rex_r(dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }

            if val >= -128 && val <= 127 {
              vec_push(bytes, opcode_rm_imm8)  # 83 /r
              vec_push(bytes, build_modrm(3, reg_opcode, dst_reg.code))
              vec_push(bytes, val as u8)
            } else {
              vec_push(bytes, opcode_rm_imm32)  # 81 /r
              vec_push(bytes, build_modrm(3, reg_opcode, dst_reg.code))
              append_imm32(bytes, val as i32)
            }
          }

          # alu mem, reg
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            encode_mem_reg(bytes, relocs, mem, dst_reg, opcode_r_rm, true)
          }

          # alu reg, mem
          (Operand::Reg(src_reg), Operand::Mem(mem)) => {
            encode_reg_mem(bytes, relocs, src_reg, mem, opcode_rm_r, true)
          }

          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # IMUL/IDIV ENCODING
      # -------------------------------------------------------------------------

      rule encode_imul(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) == 1 {
          # imul r/m64 (rdx:rax = rax * r/m64)
          match vec_get(operands, 0) {
            Operand::Reg(reg) => {
              let rex = build_rex_r(reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0xF7)
              vec_push(bytes, build_modrm(3, 5, reg.code))
            }
            _ => {}
          }
        } else if vec_len(operands) == 2 {
          # imul r64, r/m64
          match (vec_get(operands, 0), vec_get(operands, 1)) {
            (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
              let rex = build_rex_rr(src_reg, dst_reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0x0F)
              vec_push(bytes, 0xAF)
              vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
            }
            _ => {}
          }
        }
      }

      rule encode_idiv(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Reg(reg) => {
            let rex = build_rex_r(reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0xF7)
            vec_push(bytes, build_modrm(3, 7, reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # UNARY OPERATIONS (neg, not, inc, dec)
      # -------------------------------------------------------------------------

      rule encode_unary(operands: vec<Operand>, bytes: vec<u8>, opcode: u8, reg_opcode: u8) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Reg(reg) => {
            let rex = build_rex_r(reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, opcode)
            vec_push(bytes, build_modrm(3, reg_opcode, reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # SHIFT OPERATIONS
      # -------------------------------------------------------------------------

      rule encode_shift(operands: vec<Operand>, bytes: vec<u8>, reg_opcode: u8) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          # shift imm8, reg
          (Operand::Imm(count), Operand::Reg(reg)) => {
            let rex = build_rex_r(reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            if count == 1 {
              vec_push(bytes, 0xD1)  # Shift by 1
            } else {
              vec_push(bytes, 0xC1)  # Shift by imm8
            }
            vec_push(bytes, build_modrm(3, reg_opcode, reg.code))
            if count != 1 {
              vec_push(bytes, count as u8)
            }
          }
          # shift cl, reg
          (Operand::Reg(cl_reg), Operand::Reg(reg)) => {
            if cl_reg.name == "cl" {
              let rex = build_rex_r(reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0xD3)  # Shift by CL
              vec_push(bytes, build_modrm(3, reg_opcode, reg.code))
            }
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # TEST ENCODING
      # -------------------------------------------------------------------------

      rule encode_test(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(dst_reg, src_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x85)  # TEST r/m64, r64
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # BYTE OPERATION ENCODING
      # -------------------------------------------------------------------------

      rule encode_byte_test(operands: vec<Operand>, bytes: vec<u8>) {
        # testb %r8, %r8
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            # For byte registers like %cl, %al - need to handle specially
            # REX prefix may be needed for r8-r15 low bytes
            let src_code: u8 = src_reg.code
            let dst_code: u8 = dst_reg.code
            # Use legacy byte registers (al=0, cl=1, dl=2, bl=3)
            # No REX prefix for these
            vec_push(bytes, 0x84)  # TEST r/m8, r8
            vec_push(bytes, build_modrm(3, src_code, dst_code))
          }
          _ => {}
        }
      }

      rule encode_byte_cmp(operands: vec<Operand>, bytes: vec<u8>) {
        # cmpb $imm8, %r8  OR  cmpb %r8, %r8
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Imm(imm), Operand::Reg(dst_reg)) => {
            # CMP r/m8, imm8 -> 80 /7 ib
            vec_push(bytes, 0x80)
            vec_push(bytes, build_modrm(3, 7, dst_reg.code))
            vec_push(bytes, imm & 0xFF)
          }
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            # CMP r/m8, r8 -> 38 /r
            vec_push(bytes, 0x38)
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }
          _ => {}
        }
      }

      rule encode_byte_mov(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        # movb (mem), %r8  OR  movb %r8, (mem)
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            # MOV r8, r/m8 -> 8A /r
            # Reuse encode_mem_reg with byte opcode
            encode_mem_reg(bytes, relocs, mem, dst_reg, 0x8A, false)
          }
          (Operand::Reg(src_reg), Operand::Mem(mem)) => {
            # MOV r/m8, r8 -> 88 /r
            encode_reg_mem(bytes, relocs, src_reg, mem, 0x88, false)
          }
          _ => {}
        }
      }

      rule encode_byte_alu(operands: vec<Operand>, bytes: vec<u8>, op_ext: u8) {
        # Byte ALU operations: andb, subb, etc.
        # Format: OP r/m8, imm8 -> 80 /op_ext ib
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Imm(imm), Operand::Reg(dst_reg)) => {
            vec_push(bytes, 0x80)
            vec_push(bytes, build_modrm(3, op_ext, dst_reg.code))
            vec_push(bytes, imm & 0xFF)
          }
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            # r/m8, r8 forms
            match op_ext {
              4 => { vec_push(bytes, 0x20) }  # AND
              5 => { vec_push(bytes, 0x28) }  # SUB
              _ => { vec_push(bytes, 0x00) }  # ADD (default)
            }
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # JUMP ENCODING
      # -------------------------------------------------------------------------

      rule encode_jmp(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Label(label) => {
            # Always use rel32 for simplicity
            vec_push(bytes, 0xE9)  # JMP rel32
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }
          Operand::Reg(reg) => {
            # JMP r/m64 (indirect jump)
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0xFF)
            vec_push(bytes, build_modrm(3, 4, reg.code))
          }
          _ => {}
        }
      }

      rule encode_jcc(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>,
                      opcode_rel32: u8, opcode_rel8: u8) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Label(label) => {
            # Use rel32 form (0F 8x)
            vec_push(bytes, 0x0F)
            vec_push(bytes, opcode_rel32)
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # CALL ENCODING
      # -------------------------------------------------------------------------

      rule encode_call(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Label(label) => {
            vec_push(bytes, 0xE8)  # CALL rel32
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }
          Operand::Reg(reg) => {
            # CALL r/m64 (indirect call)
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0xFF)
            vec_push(bytes, build_modrm(3, 2, reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # SETCC ENCODING
      # -------------------------------------------------------------------------

      rule encode_setcc(operands: vec<Operand>, bytes: vec<u8>, opcode: u8) {
        if vec_len(operands) != 1 {
          return
        }

        match vec_get(operands, 0) {
          Operand::Reg(reg) => {
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, opcode)
            vec_push(bytes, build_modrm(3, 0, reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # MOVZX/MOVSX ENCODING
      # -------------------------------------------------------------------------

      rule encode_movzx(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0xB6)  # MOVZX r64, r/m8
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      rule encode_movsx(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0xBE)  # MOVSX r64, r/m8
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # MOVSXD ENCODING (Sign-extend dword to qword)
      # -------------------------------------------------------------------------

      rule encode_movsxd(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x63)  # MOVSXD r64, r/m32
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # XCHG ENCODING
      # -------------------------------------------------------------------------

      rule encode_xchg(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            # Special case: xchg rax, reg uses short form
            if dst_reg.name == "rax" && !src_reg.is_extended {
              vec_push(bytes, 0x48)  # REX.W
              vec_push(bytes, 0x90 + src_reg.code)  # XCHG rax, r64
            } else if src_reg.name == "rax" && !dst_reg.is_extended {
              vec_push(bytes, 0x48)  # REX.W
              vec_push(bytes, 0x90 + dst_reg.code)  # XCHG rax, r64
            } else {
              # General form: XCHG r/m64, r64
              let rex = build_rex_rr(dst_reg, src_reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0x87)  # XCHG r/m64, r64
              vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
            }
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # CMOVCC ENCODING (Conditional Move)
      # -------------------------------------------------------------------------

      rule encode_cmovcc(operands: vec<Operand>, bytes: vec<u8>, opcode: u8) {
        if vec_len(operands) != 2 {
          return
        }

        match (vec_get(operands, 0), vec_get(operands, 1)) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, opcode)  # CMOVcc r64, r/m64
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      # -------------------------------------------------------------------------
      # MEMORY ADDRESSING HELPERS
      # -------------------------------------------------------------------------

      rule encode_mem_reg(bytes: vec<u8>, relocs: vec<InstrRelocation>,
                          mem: MemoryOperand, reg: RegisterInfo, opcode: u8, is_64bit: boolean) {
        # Build REX prefix
        let rex = build_rex_mem_reg(mem, reg, is_64bit)
        if rex != 0 {
          vec_push(bytes, rex)
        }

        vec_push(bytes, opcode)

        # Encode addressing mode
        encode_memory_modrm_sib(bytes, relocs, mem, reg.code)
      }

      rule encode_reg_mem(bytes: vec<u8>, relocs: vec<InstrRelocation>,
                          reg: RegisterInfo, mem: MemoryOperand, opcode: u8, is_64bit: boolean) {
        # Build REX prefix
        let rex = build_rex_mem_reg(mem, reg, is_64bit)
        if rex != 0 {
          vec_push(bytes, rex)
        }

        vec_push(bytes, opcode)

        # Encode addressing mode
        encode_memory_modrm_sib(bytes, relocs, mem, reg.code)
      }

      rule encode_memory_modrm_sib(bytes: vec<u8>, relocs: vec<InstrRelocation>,
                                    mem: MemoryOperand, reg_code: u8) {
        if mem.is_rip_relative || mem.base == "" {
          # RIP-relative or absolute addressing
          vec_push(bytes, build_modrm(0, reg_code, 5))  # mod=00, r/m=101 (RIP-relative)

          if mem.symbol != "" {
            # Symbolic reference - emit relocation
            let reloc = InstrRelocation {
              offset: vec_len(bytes),
              symbol: mem.symbol,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4  # PC-relative needs -4 adjustment
            }
            vec_push(relocs, reloc)
            append_imm32(bytes, 0)  # Placeholder, will be patched by linker
          } else {
            append_imm32(bytes, mem.displacement)
          }
          return
        }

        let base_code = map_get(state.reg_codes, mem.base)
        let base_extended = map_get(state.reg_extended, mem.base)
        let needs_sib = mem.index != "" || mem.base == "rsp" || mem.base == "r12"

        # Determine mod field based on displacement
        let mod_field = 0u8
        if mem.displacement == 0 && mem.base != "rbp" && mem.base != "r13" {
          mod_field = 0  # No displacement
        } else if mem.displacement >= -128 && mem.displacement <= 127 {
          mod_field = 1  # 8-bit displacement
        } else {
          mod_field = 2  # 32-bit displacement
        }

        if needs_sib {
          # Need SIB byte
          let rm_field = 4u8  # SIB follows
          vec_push(bytes, build_modrm(mod_field, reg_code, rm_field))

          # Build SIB byte
          let scale = match mem.scale {
            1 => 0u8
            2 => 1u8
            4 => 2u8
            8 => 3u8
            _ => 0u8
          }

          let index_code = if mem.index != "" {
            map_get(state.reg_codes, mem.index)
          } else {
            4  # No index (100)
          }

          vec_push(bytes, (scale << 6) | (index_code << 3) | base_code)
        } else {
          vec_push(bytes, build_modrm(mod_field, reg_code, base_code))
        }

        # Add displacement
        if mod_field == 1 {
          vec_push(bytes, mem.displacement as u8)
        } else if mod_field == 2 {
          append_imm32(bytes, mem.displacement)
        } else if mem.base == "rbp" || mem.base == "r13" {
          # Special case: rbp/r13 with no displacement needs disp8=0
          vec_push(bytes, 0)
        }
      }

      # -------------------------------------------------------------------------
      # REX PREFIX HELPERS
      # -------------------------------------------------------------------------

      rule build_rex_rr(rm_reg: RegisterInfo, r_reg: RegisterInfo, is_64bit: boolean) -> u8 {
        let w = if is_64bit { 1u8 } else { 0u8 }
        let r = if r_reg.is_extended { 1u8 } else { 0u8 }
        let b = if rm_reg.is_extended { 1u8 } else { 0u8 }

        if w == 0 && r == 0 && b == 0 {
          return 0  # No REX needed
        }
        return 0x40 | (w << 3) | (r << 2) | b
      }

      rule build_rex_r(reg: RegisterInfo, is_64bit: boolean) -> u8 {
        let w = if is_64bit { 1u8 } else { 0u8 }
        let b = if reg.is_extended { 1u8 } else { 0u8 }

        if w == 0 && b == 0 {
          return 0
        }
        return 0x40 | (w << 3) | b
      }

      rule build_rex_mem_reg(mem: MemoryOperand, reg: RegisterInfo, is_64bit: boolean) -> u8 {
        let w = if is_64bit { 1u8 } else { 0u8 }
        let r = if reg.is_extended { 1u8 } else { 0u8 }
        let x = if mem.index != "" && map_get(state.reg_extended, mem.index) { 1u8 } else { 0u8 }
        let b = if mem.base != "" && map_get(state.reg_extended, mem.base) { 1u8 } else { 0u8 }

        if w == 0 && r == 0 && x == 0 && b == 0 {
          return 0
        }
        return 0x40 | (w << 3) | (r << 2) | (x << 1) | b
      }

      # -------------------------------------------------------------------------
      # MODR/M AND IMMEDIATE HELPERS
      # -------------------------------------------------------------------------

      rule build_modrm(mod_field: u8, reg: u8, rm: u8) -> u8 {
        return (mod_field << 6) | ((reg & 0x7) << 3) | (rm & 0x7)
      }

      rule append_imm8(bytes: vec<u8>, val: i8) {
        vec_push(bytes, val as u8)
      }

      rule append_imm32(bytes: vec<u8>, val: i32) {
        vec_push(bytes, (val & 0xFF) as u8)
        vec_push(bytes, ((val >> 8) & 0xFF) as u8)
        vec_push(bytes, ((val >> 16) & 0xFF) as u8)
        vec_push(bytes, ((val >> 24) & 0xFF) as u8)
      }

      rule append_imm64(bytes: vec<u8>, val: i64) {
        vec_push(bytes, (val & 0xFF) as u8)
        vec_push(bytes, ((val >> 8) & 0xFF) as u8)
        vec_push(bytes, ((val >> 16) & 0xFF) as u8)
        vec_push(bytes, ((val >> 24) & 0xFF) as u8)
        vec_push(bytes, ((val >> 32) & 0xFF) as u8)
        vec_push(bytes, ((val >> 40) & 0xFF) as u8)
        vec_push(bytes, ((val >> 48) & 0xFF) as u8)
        vec_push(bytes, ((val >> 56) & 0xFF) as u8)
      }

      # -------------------------------------------------------------------------
      # UTILITY HELPERS
      # -------------------------------------------------------------------------

      rule estimate_instruction_size(mnemonic: string, operands: vec<Operand>) -> u32 {
        # Conservative estimate for instruction sizes
        match mnemonic {
          "" => 0  # Label-only pseudo-instruction
          "ret" | "nop" | "hlt" => 1
          "syscall" | "ud2" => 2
          "cqo" | "cdq" => 2
          "push" | "pop" => 2
          _ => 7  # Maximum typical instruction size (REX + opcode + modrm + sib + disp32)
        }
      }

      rule get_current_section_offset() -> u32 {
        match state.current_section {
          ".text" => vec_len(state.text_section.data)
          ".rodata" => vec_len(state.rodata_section.data)
          ".data" => vec_len(state.data_section.data)
          ".bss" => vec_len(state.bss_section.data)
          _ => 0
        }
      }

      rule should_be_global(label: string) -> boolean {
        # Key symbols that MUST be global for linking to work
        # Using starts_with for more reliable comparison
        if starts_with(label, "_start") { return true }
        if starts_with(label, "heap_ptr") { return true }
        # main exactly (not main_something)
        if label == "main" { return true }

        # Runtime variables that must be LOCAL to avoid conflicts with complete-builtins.o
        if starts_with(label, "global_") { return false }
        if starts_with(label, "num_agents") { return false }

        # Local labels start with .L or just .
        if starts_with(label, ".L") { return false }
        if starts_with(label, ".") { return false }

        # Everything else is local by default to avoid polluting symbol table
        return false
      }

      rule get_current_section_mut() -> Section {
        match state.current_section {
          ".text" => state.text_section
          ".rodata" => state.rodata_section
          ".data" => state.data_section
          ".bss" => state.bss_section
          _ => state.text_section
        }
      }

      rule get_section_by_name_mut(name: string) -> Section {
        match name {
          ".text" => state.text_section
          ".rodata" => state.rodata_section
          ".data" => state.data_section
          ".bss" => state.bss_section
          _ => state.text_section
        }
      }

      rule parse_number_value(s: string) -> i64 {
        if starts_with(s, "0x") || starts_with(s, "0X") {
          return parse_hex(string_slice(s, 2, string_len(s)))
        }
        return parse_i64(s)
      }

      rule is_numeric_string(s: string) -> boolean {
        if string_len(s) == 0 {
          return false
        }
        let first = char_at(s, 0)
        return first == '-' || first == '+' || (first >= '0' && first <= '9')
      }

      rule string_to_bytes(s: string) -> vec<u8> {
        let result: vec<u8> = vec_new()
        let i: u32 = 0
        let len: u32 = string_len(s)

        # Skip surrounding quotes if present
        let first_char: u8 = char_code_at(s, 0)
        if len >= 2 && (first_char == 34 || first_char == 39) {
          # 34 = '"', 39 = '\''
          i = 1
          len = len - 1
        }

        while i < len {
          let c: u8 = char_code_at(s, i)
          if c == 92 && i + 1 < len {
            # 92 = '\\'
            let next: u8 = char_code_at(s, i + 1)
            if next == 110 {
              # 'n' = newline
              vec_push(result, 10)
              i = i + 2
            } else if next == 114 {
              # 'r' = carriage return
              vec_push(result, 13)
              i = i + 2
            } else if next == 116 {
              # 't' = tab
              vec_push(result, 9)
              i = i + 2
            } else if next == 48 {
              # '0' = null
              vec_push(result, 0)
              i = i + 2
            } else if next == 92 {
              # '\\' = backslash
              vec_push(result, 92)
              i = i + 2
            } else if next == 34 {
              # '"' = double quote
              vec_push(result, 34)
              i = i + 2
            } else if next == 39 {
              # '\'' = single quote
              vec_push(result, 39)
              i = i + 2
            } else {
              vec_push(result, c)
              i = i + 1
            }
          } else {
            vec_push(result, c)
            i = i + 1
          }
        }
        return result
      }

      rule i64_to_le_bytes(val: i64) -> vec<u8> {
        let result: vec<u8> = vec_new()
        append_imm64(result, val)
        return result
      }
    }

