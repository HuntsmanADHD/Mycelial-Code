/**
 * Builtin Functions (x86-64 Assembly Implementation)
 *
 * Generates x86-64 assembly implementations of Mycelial builtin functions.
 * All functions follow System V AMD64 calling convention:
 * - Arguments: rdi, rsi, rdx, rcx, r8, r9
 * - Return: rax
 * - Callee-saved: rbx, r12-r15, rbp
 *
 * Categories:
 * - String Operations: string_len, string_concat, format
 * - I/O Operations: print, println
 * - Memory Management: heap_alloc, heap_free
 * - Vector Operations: vec_new, vec_push, vec_get, vec_len
 * - Utility: memcpy, memset
 *
 * @author Claude Sonnet 4.5
 * @date 2026-01-10
 */

class BuiltinFunctionsGenerator {
  constructor() {
    this.functions = [];
  }

  /**
   * Generate all builtin functions
   * @returns {string} Complete assembly code for all builtins
   */
  generateAll() {
    const sections = [];

    sections.push(this.generateHeader());
    sections.push(this.generateStringFunctions());
    sections.push(this.generateIOFunctions());
    sections.push(this.generateMemoryFunctions());
    sections.push(this.generateVectorFunctions());
    sections.push(this.generateMapFunctions());
    sections.push(this.generateUtilityFunctions());
    sections.push(this.generateTestHelpers());

    return sections.join('\n\n');
  }

  /**
   * Generate header
   */
  generateHeader() {
    return `# ================================================================
# Mycelial Builtin Functions (x86-64)
# System V AMD64 calling convention
# ================================================================`;
  }

  /**
   * Generate string operation functions
   */
  generateStringFunctions() {
    const lines = [];

    // len(str) -> length (alias for string_len)
    lines.push(`# ================================================================`);
    lines.push(`# builtin_len(str: *u8) -> u64`);
    lines.push(`# Returns the length of a null-terminated string`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# Returns: rax = length`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_len:`);
    lines.push(`    jmp builtin_string_len    # alias to string_len`);
    lines.push(``);

    // string_len(str) -> length
    lines.push(`# ================================================================`);
    lines.push(`# builtin_string_len(str: *u8) -> u64`);
    lines.push(`# Returns the length of a null-terminated string`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# Returns: rax = length`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_string_len:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12`);
    lines.push(``);
    lines.push(`    xor rax, rax              # length = 0`);
    lines.push(`    test rdi, rdi             # check for null`);
    lines.push(`    jz .strlen_done`);
    lines.push(`    mov r12, rdi              # save string pointer`);
    lines.push(``);
    lines.push(`.strlen_loop:`);
    lines.push(`    movb cl, [r12]            # load byte into cl`);
    lines.push(`    test cl, cl               # check if zero`);
    lines.push(`    jz .strlen_done`);
    lines.push(`    incq rax`);
    lines.push(`    incq r12`);
    lines.push(`    jmp .strlen_loop`);
    lines.push(``);
    lines.push(`.strlen_done:`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // compute(str) -> i64 (custom function for pipeline test)
    lines.push(`# ================================================================`);
    lines.push(`# builtin_compute(str: *u8) -> i64`);
    lines.push(`# Custom compute function for pipeline.mycelial test`);
    lines.push(`# Returns the length of the string as the "computed result"`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# Returns: rax = string length`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_compute:`);
    lines.push(`    # Just call string_len`);
    lines.push(`    jmp builtin_string_len`);
    lines.push(``);

    // format(fmt: *u8, ...) -> *u8 - String interpolation with {} placeholders
    lines.push(`# ================================================================`);
    lines.push(`# builtin_format(fmt: *u8, arg1, arg2, arg3, arg4, arg5) -> *u8`);
    lines.push(`# String interpolation with {} placeholders`);
    lines.push(`# Arguments: rdi = format string, rsi-r9 = up to 5 arguments`);
    lines.push(`# Returns: rax = formatted string`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_format:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push rbx`);
    lines.push(`    push r12`);
    lines.push(`    push r13`);
    lines.push(`    push r14`);
    lines.push(`    push r15`);
    lines.push(``);
    lines.push(`    # Save arguments at fixed rbp-relative offsets`);
    lines.push(`    mov r12, rdi              # r12 = format string`);
    lines.push(`    sub rsp, 48               # Reserve space for 5 args (40 bytes) + alignment`);
    lines.push(`    mov [rbp - 48], rsi       # arg1`);
    lines.push(`    mov [rbp - 56], rdx       # arg2`);
    lines.push(`    mov [rbp - 64], rcx       # arg3`);
    lines.push(`    mov [rbp - 72], r8        # arg4`);
    lines.push(`    mov [rbp - 80], r9        # arg5`);
    lines.push(``);
    lines.push(`    # Count {} placeholders and calculate max result size`);
    lines.push(`    mov rdi, r12`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    mov r13, rax              # r13 = format string length`);
    lines.push(`    imul rax, 4               # Estimate: 4x format string length`);
    lines.push(`    add rax, 256              # Add buffer for arg conversions`);
    lines.push(``);
    lines.push(`    # Allocate result buffer`);
    lines.push(`    mov rdi, rax`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    mov r14, rax              # r14 = result buffer`);
    lines.push(`    mov r15, rax              # r15 = result write pointer`);
    lines.push(``);
    lines.push(`    # Scan format string and substitute`);
    lines.push(`    xor rbx, rbx              # rbx = current arg index (0-4)`);
    lines.push(`    mov r13, r12              # r13 = format read pointer`);
    lines.push(``);
    lines.push(`.format_loop:`);
    lines.push(`    movb cl, [r13]            # Load next char`);
    lines.push(`    test cl, cl               # Check for null terminator`);
    lines.push(`    jz .format_done`);
    lines.push(``);
    lines.push(`    # Check if it's '{'`);
    lines.push(`    cmp cl, 123               # '{' = 123`);
    lines.push(`    jne .format_copy_char`);
    lines.push(``);
    lines.push(`    # Check next char for '}'`);
    lines.push(`    movb dl, [r13 + 1]`);
    lines.push(`    cmp dl, 125               # '}' = 125`);
    lines.push(`    jne .format_copy_char`);
    lines.push(``);
    lines.push(`    # Found {} placeholder - substitute with argument`);
    lines.push(`    cmp rbx, 5                # Check if we have more args`);
    lines.push(`    jge .format_skip_placeholder`);
    lines.push(``);
    lines.push(`    # Get argument from fixed rbp-relative offset`);
    lines.push(`    push rcx`);
    lines.push(`    lea rax, [rbp - 48]       # Base of saved arguments`);
    lines.push(`    mov rcx, rbx              # arg index (0-4)`);
    lines.push(`    shl rcx, 3                # rcx = index * 8`);
    lines.push(`    sub rax, rcx              # rax = address of argument`);
    lines.push(`    mov rax, [rax]            # Load argument value`);
    lines.push(`    pop rcx`);
    lines.push(``);
    lines.push(`    # Detect type: if value < 10000, treat as integer; else string`);
    lines.push(`    cmp rax, 10000`);
    lines.push(`    jl .format_convert_number`);
    lines.push(``);
    lines.push(`    # It's a string - copy it`);
    lines.push(`.format_use_string:`);
    lines.push(`    push rax                  # Save string pointer`);
    lines.push(`    mov rdi, rax`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    mov rcx, rax              # rcx = string length`);
    lines.push(`    pop rsi                   # rsi = string pointer`);
    lines.push(`    mov rdi, r15              # rdi = dest`);
    lines.push(`    rep movsb                 # Copy string`);
    lines.push(`    mov r15, rdi              # Update write pointer`);
    lines.push(`    jmp .format_arg_done`);
    lines.push(``);
    lines.push(`.format_convert_number:`);
    lines.push(`    # Convert integer to string`);
    lines.push(`    mov rdi, rax              # Number to convert`);
    lines.push(`    call builtin_i64_to_string`);
    lines.push(`    # rax now points to string representation`);
    lines.push(`    jmp .format_use_string`);
    lines.push(``);
    lines.push(`.format_arg_done:`);
    lines.push(`    inc rbx                   # Move to next argument`);
    lines.push(`    add r13, 2                # Skip over {}`);
    lines.push(`    jmp .format_loop`);
    lines.push(``);
    lines.push(`.format_skip_placeholder:`);
    lines.push(`    # No more arguments - skip the {}`);
    lines.push(`    add r13, 2`);
    lines.push(`    jmp .format_loop`);
    lines.push(``);
    lines.push(`.format_copy_char:`);
    lines.push(`    # Regular character - copy it`);
    lines.push(`    movb [r15], cl`);
    lines.push(`    inc r15`);
    lines.push(`    inc r13`);
    lines.push(`    jmp .format_loop`);
    lines.push(``);
    lines.push(`.format_done:`);
    lines.push(`    # Null-terminate result`);
    lines.push(`    movb [r15], 0`);
    lines.push(`    mov rax, r14              # Return result buffer`);
    lines.push(``);
    lines.push(`    # Clean up stack`);
    lines.push(`    add rsp, 48               # Clean up reserved argument space`);
    lines.push(``);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbx`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // char_at(str, index) -> character string
    lines.push(`# ================================================================`);
    lines.push(`# builtin_char_at(str: *u8, index: u64) -> *u8`);
    lines.push(`# Returns a single-character string at the given index`);
    lines.push(`# Arguments: rdi = str, rsi = index`);
    lines.push(`# Returns: rax = pointer to single-char string (or empty string if out of bounds)`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_char_at:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12`);
    lines.push(`    push r13`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # save string pointer`);
    lines.push(`    mov r13, rsi              # save index`);
    lines.push(``);
    lines.push(`    # Check if string is null`);
    lines.push(`    test r12, r12`);
    lines.push(`    jz .char_at_empty`);
    lines.push(``);
    lines.push(`    # Get string length`);
    lines.push(`    mov rdi, r12`);
    lines.push(`    call builtin_string_len`);
    lines.push(``);
    lines.push(`    # Check if index is out of bounds`);
    lines.push(`    cmp r13, rax`);
    lines.push(`    jge .char_at_empty`);
    lines.push(``);
    lines.push(`    # Allocate 2 bytes for result (1 char + null terminator)`);
    lines.push(`    mov rdi, 2`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    mov r14, rax              # save result pointer`);
    lines.push(``);
    lines.push(`    # Copy character`);
    lines.push(`    movzx rdx, byte ptr [r12 + r13]    # load character`);
    lines.push(`    mov byte ptr [r14], dl              # store character`);
    lines.push(`    mov byte ptr [r14 + 1], 0           # null terminator`);
    lines.push(``);
    lines.push(`    mov rax, r14              # return result`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.char_at_empty:`);
    lines.push(`    # Return empty string`);
    lines.push(`    mov rdi, 1`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    mov byte ptr [rax], 0     # null terminator`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // string_char_at is an alias for char_at
    lines.push(`builtin_string_char_at:`);
    lines.push(`    jmp builtin_char_at       # alias`);
    lines.push(``);

    // string_concat(str1, str2) -> new_string
    lines.push(`# ================================================================`);
    lines.push(`# builtin_string_concat(str1: *u8, str2: *u8) -> *u8`);
    lines.push(`# Concatenates two strings and returns a new string`);
    lines.push(`# Arguments: rdi = str1, rsi = str2`);
    lines.push(`# Returns: rax = new string pointer`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_string_concat:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12`);
    lines.push(`    push r13`);
    lines.push(`    push r14`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # save str1`);
    lines.push(`    mov r13, rsi              # save str2`);
    lines.push(``);
    lines.push(`    # Get length of str1`);
    lines.push(`    mov rdi, r12`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    mov r14, rax              # len1 in r14`);
    lines.push(``);
    lines.push(`    # Get length of str2`);
    lines.push(`    mov rdi, r13`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    add r14, rax              # total = len1 + len2`);
    lines.push(`    inc r14                   # +1 for null terminator`);
    lines.push(``);
    lines.push(`    # Allocate memory`);
    lines.push(`    mov rdi, r14`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    push rax                  # save result pointer`);
    lines.push(``);
    lines.push(`    # Copy str1`);
    lines.push(`    mov rdi, rax              # dest`);
    lines.push(`    mov rsi, r12              # src = str1`);
    lines.push(`    call builtin_strcpy`);
    lines.push(``);
    lines.push(`    # Copy str2 (append)`);
    lines.push(`    pop rax                   # restore result`);
    lines.push(`    push rax`);
    lines.push(`    mov rdi, rax`);
    lines.push(`    mov rsi, r13              # src = str2`);
    lines.push(`    call builtin_strcat`);
    lines.push(``);
    lines.push(`    pop rax                   # return result`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // Helper: i64_to_string
    lines.push(`# ================================================================`);
    lines.push(`# builtin_i64_to_string(value: i64) -> *u8`);
    lines.push(`# Convert signed 64-bit integer to string`);
    lines.push(`# Arguments: rdi = value`);
    lines.push(`# Returns: rax = pointer to string (heap allocated)`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_i64_to_string:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push rbx                  # callee-saved register`);
    lines.push(`    push r12                  # original value`);
    lines.push(`    push r13                  # is_negative flag`);
    lines.push(`    push r14                  # digit count`);
    lines.push(`    sub rsp, 32               # temp buffer`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # save value`);
    lines.push(`    xor r13, r13              # is_negative = 0`);
    lines.push(`    xor r14, r14              # digit_count = 0`);
    lines.push(``);
    lines.push(`    # Check if negative`);
    lines.push(`    test rdi, rdi`);
    lines.push(`    jns .i64_positive`);
    lines.push(`    mov r13, 1                # is_negative = 1`);
    lines.push(`    neg rdi                   # make positive`);
    lines.push(``);
    lines.push(`.i64_positive:`);
    lines.push(`    # Handle zero case`);
    lines.push(`    test rdi, rdi`);
    lines.push(`    jnz .i64_convert_loop`);
    lines.push(`    mov BYTE PTR [rbp - 64], '0'  # temp buffer`);
    lines.push(`    mov r14, 1`);
    lines.push(`    jmp .i64_build_result`);
    lines.push(``);
    lines.push(`    # Convert digits (least significant first)`);
    lines.push(`.i64_convert_loop:`);
    lines.push(`    test rdi, rdi`);
    lines.push(`    jz .i64_build_result`);
    lines.push(``);
    lines.push(`    xor rdx, rdx              # clear for division`);
    lines.push(`    mov rax, rdi`);
    lines.push(`    mov rcx, 10`);
    lines.push(`    div rcx                   # rax = quotient, rdx = remainder`);
    lines.push(`    mov rdi, rax              # value = quotient`);
    lines.push(``);
    lines.push(`    add dl, '0'               # convert digit to ASCII`);
    lines.push(`    lea rax, [rbp - 64]       # temp buffer (after saved registers)`);
    lines.push(`    add rax, r14`);
    lines.push(`    mov [rax], dl             # store digit`);
    lines.push(`    inc r14                   # digit_count++`);
    lines.push(`    jmp .i64_convert_loop`);
    lines.push(``);
    lines.push(`.i64_build_result:`);
    lines.push(`    # Allocate heap for result`);
    lines.push(`    mov rdi, r14`);
    lines.push(`    add rdi, r13              # length = digit_count + is_negative`);
    lines.push(`    inc rdi                   # +1 for null terminator`);
    lines.push(`    push r14                  # save digit_count`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    pop r14                   # restore digit_count`);
    lines.push(`    push rax                  # save result pointer`);
    lines.push(``);
    lines.push(`    # Copy to result (with reversal)`);
    lines.push(`    mov rdi, rax              # dest = result`);
    lines.push(``);
    lines.push(`    # Add '-' if negative`);
    lines.push(`    test r13, r13`);
    lines.push(`    jz .i64_copy_digits`);
    lines.push(`    mov BYTE PTR [rdi], '-'`);
    lines.push(`    inc rdi`);
    lines.push(``);
    lines.push(`.i64_copy_digits:`);
    lines.push(`    # Copy digits in reverse order`);
    lines.push(`    xor rcx, rcx              # i = 0`);
    lines.push(`.i64_copy_loop:`);
    lines.push(`    cmp rcx, r14`);
    lines.push(`    jge .i64_copy_done`);
    lines.push(``);
    lines.push(`    # Get digit from temp buffer (reversed)`);
    lines.push(`    mov rax, r14`);
    lines.push(`    dec rax`);
    lines.push(`    sub rax, rcx              # index = digit_count - 1 - i`);
    lines.push(`    lea rbx, [rbp - 64]       # temp buffer`);
    lines.push(`    add rbx, rax`);
    lines.push(`    mov al, [rbx]`);
    lines.push(``);
    lines.push(`    mov [rdi], al             # store digit`);
    lines.push(`    inc rdi`);
    lines.push(`    inc rcx`);
    lines.push(`    jmp .i64_copy_loop`);
    lines.push(``);
    lines.push(`.i64_copy_done:`);
    lines.push(`    mov BYTE PTR [rdi], 0     # null terminator`);
    lines.push(`    pop rax                   # return result pointer`);
    lines.push(``);
    lines.push(`    add rsp, 32               # deallocate temp buffer`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbx`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // Helper: strcpy
    lines.push(`# Helper: strcpy(dest, src)`);
    lines.push(`builtin_strcpy:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`.strcpy_loop:`);
    lines.push(`    mov al, [rsi]             # load byte from src`);
    lines.push(`    mov [rdi], al             # store to dest`);
    lines.push(`    test al, al               # check for null`);
    lines.push(`    jz .strcpy_done`);
    lines.push(`    inc rsi`);
    lines.push(`    inc rdi`);
    lines.push(`    jmp .strcpy_loop`);
    lines.push(``);
    lines.push(`.strcpy_done:`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // Helper: strcat
    lines.push(`# Helper: strcat(dest, src)`);
    lines.push(`builtin_strcat:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Find end of dest`);
    lines.push(`.strcat_find_end:`);
    lines.push(`    cmp byte ptr [rdi], 0`);
    lines.push(`    je .strcat_copy`);
    lines.push(`    inc rdi`);
    lines.push(`    jmp .strcat_find_end`);
    lines.push(``);
    lines.push(`.strcat_copy:`);
    lines.push(`    # Copy src to end of dest`);
    lines.push(`    mov al, [rsi]`);
    lines.push(`    mov [rdi], al`);
    lines.push(`    test al, al`);
    lines.push(`    jz .strcat_done`);
    lines.push(`    inc rsi`);
    lines.push(`    inc rdi`);
    lines.push(`    jmp .strcat_copy`);
    lines.push(``);
    lines.push(`.strcat_done:`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // string_contains(haystack, needle) -> bool
    lines.push(`# ================================================================`);
    lines.push(`# builtin_string_contains(haystack: *u8, needle: *u8) -> bool`);
    lines.push(`# Checks if haystack contains needle as a substring`);
    lines.push(`# Arguments: rdi = haystack pointer, rsi = needle pointer`);
    lines.push(`# Returns: rax = 1 if found, 0 if not found`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_string_contains:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12              # save haystack`);
    lines.push(`    push r13              # save needle`);
    lines.push(`    push r14              # haystack position`);
    lines.push(`    push r15              # needle position`);
    lines.push(``);
    lines.push(`    mov r12, rdi          # haystack`);
    lines.push(`    mov r13, rsi          # needle`);
    lines.push(``);
    lines.push(`    # Check if needle is empty - empty string is always found`);
    lines.push(`    cmp byte ptr [r13], 0`);
    lines.push(`    je .contains_found`);
    lines.push(``);
    lines.push(`.contains_outer_loop:`);
    lines.push(`    # Check if we've reached end of haystack`);
    lines.push(`    cmp byte ptr [r12], 0`);
    lines.push(`    je .contains_not_found`);
    lines.push(``);
    lines.push(`    # Try to match needle starting at current position`);
    lines.push(`    mov r14, r12          # haystack position`);
    lines.push(`    mov r15, r13          # needle position`);
    lines.push(``);
    lines.push(`.contains_inner_loop:`);
    lines.push(`    # Check if we've matched entire needle`);
    lines.push(`    cmp byte ptr [r15], 0`);
    lines.push(`    je .contains_found`);
    lines.push(``);
    lines.push(`    # Check if haystack ended`);
    lines.push(`    cmp byte ptr [r14], 0`);
    lines.push(`    je .contains_not_found`);
    lines.push(``);
    lines.push(`    # Compare characters`);
    lines.push(`    mov al, [r14]`);
    lines.push(`    mov bl, [r15]`);
    lines.push(`    cmp al, bl`);
    lines.push(`    jne .contains_try_next`);
    lines.push(``);
    lines.push(`    # Characters match, continue to next`);
    lines.push(`    inc r14`);
    lines.push(`    inc r15`);
    lines.push(`    jmp .contains_inner_loop`);
    lines.push(``);
    lines.push(`.contains_try_next:`);
    lines.push(`    # Mismatch - try starting from next position in haystack`);
    lines.push(`    inc r12`);
    lines.push(`    jmp .contains_outer_loop`);
    lines.push(``);
    lines.push(`.contains_found:`);
    lines.push(`    mov rax, 1            # return true`);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.contains_not_found:`);
    lines.push(`    xor rax, rax          # return false`);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);

    // Add string equality function
    lines.push(``);
    lines.push(`# ================================================================`);
    lines.push(`# builtin_string_eq(str1: *u8, str2: *u8) -> bool`);
    lines.push(`# Checks if two strings are exactly equal`);
    lines.push(`# Arguments: rdi = string1 pointer, rsi = string2 pointer`);
    lines.push(`# Returns: rax = 1 if equal, 0 if not equal`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_string_eq:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    mov r10, rdi          # str1`);
    lines.push(`    mov r11, rsi          # str2`);
    lines.push(``);
    lines.push(`.eq_loop:`);
    lines.push(`    # Load characters from both strings`);
    lines.push(`    mov al, [r10]`);
    lines.push(`    mov bl, [r11]`);
    lines.push(``);
    lines.push(`    # Compare characters`);
    lines.push(`    cmp al, bl`);
    lines.push(`    jne .eq_not_equal`);
    lines.push(``);
    lines.push(`    # Check if we've reached the end (both strings ended simultaneously)`);
    lines.push(`    test al, al`);
    lines.push(`    jz .eq_equal`);
    lines.push(``);
    lines.push(`    # Move to next character`);
    lines.push(`    inc r10`);
    lines.push(`    inc r11`);
    lines.push(`    jmp .eq_loop`);
    lines.push(``);
    lines.push(`.eq_equal:`);
    lines.push(`    mov rax, 1            # return true`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.eq_not_equal:`);
    lines.push(`    xor rax, rax          # return false`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);

    return lines.join('\n');
  }

  /**
   * Generate I/O functions
   */
  generateIOFunctions() {
    const lines = [];

    // print(str)
    lines.push(`# ================================================================`);
    lines.push(`# builtin_print(str: *u8)`);
    lines.push(`# Prints a string to stdout (without newline)`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_print:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push rdi                  # save string pointer`);
    lines.push(``);
    lines.push(`    # Get string length`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    mov rdx, rax              # length for syscall`);
    lines.push(``);
    lines.push(`    # Write syscall`);
    lines.push(`    mov rax, 1                # syscall: write`);
    lines.push(`    mov rdi, 1                # fd: stdout`);
    lines.push(`    pop rsi                   # string pointer`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // println(str)
    lines.push(`# ================================================================`);
    lines.push(`# builtin_println(str: *u8)`);
    lines.push(`# Prints a string to stdout with newline`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_println:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Print the string`);
    lines.push(`    call builtin_print`);
    lines.push(``);
    lines.push(`    # Print newline`);
    lines.push(`    mov rax, 1                # syscall: write`);
    lines.push(`    mov rdi, 1                # fd: stdout`);
    lines.push(`    lea rsi, [newline_str]    # newline`);
    lines.push(`    mov rdx, 1                # length = 1`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // print_i64(num)
    lines.push(`# ================================================================`);
    lines.push(`# builtin_print_i64(num: i64)`);
    lines.push(`# Prints a signed 64-bit integer to stdout`);
    lines.push(`# Arguments: rdi = number to print`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_print_i64:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    sub rsp, 32               # buffer for string conversion`);
    lines.push(`    push r12`);
    lines.push(`    push r13`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # save number`);
    lines.push(`    lea r13, [rbp - 30]       # buffer pointer`);
    lines.push(`    mov byte ptr [rbp - 1], 0 # null terminator`);
    lines.push(``);
    lines.push(`    # Check if negative`);
    lines.push(`    test r12, r12`);
    lines.push(`    jns .print_i64_positive`);
    lines.push(``);
    lines.push(`    # Handle negative: print '-' and negate`);
    lines.push(`    mov rax, 1                # syscall: write`);
    lines.push(`    mov rdi, 1                # fd: stdout`);
    lines.push(`    lea rsi, [minus_sign]`);
    lines.push(`    mov rdx, 1                # length = 1`);
    lines.push(`    syscall`);
    lines.push(`    neg r12                   # make positive`);
    lines.push(``);
    lines.push(`.print_i64_positive:`);
    lines.push(`    # Convert to string (reverse order)`);
    lines.push(`    mov rax, r12`);
    lines.push(`    lea rdi, [rbp - 2]        # start at end of buffer`);
    lines.push(``);
    lines.push(`.print_i64_convert_loop:`);
    lines.push(`    xor rdx, rdx`);
    lines.push(`    mov rcx, 10`);
    lines.push(`    div rcx                   # rdx = rax % 10, rax = rax / 10`);
    lines.push(`    add dl, 48                # convert to ASCII`);
    lines.push(`    mov [rdi], dl`);
    lines.push(`    dec rdi`);
    lines.push(`    test rax, rax`);
    lines.push(`    jnz .print_i64_convert_loop`);
    lines.push(``);
    lines.push(`    # Print the number`);
    lines.push(`    inc rdi                   # move to first digit`);
    lines.push(`    lea rsi, [rbp - 2]`);
    lines.push(`    sub rsi, rdi              # calculate length`);
    lines.push(`    inc rsi                   # length`);
    lines.push(`    mov rdx, rsi              # length`);
    lines.push(`    mov rax, 1                # syscall: write`);
    lines.push(`    mov rsi, rdi              # buffer`);
    lines.push(`    mov rdi, 1                # fd: stdout`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    mov rsp, rbp`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // read_file(path) -> string
    lines.push(`# ================================================================`);
    lines.push(`# builtin_read_file(path: *u8) -> *u8`);
    lines.push(`# Reads entire file contents and returns as string`);
    lines.push(`# Arguments: rdi = file path (null-terminated string)`);
    lines.push(`# Returns: rax = file contents as string (or empty string on error)`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_read_file:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12                  # file descriptor`);
    lines.push(`    push r13                  # file size`);
    lines.push(`    push r14                  # buffer pointer`);
    lines.push(`    sub rsp, 144              # stat buffer (144 bytes for struct stat)`);
    lines.push(``);
    lines.push(`    # Open file (syscall 2: open)`);
    lines.push(`    # open(path, O_RDONLY=0, 0)`);
    lines.push(`    mov rax, 2                # syscall: open`);
    lines.push(`    # rdi already contains path`);
    lines.push(`    xor rsi, rsi              # flags: O_RDONLY = 0`);
    lines.push(`    xor rdx, rdx              # mode: 0`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Check for error`);
    lines.push(`    test rax, rax`);
    lines.push(`    js .read_file_error       # if fd < 0, error`);
    lines.push(`    mov r12, rax              # save fd`);
    lines.push(``);
    lines.push(`    # Get file size using fstat (syscall 5)`);
    lines.push(`    mov rax, 5                # syscall: fstat`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    lea rsi, [rbp - 160]      # stat buffer`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Check for error`);
    lines.push(`    test rax, rax`);
    lines.push(`    js .read_file_close_error`);
    lines.push(``);
    lines.push(`    # Get file size from stat buffer (st_size at offset 48)`);
    lines.push(`    mov r13, [rbp - 112]      # st_size at offset 48 from stat buffer start`);
    lines.push(``);
    lines.push(`    # Allocate buffer for file contents + null terminator`);
    lines.push(`    mov rdi, r13`);
    lines.push(`    inc rdi                   # +1 for null terminator`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    mov r14, rax              # save buffer pointer`);
    lines.push(``);
    lines.push(`    # Read file contents (syscall 0: read)`);
    lines.push(`    mov rax, 0                # syscall: read`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    mov rsi, r14              # buffer`);
    lines.push(`    mov rdx, r13              # count = file_size`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Check for error`);
    lines.push(`    test rax, rax`);
    lines.push(`    js .read_file_close_error`);
    lines.push(``);
    lines.push(`    # Add null terminator`);
    lines.push(`    mov byte ptr [r14 + r13], 0`);
    lines.push(``);
    lines.push(`    # Close file (syscall 3: close)`);
    lines.push(`    mov rax, 3                # syscall: close`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Return buffer`);
    lines.push(`    mov rax, r14`);
    lines.push(`    add rsp, 144`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.read_file_close_error:`);
    lines.push(`    # Close file before returning error`);
    lines.push(`    mov rax, 3                # syscall: close`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`.read_file_error:`);
    lines.push(`    # Return empty string on error`);
    lines.push(`    mov rdi, 1`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    mov byte ptr [rax], 0     # null terminator`);
    lines.push(`    add rsp, 144`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // write_file(path, contents) -> success
    lines.push(`# ================================================================`);
    lines.push(`# builtin_write_file(path: *u8, contents: *u8) -> i64`);
    lines.push(`# Writes string contents to file (overwrites if exists)`);
    lines.push(`# Arguments: rdi = file path, rsi = contents string`);
    lines.push(`# Returns: rax = 1 on success, 0 on error`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_write_file:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12                  # file descriptor`);
    lines.push(`    push r13                  # contents pointer`);
    lines.push(`    push r14                  # contents length`);
    lines.push(`    push r15                  # path pointer`);
    lines.push(``);
    lines.push(`    mov r15, rdi              # save path pointer`);
    lines.push(`    mov r13, rsi              # save contents pointer`);
    lines.push(``);
    lines.push(`    # Get contents length`);
    lines.push(`    mov rdi, rsi`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    mov r14, rax              # save length`);
    lines.push(``);
    lines.push(`    # Open/create file (syscall 2: open)`);
    lines.push(`    # open(path, O_WRONLY|O_CREAT|O_TRUNC=0x241, 0644)`);
    lines.push(`    mov rax, 2                # syscall: open`);
    lines.push(`    mov rdi, r15              # path pointer`);
    lines.push(`    mov rsi, 0x241            # flags: O_WRONLY|O_CREAT|O_TRUNC`);
    lines.push(`    mov rdx, 0x1A4            # mode: 0644 octal = 0x1A4`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Check for error`);
    lines.push(`    test rax, rax`);
    lines.push(`    js .write_file_error      # if fd < 0, error`);
    lines.push(`    mov r12, rax              # save fd`);
    lines.push(``);
    lines.push(`    # Write contents (syscall 1: write)`);
    lines.push(`    mov rax, 1                # syscall: write`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    mov rsi, r13              # buffer = contents`);
    lines.push(`    mov rdx, r14              # count = length`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Check for error (negative return value)`);
    lines.push(`    test rax, rax`);
    lines.push(`    js .write_file_close_error`);
    lines.push(``);
    lines.push(`    # Close file (syscall 3: close)`);
    lines.push(`    mov rax, 3                # syscall: close`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Return success (1)`);
    lines.push(`    mov rax, 1`);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.write_file_close_error:`);
    lines.push(`    # Close file before returning error`);
    lines.push(`    mov rax, 3                # syscall: close`);
    lines.push(`    mov rdi, r12              # fd`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`.write_file_error:`);
    lines.push(`    # Return error (0)`);
    lines.push(`    xor rax, rax`);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);

    return lines.join('\n');
  }

  /**
   * Generate memory management functions
   */
  generateMemoryFunctions() {
    const lines = [];

    // Simple bump allocator
    lines.push(`# ================================================================`);
    lines.push(`# builtin_heap_alloc(size: u64) -> *u8`);
    lines.push(`# Simple bump allocator`);
    lines.push(`# Arguments: rdi = size`);
    lines.push(`# Returns: rax = pointer to allocated memory`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_heap_alloc:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Get current heap pointer`);
    lines.push(`    mov rax, [heap_ptr]`);
    lines.push(``);
    lines.push(`    # Advance heap pointer`);
    lines.push(`    add rdi, rax`);
    lines.push(`    mov [heap_ptr], rdi`);
    lines.push(``);
    lines.push(`    # Check if we exceeded heap limit`);
    lines.push(`    mov rsi, [heap_end]`);
    lines.push(`    cmp rdi, rsi`);
    lines.push(`    jg .heap_overflow`);
    lines.push(``);
    lines.push(`    # Return allocated pointer`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.heap_overflow:`);
    lines.push(`    # Out of memory - exit with error`);
    lines.push(`    mov rdi, 1                # exit code 1`);
    lines.push(`    mov rax, 60               # syscall: exit`);
    lines.push(`    syscall`);
    lines.push(``);

    // heap_free (no-op for bump allocator)
    lines.push(`# builtin_heap_free(ptr: *u8)`);
    lines.push(`# No-op for bump allocator`);
    lines.push(`builtin_heap_free:`);
    lines.push(`    ret`);

    return lines.join('\n');
  }

  /**
   * Generate vector operation functions
   */
  generateVectorFunctions() {
    const lines = [];

    // vec_new() -> vec
    lines.push(`# ================================================================`);
    lines.push(`# builtin_vec_new() -> *vec`);
    lines.push(`# Creates a new vector (ptr, len, cap)`);
    lines.push(`# Returns: rax = vector struct pointer`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_vec_new:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Allocate vector struct (24 bytes)`);
    lines.push(`    mov rdi, 24`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(``);
    lines.push(`    # Initialize: ptr=0, len=0, cap=0`);
    lines.push(`    xor rdx, rdx`);
    lines.push(`    mov qword ptr [rax + 0], rdx    # ptr`);
    lines.push(`    mov qword ptr [rax + 8], rdx    # len`);
    lines.push(`    mov qword ptr [rax + 16], rdx   # cap`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // vec_len(vec) -> length
    lines.push(`# builtin_vec_len(vec: *vec) -> u64`);
    lines.push(`builtin_vec_len:`);
    lines.push(`    mov rax, [rdi + 8]        # return len field`);
    lines.push(`    ret`);
    lines.push(``);

    // vec_push(vec, item)
    lines.push(`# builtin_vec_push(vec: *vec, item: u64)`);
    lines.push(`# Arguments: rdi = vec pointer, rsi = item to push`);
    lines.push(`builtin_vec_push:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12              # save vec pointer`);
    lines.push(`    push r13              # save item`);
    lines.push(``);
    lines.push(`    mov r12, rdi          # save vec pointer`);
    lines.push(`    mov r13, rsi          # save item`);
    lines.push(``);
    lines.push(`    # Load len and cap`);
    lines.push(`    mov rax, [r12 + 8]    # len`);
    lines.push(`    mov rdx, [r12 + 16]   # cap`);
    lines.push(``);
    lines.push(`    # Check if we need to grow`);
    lines.push(`    cmp rax, rdx`);
    lines.push(`    jl .vec_push_no_grow`);
    lines.push(``);
    lines.push(`    # Need to grow: allocate new capacity (cap * 2, or 8 if cap==0)`);
    lines.push(`    test rdx, rdx`);
    lines.push(`    jz .vec_push_init_cap`);
    lines.push(`    shl rdx, 1            # new_cap = cap * 2`);
    lines.push(`    jmp .vec_push_alloc`);
    lines.push(``);
    lines.push(`.vec_push_init_cap:`);
    lines.push(`    mov rdx, 8            # initial capacity = 8`);
    lines.push(``);
    lines.push(`.vec_push_alloc:`);
    lines.push(`    # Allocate new array (new_cap * 8 bytes)`);
    lines.push(`    push rdx              # save new_cap`);
    lines.push(`    shl rdx, 3            # new_cap * 8`);
    lines.push(`    mov rdi, rdx`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    pop rdx               # restore new_cap`);
    lines.push(`    mov r14, rax          # save new_ptr`);
    lines.push(``);
    lines.push(`    # Copy old data to new array`);
    lines.push(`    mov rcx, [r12 + 8]    # len`);
    lines.push(`    test rcx, rcx`);
    lines.push(`    jz .vec_push_no_copy`);
    lines.push(`    mov rsi, [r12 + 0]    # old ptr`);
    lines.push(`    mov rdi, r14          # new ptr`);
    lines.push(`.vec_push_copy_loop:`);
    lines.push(`    mov rax, [rsi]`);
    lines.push(`    mov [rdi], rax`);
    lines.push(`    add rsi, 8`);
    lines.push(`    add rdi, 8`);
    lines.push(`    dec rcx`);
    lines.push(`    jnz .vec_push_copy_loop`);
    lines.push(``);
    lines.push(`.vec_push_no_copy:`);
    lines.push(`    # Update vector struct`);
    lines.push(`    mov [r12 + 0], r14    # ptr = new_ptr`);
    lines.push(`    mov [r12 + 16], rdx   # cap = new_cap`);
    lines.push(``);
    lines.push(`.vec_push_no_grow:`);
    lines.push(`    # Add item at end`);
    lines.push(`    mov rax, [r12 + 8]    # len`);
    lines.push(`    mov rdx, [r12 + 0]    # ptr`);
    lines.push(`    mov [rdx + rax * 8], r13  # ptr[len] = item`);
    lines.push(``);
    lines.push(`    # Increment len`);
    lines.push(`    inc rax`);
    lines.push(`    mov [r12 + 8], rax    # len++`);
    lines.push(``);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // vec_get(vec, index) -> item
    lines.push(`# builtin_vec_get(vec: *vec, index: u64) -> u64`);
    lines.push(`builtin_vec_get:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Check bounds`);
    lines.push(`    cmp rsi, [rdi + 8]        # index < len?`);
    lines.push(`    jge .vec_get_bounds`);
    lines.push(``);
    lines.push(`    # Get item: ptr[index]`);
    lines.push(`    mov rax, [rdi + 0]        # ptr`);
    lines.push(`    mov rax, [rax + rsi * 8]  # ptr[index]`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.vec_get_bounds:`);
    lines.push(`    # Out of bounds - return 0`);
    lines.push(`    xor rax, rax`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // vec_set(vec, index, value)
    lines.push(`# builtin_vec_set(vec: *vec, index: u64, value: u64)`);
    lines.push(`# Arguments: rdi = vec pointer, rsi = index, rdx = value`);
    lines.push(`builtin_vec_set:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Check bounds`);
    lines.push(`    cmp rsi, [rdi + 8]        # index < len?`);
    lines.push(`    jge .vec_set_bounds`);
    lines.push(``);
    lines.push(`    # Set item: ptr[index] = value`);
    lines.push(`    mov rax, [rdi + 0]        # ptr`);
    lines.push(`    mov [rax + rsi * 8], rdx  # ptr[index] = value`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.vec_set_bounds:`);
    lines.push(`    # Out of bounds - do nothing`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // vec_slice(vec, start, end) -> new_vec
    lines.push(`# builtin_vec_slice(vec: *vec, start: u64, end: u64) -> *vec`);
    lines.push(`# Arguments: rdi = vec pointer, rsi = start, rdx = end`);
    lines.push(`# Returns: rax = new vector containing elements [start..end)`);
    lines.push(`builtin_vec_slice:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12              # save vec pointer`);
    lines.push(`    push r13              # save start`);
    lines.push(`    push r14              # save end`);
    lines.push(``);
    lines.push(`    mov r12, rdi          # save vec pointer`);
    lines.push(`    mov r13, rsi          # save start`);
    lines.push(`    mov r14, rdx          # save end`);
    lines.push(``);
    lines.push(`    # Validate bounds: start <= end <= len`);
    lines.push(`    mov rcx, [r12 + 8]    # len`);
    lines.push(`    cmp r14, rcx          # end <= len?`);
    lines.push(`    jg .vec_slice_clamp_end`);
    lines.push(`    jmp .vec_slice_bounds_ok`);
    lines.push(``);
    lines.push(`.vec_slice_clamp_end:`);
    lines.push(`    mov r14, rcx          # clamp end to len`);
    lines.push(``);
    lines.push(`.vec_slice_bounds_ok:`);
    lines.push(`    cmp r13, r14          # start <= end?`);
    lines.push(`    jg .vec_slice_empty`);
    lines.push(``);
    lines.push(`    # Calculate slice length`);
    lines.push(`    mov r15, r14`);
    lines.push(`    sub r15, r13          # length = end - start`);
    lines.push(``);
    lines.push(`    # Create new vector`);
    lines.push(`    call builtin_vec_new`);
    lines.push(`    push rax              # save new vec`);
    lines.push(``);
    lines.push(`    # Allocate array for new vector`);
    lines.push(`    mov rdi, r15`);
    lines.push(`    shl rdi, 3            # length * 8`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    pop r8                # restore new vec`);
    lines.push(`    mov [r8 + 0], rax     # set ptr`);
    lines.push(`    mov [r8 + 8], r15     # set len`);
    lines.push(`    mov [r8 + 16], r15    # set cap = len`);
    lines.push(``);
    lines.push(`    # Copy elements from source[start..end) to new vector`);
    lines.push(`    test r15, r15         # length == 0?`);
    lines.push(`    jz .vec_slice_done`);
    lines.push(``);
    lines.push(`    mov rsi, [r12 + 0]    # source ptr`);
    lines.push(`    lea rsi, [rsi + r13 * 8]  # source ptr + start offset`);
    lines.push(`    mov rdi, rax          # dest ptr`);
    lines.push(`    mov rcx, r15          # count`);
    lines.push(``);
    lines.push(`.vec_slice_copy_loop:`);
    lines.push(`    mov r9, [rsi]`);
    lines.push(`    mov [rdi], r9`);
    lines.push(`    add rsi, 8`);
    lines.push(`    add rdi, 8`);
    lines.push(`    dec rcx`);
    lines.push(`    jnz .vec_slice_copy_loop`);
    lines.push(``);
    lines.push(`.vec_slice_done:`);
    lines.push(`    mov rax, r8           # return new vec`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.vec_slice_empty:`);
    lines.push(`    # Return empty vector`);
    lines.push(`    call builtin_vec_new`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // vec_clear(vec)
    lines.push(`# ================================================================`);
    lines.push(`# builtin_vec_clear(vec: *vec)`);
    lines.push(`# Clears all elements from a vector, setting length to 0`);
    lines.push(`# Does not free memory, just resets length`);
    lines.push(`# Arguments: rdi = vector pointer`);
    lines.push(`# Returns: nothing`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_vec_clear:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Set length to 0`);
    lines.push(`    xor rax, rax          # rax = 0`);
    lines.push(`    mov [rdi + 8], rax    # vec.len = 0`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);

    return lines.join('\n');
  }

  /**
   * Generate map operation functions
   * Map structure: { entries: *entry, len: u64, cap: u64 }
   * Entry structure: { key: u64, value: u64 } (16 bytes)
   */
  generateMapFunctions() {
    const lines = [];

    // map_new() -> map
    lines.push(`# ================================================================`);
    lines.push(`# builtin_map_new() -> *map`);
    lines.push(`# Creates a new map (entries, len, cap)`);
    lines.push(`# Returns: rax = map struct pointer`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_map_new:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Allocate map struct (24 bytes)`);
    lines.push(`    mov rdi, 24`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(``);
    lines.push(`    # Initialize: entries=0, len=0, cap=0`);
    lines.push(`    xor rdx, rdx`);
    lines.push(`    mov qword ptr [rax + 0], rdx    # entries`);
    lines.push(`    mov qword ptr [rax + 8], rdx    # len`);
    lines.push(`    mov qword ptr [rax + 16], rdx   # cap`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // map_set(map, key, value)
    lines.push(`# builtin_map_set(map: *map, key: u64, value: u64)`);
    lines.push(`# Arguments: rdi = map, rsi = key, rdx = value`);
    lines.push(`builtin_map_set:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12              # save map`);
    lines.push(`    push r13              # save key`);
    lines.push(`    push r14              # save value`);
    lines.push(``);
    lines.push(`    mov r12, rdi          # save map`);
    lines.push(`    mov r13, rsi          # save key`);
    lines.push(`    mov r14, rdx          # save value`);
    lines.push(``);
    lines.push(`    # First check if key already exists`);
    lines.push(`    xor rcx, rcx          # i = 0`);
    lines.push(`.map_set_find_loop:`);
    lines.push(`    cmp rcx, [r12 + 8]    # i < len?`);
    lines.push(`    jge .map_set_not_found`);
    lines.push(`    mov rax, [r12 + 0]    # entries ptr`);
    lines.push(`    mov r15, rcx`);
    lines.push(`    shl r15, 4            # i * 16`);
    lines.push(`    add r15, rax          # &entries[i]`);
    lines.push(`    mov rax, [r15]        # entries[i].key`);
    lines.push(`    cmp rax, r13          # key == target?`);
    lines.push(`    je .map_set_update`);
    lines.push(`    inc rcx`);
    lines.push(`    jmp .map_set_find_loop`);
    lines.push(``);
    lines.push(`.map_set_update:`);
    lines.push(`    # Update existing entry (r15 still points to entry)`);
    lines.push(`    mov [r15 + 8], r14    # entries[i].value = value`);
    lines.push(`    jmp .map_set_done`);
    lines.push(``);
    lines.push(`.map_set_not_found:`);
    lines.push(`    # Need to add new entry - check if we need to grow`);
    lines.push(`    mov rax, [r12 + 8]    # len`);
    lines.push(`    mov rdx, [r12 + 16]   # cap`);
    lines.push(`    cmp rax, rdx`);
    lines.push(`    jl .map_set_no_grow`);
    lines.push(``);
    lines.push(`    # Grow capacity`);
    lines.push(`    test rdx, rdx`);
    lines.push(`    jz .map_set_init_cap`);
    lines.push(`    shl rdx, 1            # new_cap = cap * 2`);
    lines.push(`    jmp .map_set_alloc`);
    lines.push(``);
    lines.push(`.map_set_init_cap:`);
    lines.push(`    mov rdx, 4            # initial capacity = 4`);
    lines.push(``);
    lines.push(`.map_set_alloc:`);
    lines.push(`    # Allocate new entries array (new_cap * 16 bytes per entry)`);
    lines.push(`    push rdx              # save new_cap`);
    lines.push(`    shl rdx, 4            # new_cap * 16`);
    lines.push(`    mov rdi, rdx`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    pop rdx               # restore new_cap`);
    lines.push(`    mov r15, rax          # save new_entries`);
    lines.push(``);
    lines.push(`    # Copy old entries`);
    lines.push(`    mov rcx, [r12 + 8]    # len`);
    lines.push(`    test rcx, rcx`);
    lines.push(`    jz .map_set_no_copy`);
    lines.push(`    mov rsi, [r12 + 0]    # old entries`);
    lines.push(`    mov rdi, r15          # new entries`);
    lines.push(`.map_set_copy_loop:`);
    lines.push(`    mov rax, [rsi]        # key`);
    lines.push(`    mov [rdi], rax`);
    lines.push(`    mov rax, [rsi + 8]    # value`);
    lines.push(`    mov [rdi + 8], rax`);
    lines.push(`    add rsi, 16`);
    lines.push(`    add rdi, 16`);
    lines.push(`    dec rcx`);
    lines.push(`    jnz .map_set_copy_loop`);
    lines.push(``);
    lines.push(`.map_set_no_copy:`);
    lines.push(`    # Update map struct`);
    lines.push(`    mov [r12 + 0], r15    # entries = new_entries`);
    lines.push(`    mov [r12 + 16], rdx   # cap = new_cap`);
    lines.push(``);
    lines.push(`.map_set_no_grow:`);
    lines.push(`    # Add new entry at end`);
    lines.push(`    mov rax, [r12 + 8]    # len`);
    lines.push(`    mov rdx, [r12 + 0]    # entries`);
    lines.push(`    mov r15, rax`);
    lines.push(`    shl r15, 4            # len * 16`);
    lines.push(`    add r15, rdx          # &entries[len]`);
    lines.push(`    mov [r15], r13        # entries[len].key = key`);
    lines.push(`    mov [r15 + 8], r14    # entries[len].value = value`);
    lines.push(``);
    lines.push(`    # Increment len`);
    lines.push(`    inc rax`);
    lines.push(`    mov [r12 + 8], rax    # len++`);
    lines.push(``);
    lines.push(`.map_set_done:`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // map_get(map, key) -> value
    lines.push(`# builtin_map_get(map: *map, key: u64) -> u64`);
    lines.push(`# Returns value for key, or 0 if not found`);
    lines.push(`builtin_map_get:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Search for key`);
    lines.push(`    xor rcx, rcx          # i = 0`);
    lines.push(`.map_get_loop:`);
    lines.push(`    cmp rcx, [rdi + 8]    # i < len?`);
    lines.push(`    jge .map_get_not_found`);
    lines.push(`    mov rax, [rdi + 0]    # entries ptr`);
    lines.push(`    mov r8, rcx`);
    lines.push(`    shl r8, 4             # i * 16`);
    lines.push(`    add r8, rax           # &entries[i]`);
    lines.push(`    mov rdx, [r8]         # entries[i].key`);
    lines.push(`    cmp rdx, rsi          # key == target?`);
    lines.push(`    je .map_get_found`);
    lines.push(`    inc rcx`);
    lines.push(`    jmp .map_get_loop`);
    lines.push(``);
    lines.push(`.map_get_found:`);
    lines.push(`    mov rax, [r8 + 8]     # entries[i].value`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.map_get_not_found:`);
    lines.push(`    xor rax, rax          # return 0`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // map_has(map, key) -> bool
    lines.push(`# builtin_map_has(map: *map, key: u64) -> bool`);
    lines.push(`# Returns 1 if key exists, 0 otherwise`);
    lines.push(`builtin_map_has:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Search for key`);
    lines.push(`    xor rcx, rcx          # i = 0`);
    lines.push(`.map_has_loop:`);
    lines.push(`    cmp rcx, [rdi + 8]    # i < len?`);
    lines.push(`    jge .map_has_not_found`);
    lines.push(`    mov rax, [rdi + 0]    # entries ptr`);
    lines.push(`    mov r8, rcx`);
    lines.push(`    shl r8, 4             # i * 16`);
    lines.push(`    add r8, rax           # &entries[i]`);
    lines.push(`    mov rax, [r8]         # entries[i].key`);
    lines.push(`    cmp rax, rsi          # key == target?`);
    lines.push(`    je .map_has_found`);
    lines.push(`    inc rcx`);
    lines.push(`    jmp .map_has_loop`);
    lines.push(``);
    lines.push(`.map_has_found:`);
    lines.push(`    mov rax, 1            # return true`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.map_has_not_found:`);
    lines.push(`    xor rax, rax          # return false`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // map_delete(map, key)
    lines.push(`# builtin_map_delete(map: *map, key: u64)`);
    lines.push(`# Removes key-value pair if it exists`);
    lines.push(`builtin_map_delete:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Search for key`);
    lines.push(`    xor rcx, rcx          # i = 0`);
    lines.push(`.map_delete_loop:`);
    lines.push(`    cmp rcx, [rdi + 8]    # i < len?`);
    lines.push(`    jge .map_delete_not_found`);
    lines.push(`    mov rax, [rdi + 0]    # entries ptr`);
    lines.push(`    mov r10, rcx`);
    lines.push(`    shl r10, 4            # i * 16`);
    lines.push(`    add r10, rax          # &entries[i]`);
    lines.push(`    mov rdx, [r10]        # entries[i].key`);
    lines.push(`    cmp rdx, rsi          # key == target?`);
    lines.push(`    je .map_delete_found`);
    lines.push(`    inc rcx`);
    lines.push(`    jmp .map_delete_loop`);
    lines.push(``);
    lines.push(`.map_delete_found:`);
    lines.push(`    # Shift remaining entries down`);
    lines.push(`    mov r8, [rdi + 8]     # len`);
    lines.push(`    dec r8                # len - 1`);
    lines.push(`    cmp rcx, r8           # if i == len-1, just decrement len`);
    lines.push(`    je .map_delete_last`);
    lines.push(``);
    lines.push(`    # Move entries[i+1..len] to entries[i..len-1]`);
    lines.push(`    mov rax, [rdi + 0]    # entries ptr`);
    lines.push(`    mov r10, rcx`);
    lines.push(`    shl r10, 4            # i * 16`);
    lines.push(`    add r10, rax          # &entries[i]`);
    lines.push(`    mov r11, r10`);
    lines.push(`    add r11, 16           # &entries[i+1]`);
    lines.push(`    mov rsi, r11          # src = &entries[i+1]`);
    lines.push(`    mov rdx, r10          # dst = &entries[i]`);
    lines.push(`    mov r9, [rdi + 8]     # len`);
    lines.push(`    sub r9, rcx           # count = len - i`);
    lines.push(`    dec r9                # count - 1`);
    lines.push(`.map_delete_shift_loop:`);
    lines.push(`    test r9, r9`);
    lines.push(`    jz .map_delete_last`);
    lines.push(`    mov rax, [rsi]        # key`);
    lines.push(`    mov [rdx], rax`);
    lines.push(`    mov rax, [rsi + 8]    # value`);
    lines.push(`    mov [rdx + 8], rax`);
    lines.push(`    add rsi, 16`);
    lines.push(`    add rdx, 16`);
    lines.push(`    dec r9`);
    lines.push(`    jmp .map_delete_shift_loop`);
    lines.push(``);
    lines.push(`.map_delete_last:`);
    lines.push(`    # Decrement len`);
    lines.push(`    mov rax, [rdi + 8]`);
    lines.push(`    dec rax`);
    lines.push(`    mov [rdi + 8], rax`);
    lines.push(``);
    lines.push(`.map_delete_not_found:`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // Aliases for compatibility with historical compiler
    lines.push(`# Alias: map_insert -> map_set`);
    lines.push(`builtin_map_insert:`);
    lines.push(`    jmp builtin_map_set`);
    lines.push(``);

    lines.push(`# Alias: map_contains -> map_has`);
    lines.push(`builtin_map_contains:`);
    lines.push(`    jmp builtin_map_has`);

    return lines.join('\n');
  }

  /**
   * Generate utility functions
   */
  generateUtilityFunctions() {
    const lines = [];

    // memcpy
    lines.push(`# ================================================================`);
    lines.push(`# builtin_memcpy(dest: *u8, src: *u8, n: u64)`);
    lines.push(`# Copy n bytes from src to dest`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_memcpy:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    mov rcx, rdx              # count`);
    lines.push(`    rep movsb                 # copy bytes`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // memset
    lines.push(`# builtin_memset(ptr: *u8, value: u8, n: u64)`);
    lines.push(`builtin_memset:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    mov al, sil               # value`);
    lines.push(`    mov rcx, rdx              # count`);
    lines.push(`    rep stosb                 # set bytes`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // sum(vec) -> i64
    lines.push(`# builtin_sum(vec: *vec) -> i64`);
    lines.push(`# Sums all elements in a vector`);
    lines.push(`# Arguments: rdi = vector pointer`);
    lines.push(`# Returns: rax = sum of all elements`);
    lines.push(`builtin_sum:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    xor rax, rax              # sum = 0`);
    lines.push(`    mov rcx, [rdi + 8]        # len`);
    lines.push(`    test rcx, rcx             # if len == 0, return 0`);
    lines.push(`    jz .sum_done`);
    lines.push(``);
    lines.push(`    mov rdx, [rdi + 0]        # ptr`);
    lines.push(`    xor r8, r8                # i = 0`);
    lines.push(``);
    lines.push(`.sum_loop:`);
    lines.push(`    add rax, [rdx + r8 * 8]   # sum += ptr[i]`);
    lines.push(`    inc r8                    # i++`);
    lines.push(`    cmp r8, rcx               # i < len?`);
    lines.push(`    jl .sum_loop`);
    lines.push(``);
    lines.push(`.sum_done:`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // time_now() -> i64
    lines.push(`# ================================================================`);
    lines.push(`# builtin_time_now() -> i64`);
    lines.push(`# Returns current Unix timestamp in milliseconds`);
    lines.push(`# Uses gettimeofday syscall (96)`);
    lines.push(`# Returns: rax = milliseconds since epoch`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_time_now:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    sub rsp, 16               # allocate timeval struct (tv_sec: i64, tv_usec: i64)`);
    lines.push(``);
    lines.push(`    # gettimeofday(timeval*, NULL)`);
    lines.push(`    mov rax, 96               # syscall: gettimeofday`);
    lines.push(`    lea rdi, [rbp - 16]       # timeval pointer`);
    lines.push(`    xor rsi, rsi              # timezone = NULL`);
    lines.push(`    syscall`);
    lines.push(``);
    lines.push(`    # Convert to milliseconds: (tv_sec * 1000) + (tv_usec / 1000)`);
    lines.push(`    mov rax, [rbp - 16]       # tv_sec`);
    lines.push(`    imul rax, 1000            # tv_sec * 1000`);
    lines.push(`    mov rdx, [rbp - 8]        # tv_usec`);
    lines.push(`    mov rcx, 1000`);
    lines.push(`    xor rdx, rdx`);
    lines.push(`    mov rdx, [rbp - 8]        # tv_usec`);
    lines.push(`    mov rbx, 1000`);
    lines.push(`    xor rdx, rdx              # clear rdx for div`);
    lines.push(`    mov rax, [rbp - 8]        # tv_usec`);
    lines.push(`    cqo                       # sign extend`);
    lines.push(`    idiv rbx                  # tv_usec / 1000`);
    lines.push(`    mov rbx, rax              # save microseconds`);
    lines.push(`    mov rax, [rbp - 16]       # tv_sec`);
    lines.push(`    imul rax, 1000            # tv_sec * 1000`);
    lines.push(`    add rax, rbx              # add milliseconds from usec`);
    lines.push(``);
    lines.push(`    add rsp, 16`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // json_encode(value) -> string
    // Simplified implementation: treats value as a 64-bit integer and converts to string
    lines.push(`# ================================================================`);
    lines.push(`# builtin_json_encode(value: i64) -> *u8`);
    lines.push(`# Encodes a value as JSON string (simplified: integers as decimal strings)`);
    lines.push(`# For full JSON encoding, would need type information`);
    lines.push(`# Arguments: rdi = value (treated as signed integer)`);
    lines.push(`# Returns: rax = pointer to JSON string (number as string)`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_json_encode:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12`);
    lines.push(`    push r13`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # save value`);
    lines.push(``);
    lines.push(`    # Allocate buffer for result (20 bytes enough for 64-bit int)`);
    lines.push(`    mov rdi, 32`);
    lines.push(`    call builtin_heap_alloc`);
    lines.push(`    mov r13, rax              # save buffer pointer`);
    lines.push(``);
    lines.push(`    # Convert integer to string`);
    lines.push(`    mov rdi, r12              # value`);
    lines.push(`    mov rsi, r13              # buffer`);
    lines.push(`    call .int_to_string       # helper function`);
    lines.push(``);
    lines.push(`    mov rax, r13              # return buffer pointer`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.int_to_string:               # convert integer (rdi) to string in buffer (rsi)`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push rbx`);
    lines.push(`    push r12`);
    lines.push(`    push r13`);
    lines.push(`    push r14`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # value`);
    lines.push(`    mov r13, rsi              # buffer`);
    lines.push(``);
    lines.push(`    # Handle zero`);
    lines.push(`    test r12, r12`);
    lines.push(`    jnz .not_zero`);
    lines.push(`    mov byte ptr [r13], 0x30  # '0'`);
    lines.push(`    mov byte ptr [r13 + 1], 0 # null terminator`);
    lines.push(`    jmp .int_to_str_done`);
    lines.push(``);
    lines.push(`.not_zero:`);
    lines.push(`    # Handle negative`);
    lines.push(`    xor r14, r14              # offset = 0`);
    lines.push(`    test r12, r12`);
    lines.push(`    jns .positive`);
    lines.push(`    mov byte ptr [r13], 0x2d  # '-'`);
    lines.push(`    inc r14                   # offset++`);
    lines.push(`    neg r12                   # make positive`);
    lines.push(``);
    lines.push(`.positive:`);
    lines.push(`    # Convert digits (reverse order)`);
    lines.push(`    lea rsi, [r13 + r14]      # start of digits`);
    lines.push(`    mov rbx, rsi              # save start`);
    lines.push(``);
    lines.push(`.digit_loop:`);
    lines.push(`    mov rax, r12`);
    lines.push(`    xor rdx, rdx`);
    lines.push(`    mov rcx, 10`);
    lines.push(`    div rcx                   # rax = value/10, rdx = value%10`);
    lines.push(`    add dl, 0x30              # convert to ASCII`);
    lines.push(`    mov [rsi], dl             # store digit`);
    lines.push(`    inc rsi`);
    lines.push(`    mov r12, rax              # value = value/10`);
    lines.push(`    test r12, r12`);
    lines.push(`    jnz .digit_loop`);
    lines.push(``);
    lines.push(`    mov byte ptr [rsi], 0     # null terminator`);
    lines.push(``);
    lines.push(`    # Reverse digits`);
    lines.push(`    dec rsi                   # point to last digit`);
    lines.push(`.reverse_loop:`);
    lines.push(`    cmp rbx, rsi              # start >= end?`);
    lines.push(`    jge .int_to_str_done`);
    lines.push(`    mov al, [rbx]             # swap characters`);
    lines.push(`    mov cl, [rsi]`);
    lines.push(`    mov [rbx], cl`);
    lines.push(`    mov [rsi], al`);
    lines.push(`    inc rbx`);
    lines.push(`    dec rsi`);
    lines.push(`    jmp .reverse_loop`);
    lines.push(``);
    lines.push(`.int_to_str_done:`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbx`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // map_get_or_default(map, key, default) -> value
    lines.push(`# ================================================================`);
    lines.push(`# builtin_map_get_or_default(map: *map, key: i64, default: i64) -> i64`);
    lines.push(`# Get value from map or return default if not found`);
    lines.push(`# Arguments: rdi = map pointer, rsi = key, rdx = default value`);
    lines.push(`# Returns: rax = value or default`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_map_get_or_default:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push rdx                  # save default value`);
    lines.push(``);
    lines.push(`    # First check if key exists`);
    lines.push(`    call builtin_map_has`);
    lines.push(`    test rax, rax             # does key exist?`);
    lines.push(`    jz .map_get_default       # if not, return default`);
    lines.push(``);
    lines.push(`    # Key exists, get the value`);
    lines.push(`    pop rdx                   # remove default from stack`);
    lines.push(`    mov rdi, [rbp + 16]       # restore map pointer (from stack)`);
    lines.push(`    mov rsi, [rbp + 24]       # restore key (from stack)`);
    lines.push(`    call builtin_map_get`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.map_get_default:`);
    lines.push(`    pop rax                   # return default value`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // hex_decode(hexstr) -> vec<u8>
    lines.push(`# ================================================================`);
    lines.push(`# builtin_hex_decode(hexstr: *u8) -> *vec`);
    lines.push(`# Decode hexadecimal string to byte vector`);
    lines.push(`# Arguments: rdi = hex string pointer`);
    lines.push(`# Returns: rax = vector of bytes`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_hex_decode:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12                  # hex string`);
    lines.push(`    push r13                  # result vector`);
    lines.push(`    push r14                  # current position`);
    lines.push(`    push r15                  # string length`);
    lines.push(``);
    lines.push(`    mov r12, rdi              # save hex string`);
    lines.push(``);
    lines.push(`    # Get string length`);
    lines.push(`    call builtin_string_len`);
    lines.push(`    mov r15, rax              # save length`);
    lines.push(``);
    lines.push(`    # Create result vector`);
    lines.push(`    call builtin_vec_new`);
    lines.push(`    mov r13, rax              # save result vector`);
    lines.push(``);
    lines.push(`    # Check for empty string`);
    lines.push(`    test r15, r15`);
    lines.push(`    jz .hex_decode_done`);
    lines.push(``);
    lines.push(`    xor r14, r14              # position = 0`);
    lines.push(``);
    lines.push(`.hex_decode_loop:`);
    lines.push(`    # Check if we have at least 2 characters left`);
    lines.push(`    lea rax, [r14 + 1]`);
    lines.push(`    cmp rax, r15`);
    lines.push(`    jge .hex_decode_done      # if position+1 >= length, done`);
    lines.push(``);
    lines.push(`    # Get first hex digit`);
    lines.push(`    movzx rax, byte ptr [r12 + r14]`);
    lines.push(`    call .hex_char_to_value   # convert to value (0-15)`);
    lines.push(`    cmp rax, -1               # check if invalid`);
    lines.push(`    je .hex_decode_done       # if invalid, stop`);
    lines.push(`    shl rax, 4                # shift left 4 bits`);
    lines.push(`    mov rbx, rax              # save high nibble`);
    lines.push(``);
    lines.push(`    # Get second hex digit`);
    lines.push(`    movzx rax, byte ptr [r12 + r14 + 1]`);
    lines.push(`    call .hex_char_to_value`);
    lines.push(`    cmp rax, -1`);
    lines.push(`    je .hex_decode_done`);
    lines.push(`    or rax, rbx               # combine nibbles`);
    lines.push(``);
    lines.push(`    # Push byte to vector`);
    lines.push(`    mov rdi, r13              # vector`);
    lines.push(`    mov rsi, rax              # byte value`);
    lines.push(`    call builtin_vec_push`);
    lines.push(``);
    lines.push(`    add r14, 2                # advance position by 2`);
    lines.push(`    jmp .hex_decode_loop`);
    lines.push(``);
    lines.push(`.hex_decode_done:`);
    lines.push(`    mov rax, r13              # return vector`);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);
    lines.push(`.hex_char_to_value:           # convert hex char (in rax) to value 0-15, or -1 if invalid`);
    lines.push(`    cmp rax, 0x30             # '0'`);
    lines.push(`    jl .hex_invalid`);
    lines.push(`    cmp rax, 0x39             # '9'`);
    lines.push(`    jle .hex_digit            # 0-9`);
    lines.push(`    cmp rax, 0x41             # 'A'`);
    lines.push(`    jl .hex_invalid`);
    lines.push(`    cmp rax, 0x46             # 'F'`);
    lines.push(`    jle .hex_upper            # A-F`);
    lines.push(`    cmp rax, 0x61             # 'a'`);
    lines.push(`    jl .hex_invalid`);
    lines.push(`    cmp rax, 0x66             # 'f'`);
    lines.push(`    jg .hex_invalid`);
    lines.push(`    # a-f: subtract 'a' (0x61) and add 10`);
    lines.push(`    sub rax, 0x61`);
    lines.push(`    add rax, 10`);
    lines.push(`    ret`);
    lines.push(`.hex_digit:                   # 0-9: subtract '0'`);
    lines.push(`    sub rax, 0x30`);
    lines.push(`    ret`);
    lines.push(`.hex_upper:                   # A-F: subtract 'A' and add 10`);
    lines.push(`    sub rax, 0x41`);
    lines.push(`    add rax, 10`);
    lines.push(`    ret`);
    lines.push(`.hex_invalid:`);
    lines.push(`    mov rax, -1`);
    lines.push(`    ret`);
    lines.push(``);

    // parse_i64(str) -> i64
    lines.push(`# ================================================================`);
    lines.push(`# builtin_parse_i64(str: *u8) -> i64`);
    lines.push(`# Parse string to signed 64-bit integer`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# Returns: rax = parsed integer value`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_parse_i64:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12              # save string pointer`);
    lines.push(`    push r13              # sign flag`);
    lines.push(``);
    lines.push(`    mov r12, rdi          # string pointer`);
    lines.push(`    xor rax, rax          # result = 0`);
    lines.push(`    xor r13, r13          # sign = positive (0)`);
    lines.push(``);
    lines.push(`    # Check for sign`);
    lines.push(`    cmp byte ptr [r12], '-'`);
    lines.push(`    jne .parse_i64_check_plus`);
    lines.push(`    mov r13, 1            # sign = negative`);
    lines.push(`    inc r12               # skip '-'`);
    lines.push(`    jmp .parse_i64_loop`);
    lines.push(``);
    lines.push(`.parse_i64_check_plus:`);
    lines.push(`    cmp byte ptr [r12], '+'`);
    lines.push(`    jne .parse_i64_loop`);
    lines.push(`    inc r12               # skip '+'`);
    lines.push(``);
    lines.push(`.parse_i64_loop:`);
    lines.push(`    movzx rdx, byte ptr [r12]`);
    lines.push(`    test rdx, rdx`);
    lines.push(`    jz .parse_i64_done    # null terminator`);
    lines.push(``);
    lines.push(`    # Check if digit (0-9)`);
    lines.push(`    cmp rdx, '0'`);
    lines.push(`    jl .parse_i64_done    # not a digit, stop`);
    lines.push(`    cmp rdx, '9'`);
    lines.push(`    jg .parse_i64_done    # not a digit, stop`);
    lines.push(``);
    lines.push(`    # result = result * 10 + (digit - '0')`);
    lines.push(`    imul rax, 10`);
    lines.push(`    sub rdx, '0'`);
    lines.push(`    add rax, rdx`);
    lines.push(``);
    lines.push(`    inc r12`);
    lines.push(`    jmp .parse_i64_loop`);
    lines.push(``);
    lines.push(`.parse_i64_done:`);
    lines.push(`    # Apply sign if negative`);
    lines.push(`    test r13, r13`);
    lines.push(`    jz .parse_i64_positive`);
    lines.push(`    neg rax               # negate if sign was negative`);
    lines.push(``);
    lines.push(`.parse_i64_positive:`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);
    lines.push(``);

    // parse_f64(str) -> f64
    lines.push(`# ================================================================`);
    lines.push(`# builtin_parse_f64(str: *u8) -> f64`);
    lines.push(`# Parse string to 64-bit floating point`);
    lines.push(`# Simplified implementation: supports basic decimal notation`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# Returns: xmm0 = parsed float value`);
    lines.push(`# For now, we store the result as an integer in rax for simplicity`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_parse_f64:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(`    push r12              # save string pointer`);
    lines.push(`    push r13              # integer part`);
    lines.push(`    push r14              # fractional part`);
    lines.push(`    push r15              # sign flag`);
    lines.push(``);
    lines.push(`    mov r12, rdi          # string pointer`);
    lines.push(`    xor r13, r13          # integer part = 0`);
    lines.push(`    xor r14, r14          # fractional part = 0`);
    lines.push(`    xor r15, r15          # sign = positive`);
    lines.push(``);
    lines.push(`    # Check for sign`);
    lines.push(`    cmp byte ptr [r12], '-'`);
    lines.push(`    jne .parse_f64_check_plus`);
    lines.push(`    mov r15, 1            # sign = negative`);
    lines.push(`    inc r12               # skip '-'`);
    lines.push(`    jmp .parse_f64_integer`);
    lines.push(``);
    lines.push(`.parse_f64_check_plus:`);
    lines.push(`    cmp byte ptr [r12], '+'`);
    lines.push(`    jne .parse_f64_integer`);
    lines.push(`    inc r12               # skip '+'`);
    lines.push(``);
    lines.push(`.parse_f64_integer:`);
    lines.push(`    movzx rax, byte ptr [r12]`);
    lines.push(`    test rax, rax`);
    lines.push(`    jz .parse_f64_done`);
    lines.push(``);
    lines.push(`    cmp rax, '.'`);
    lines.push(`    je .parse_f64_fraction`);
    lines.push(``);
    lines.push(`    cmp rax, '0'`);
    lines.push(`    jl .parse_f64_done`);
    lines.push(`    cmp rax, '9'`);
    lines.push(`    jg .parse_f64_done`);
    lines.push(``);
    lines.push(`    # integer_part = integer_part * 10 + (digit - '0')`);
    lines.push(`    imul r13, 10`);
    lines.push(`    sub rax, '0'`);
    lines.push(`    add r13, rax`);
    lines.push(``);
    lines.push(`    inc r12`);
    lines.push(`    jmp .parse_f64_integer`);
    lines.push(``);
    lines.push(`.parse_f64_fraction:`);
    lines.push(`    inc r12               # skip '.'`);
    lines.push(`    # For simplicity, we'll just ignore the fractional part`);
    lines.push(`    # A full implementation would parse it properly`);
    lines.push(``);
    lines.push(`.parse_f64_fraction_loop:`);
    lines.push(`    movzx rax, byte ptr [r12]`);
    lines.push(`    test rax, rax`);
    lines.push(`    jz .parse_f64_done`);
    lines.push(``);
    lines.push(`    cmp rax, '0'`);
    lines.push(`    jl .parse_f64_done`);
    lines.push(`    cmp rax, '9'`);
    lines.push(`    jg .parse_f64_done`);
    lines.push(``);
    lines.push(`    inc r12`);
    lines.push(`    jmp .parse_f64_fraction_loop`);
    lines.push(``);
    lines.push(`.parse_f64_done:`);
    lines.push(`    # For now, return integer part as the result`);
    lines.push(`    # TODO: Proper float implementation with fractional part`);
    lines.push(`    mov rax, r13`);
    lines.push(`    test r15, r15`);
    lines.push(`    jz .parse_f64_positive`);
    lines.push(`    neg rax`);
    lines.push(``);
    lines.push(`.parse_f64_positive:`);
    lines.push(`    pop r15`);
    lines.push(`    pop r14`);
    lines.push(`    pop r13`);
    lines.push(`    pop r12`);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);

    return lines.join('\n');
  }

  /**
   * Generate test helper functions
   * These are application-specific functions used in test programs
   */
  generateTestHelpers() {
    const lines = [];

    // compute(str) -> i64
    // Test function used in pipeline.mycelial
    // Returns the length of the string as a simple computation
    lines.push(`# ================================================================`);
    lines.push(`# builtin_compute(str: *u8) -> i64`);
    lines.push(`# Test function: computes a value from a string`);
    lines.push(`# For simplicity, returns the string length`);
    lines.push(`# Arguments: rdi = string pointer`);
    lines.push(`# Returns: rax = computed value (length)`);
    lines.push(`# ================================================================`);
    lines.push(`builtin_compute:`);
    lines.push(`    push rbp`);
    lines.push(`    mov rbp, rsp`);
    lines.push(``);
    lines.push(`    # Just return string length as the "computation"`);
    lines.push(`    call builtin_string_len`);
    lines.push(``);
    lines.push(`    pop rbp`);
    lines.push(`    ret`);

    return lines.join('\n');
  }
}

module.exports = { BuiltinFunctionsGenerator };
