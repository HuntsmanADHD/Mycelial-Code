/*
 * Mycelial Signal Runtime - Dispatch Tables
 * M2 Phase 3 Implementation
 *
 * Provides signal dispatch infrastructure for handler functions.
 * When an agent receives a signal, the dispatch table routes it to
 * the appropriate handler based on frequency_id.
 *
 * Based on M2_PATTERN_MATCHING_DISPATCH_SPEC.md
 */

#ifndef MYCELIAL_DISPATCH_H
#define MYCELIAL_DISPATCH_H

#include <stdint.h>
#include <stddef.h>

/* Forward declarations */
struct Signal;

/* =============================================================================
 * HANDLER FUNCTION TYPES
 * ============================================================================= */

/*
 * Signal handler function signature
 *
 * @param agent_state: Pointer to agent's state structure
 * @param signal: Pointer to received signal
 * @return: 0 on success, non-zero on error
 *
 * Handler functions are generated by the compiler for each `on signal` block.
 * System V AMD64 calling convention:
 *   rdi = agent_state
 *   rsi = signal pointer
 *   rax = return value
 */
typedef int (*signal_handler_fn)(void* agent_state, struct Signal* signal);

/*
 * Guard function signature (for where clauses)
 *
 * @param agent_state: Pointer to agent's state structure
 * @param signal: Pointer to received signal
 * @return: 1 if guard passes, 0 if guard fails
 */
typedef int (*guard_fn)(void* agent_state, struct Signal* signal);

/* =============================================================================
 * DISPATCH TABLE STRUCTURES
 * ============================================================================= */

/*
 * Single dispatch entry - maps frequency_id to handler
 *
 * Layout: 24 bytes
 * - 4 bytes: frequency_id
 * - 4 bytes: flags (has_guard, etc.)
 * - 8 bytes: handler function pointer
 * - 8 bytes: guard function pointer (NULL if no guard)
 */
typedef struct DispatchEntry {
    uint32_t frequency_id;          /* 0x00: Signal frequency to match */
    uint32_t flags;                 /* 0x04: Entry flags */
    signal_handler_fn handler;      /* 0x08: Handler function pointer */
    guard_fn guard;                 /* 0x10: Optional guard function */
} DispatchEntry;

/* DispatchEntry flags */
#define DISPATCH_FLAG_ACTIVE        0x0001  /* Entry is active */
#define DISPATCH_FLAG_HAS_GUARD     0x0002  /* Entry has guard clause */
#define DISPATCH_FLAG_CATCHALL      0x0004  /* Matches any frequency */

/*
 * Dispatch table for one agent
 *
 * Contains all handlers registered for a single agent.
 * Lookup is O(n) for small tables (< 16 entries) or O(1) with hash.
 *
 * Layout: 40 bytes
 */
typedef struct DispatchTable {
    DispatchEntry* entries;         /* 0x00: Array of dispatch entries */
    uint32_t entry_count;           /* 0x08: Number of active entries */
    uint32_t capacity;              /* 0x0C: Max entries */
    signal_handler_fn default_handler;  /* 0x10: Called if no match found */
    void* agent_state;              /* 0x18: Cached agent state pointer */
    uint32_t agent_id;              /* 0x20: Agent this table belongs to */
    uint32_t lookup_count;          /* 0x24: Stats: total lookups */
    uint32_t hit_count;             /* 0x28: Stats: successful lookups */
    uint32_t miss_count;            /* 0x2C: Stats: failed lookups */
} DispatchTable;

/* =============================================================================
 * DISPATCH RESULT CODES
 * ============================================================================= */

#define DISPATCH_OK                 0   /* Handler executed successfully */
#define DISPATCH_ERR_NO_HANDLER     1   /* No handler found for frequency */
#define DISPATCH_ERR_GUARD_FAILED   2   /* Guard clause returned false */
#define DISPATCH_ERR_NULL_POINTER   3   /* NULL table or signal */
#define DISPATCH_ERR_HANDLER_FAILED 4   /* Handler returned non-zero */
#define DISPATCH_ERR_ALLOC_FAILED   5   /* Memory allocation failed */

/* =============================================================================
 * DISPATCH TABLE FUNCTIONS
 * ============================================================================= */

/*
 * Create a dispatch table for an agent
 *
 * @param capacity: Maximum number of handlers
 * @param agent_id: ID of the agent this table belongs to
 * @return: Pointer to table, or NULL on failure
 */
DispatchTable* dispatch_table_create(uint32_t capacity, uint32_t agent_id);

/*
 * Destroy dispatch table and free memory
 *
 * @param table: Table to destroy
 */
void dispatch_table_destroy(DispatchTable* table);

/*
 * Register a handler in the dispatch table
 *
 * @param table: Dispatch table
 * @param frequency_id: Signal frequency to handle
 * @param handler: Handler function pointer
 * @param guard: Optional guard function (NULL if no guard)
 * @return: DISPATCH_OK on success
 */
int dispatch_register(DispatchTable* table, uint32_t frequency_id,
                      signal_handler_fn handler, guard_fn guard);

/*
 * Unregister a handler from the dispatch table
 *
 * @param table: Dispatch table
 * @param frequency_id: Signal frequency to unregister
 * @return: DISPATCH_OK on success, DISPATCH_ERR_NO_HANDLER if not found
 */
int dispatch_unregister(DispatchTable* table, uint32_t frequency_id);

/*
 * Set default handler (called when no matching frequency found)
 *
 * @param table: Dispatch table
 * @param handler: Default handler function
 */
void dispatch_set_default(DispatchTable* table, signal_handler_fn handler);

/*
 * Set agent state pointer (cached for fast dispatch)
 *
 * @param table: Dispatch table
 * @param state: Pointer to agent state
 */
void dispatch_set_state(DispatchTable* table, void* state);

/*
 * Look up handler for a frequency
 *
 * Fast lookup for dispatch. Returns NULL if no handler found.
 * Performance target: < 20 cycles
 *
 * @param table: Dispatch table
 * @param frequency_id: Signal frequency to look up
 * @return: Handler function pointer, or NULL if not found
 */
signal_handler_fn dispatch_lookup(DispatchTable* table, uint32_t frequency_id);

/*
 * Look up full dispatch entry for a frequency
 *
 * Returns the complete entry including guard function.
 *
 * @param table: Dispatch table
 * @param frequency_id: Signal frequency to look up
 * @return: Dispatch entry pointer, or NULL if not found
 */
DispatchEntry* dispatch_lookup_entry(DispatchTable* table, uint32_t frequency_id);

/*
 * Execute handler for a signal
 *
 * This is the main dispatch function. It:
 * 1. Looks up the handler by frequency_id
 * 2. Checks the guard clause (if present)
 * 3. Invokes the handler with agent_state and signal
 * 4. Returns the handler's result code
 *
 * Performance target: < 50 cycles total
 *
 * @param table: Dispatch table
 * @param signal: Signal to dispatch
 * @return: DISPATCH_OK on success, error code on failure
 */
int dispatch_invoke(DispatchTable* table, struct Signal* signal);

/*
 * Execute handler with explicit state pointer
 *
 * Same as dispatch_invoke but uses provided state instead of cached state.
 *
 * @param table: Dispatch table
 * @param agent_state: Agent state pointer
 * @param signal: Signal to dispatch
 * @return: DISPATCH_OK on success, error code on failure
 */
int dispatch_invoke_with_state(DispatchTable* table, void* agent_state,
                               struct Signal* signal);

/* =============================================================================
 * DISPATCH STATISTICS
 * ============================================================================= */

/*
 * Get dispatch statistics
 */
uint32_t dispatch_get_lookup_count(DispatchTable* table);
uint32_t dispatch_get_hit_count(DispatchTable* table);
uint32_t dispatch_get_miss_count(DispatchTable* table);

/*
 * Reset dispatch statistics
 */
void dispatch_reset_stats(DispatchTable* table);

/* =============================================================================
 * AGENT EVENT LOOP SUPPORT
 * ============================================================================= */

/*
 * Process all signals in an agent's queue
 *
 * Dequeues signals one at a time and dispatches to handlers.
 * Returns number of signals processed.
 *
 * @param table: Dispatch table for the agent
 * @param queue: Agent's input signal queue
 * @return: Number of signals processed
 */
struct SignalQueue;
int dispatch_process_queue(DispatchTable* table, struct SignalQueue* queue);

/*
 * Process up to N signals from queue
 *
 * Useful for fair scheduling when multiple agents need processing.
 *
 * @param table: Dispatch table
 * @param queue: Agent's input queue
 * @param max_signals: Maximum signals to process
 * @return: Number of signals actually processed
 */
int dispatch_process_batch(DispatchTable* table, struct SignalQueue* queue,
                           uint32_t max_signals);

#endif /* MYCELIAL_DISPATCH_H */
