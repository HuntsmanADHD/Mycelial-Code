# Pipeline Pattern in Mycelial
# Sequential processing stages: each stage transforms data and passes to next

network Pipeline {
  frequencies {
    raw_data {
      id: u32
      payload: string
    }

    validated_data {
      id: u32
      payload: string
    }

    processed_data {
      id: u32
      result: i64
    }

    formatted_output {
      id: u32
      message: string
    }
  }

  hyphae {
    # Stage 1: Validation
    hyphal validator {
      state {
        validated_count: u32 = 0
        failed_count: u32 = 0
      }

      on signal(raw_data, d) {
        if len(d.payload) > 0 && len(d.payload) <= 100 {
          state.validated_count = state.validated_count + 1
          emit validated_data {
            id: d.id,
            payload: d.payload
          }
        } else {
          state.failed_count = state.failed_count + 1
          report error: format("validation_failed_id_{}", d.id)
        }
      }

      on rest {
        report validation_stats: state.validated_count
      }
    }

    # Stage 2: Processing
    hyphal processor {
      state {
        processed_count: u32 = 0
      }

      on signal(validated_data, d) {
        # Some transformation
        let result = compute(d.payload)
        state.processed_count = state.processed_count + 1

        emit processed_data {
          id: d.id,
          result: result
        }
      }

      on rest {
        report processed_count: state.processed_count
      }
    }

    # Stage 3: Formatting
    hyphal formatter {
      state {
        formatted_count: u32 = 0
      }

      on signal(processed_data, d) {
        state.formatted_count = state.formatted_count + 1

        emit formatted_output {
          id: d.id,
          message: format("[{}] Result: {}", d.id, d.result)
        }
      }

      on rest {
        report formatted_count: state.formatted_count
      }
    }
  }

  topology {
    fruiting_body input
    fruiting_body output

    spawn validator as V
    spawn processor as P
    spawn formatter as F

    # Pipeline: each stage feeds the next
    socket input -> V (frequency: raw_data)
    socket V -> P (frequency: validated_data)
    socket P -> F (frequency: processed_data)
    socket F -> output (frequency: formatted_output)
  }
}

# CHARACTERISTICS:
#   - Linear dataflow: input -> validate -> process -> format -> output
#   - Each stage is independent: can be scaled, replaced, or extended
#   - Backpressure: if output stage is slow, it backs up through the pipeline
#   - Throughput: at any moment, different stages process different items
#   - Easy to debug: trace data through each stage
#
# EXAMPLE FLOW:
#   INPUT:  raw_data(id=1, payload="hello")
#   [V]     validated_data(id=1, payload="hello")
#   [P]     processed_data(id=1, result=5)
#   [F]     formatted_output(id=1, message="[1] Result: 5")
#   OUTPUT: formatted_output(id=1, message="[1] Result: 5")
