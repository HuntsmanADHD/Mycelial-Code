# Parser Test Harness
#
# Purpose: Validate the Parser Agent with hello_world and other test cases
# This test simulates Lexer output and verifies Parser produces correct AST
#
# Test Coverage:
#   - hello_world.mycelial parsing
#   - Expression parsing (all precedence levels)
#   - Statement parsing (all types)
#   - Definition parsing (network, hyphal, frequency)

network ParserTest {

  import parser

  # ═══════════════════════════════════════════════════════════════════════════
  # TEST SIGNAL DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  frequencies {
    run_parser_test {
      test_name: string
    }

    parser_test_result {
      test_name: string
      passed: boolean
      message: string
      ast_summary: string
    }

    all_parser_tests_complete {
      total: u32
      passed: u32
      failed: u32
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TEST DATA - hello_world.mycelial tokens
  # ═══════════════════════════════════════════════════════════════════════════

  constants {
    # Tokenized version of hello_world.mycelial:
    #
    # network HelloWorld {
    #   frequencies {
    #     greeting { name: string }
    #     response { message: string }
    #   }
    #   hyphae {
    #     hyphal greeter {
    #       on signal(greeting, g) {
    #         emit response {
    #           message: format("Hello, {}!", g.name)
    #         }
    #       }
    #     }
    #   }
    # }

    HELLO_WORLD_TOKENS = [
      Token { type: NETWORK, value: "network", line: 1, column: 1 },
      Token { type: IDENTIFIER, value: "HelloWorld", line: 1, column: 9 },
      Token { type: LBRACE, value: "{", line: 1, column: 20 },

      # frequencies block
      Token { type: FREQUENCIES, value: "frequencies", line: 2, column: 3 },
      Token { type: LBRACE, value: "{", line: 2, column: 15 },

      # greeting frequency
      Token { type: IDENTIFIER, value: "greeting", line: 3, column: 5 },
      Token { type: LBRACE, value: "{", line: 3, column: 14 },
      Token { type: IDENTIFIER, value: "name", line: 3, column: 16 },
      Token { type: COLON, value: ":", line: 3, column: 20 },
      Token { type: IDENTIFIER, value: "string", line: 3, column: 22 },
      Token { type: RBRACE, value: "}", line: 3, column: 29 },

      # response frequency
      Token { type: IDENTIFIER, value: "response", line: 4, column: 5 },
      Token { type: LBRACE, value: "{", line: 4, column: 14 },
      Token { type: IDENTIFIER, value: "message", line: 4, column: 16 },
      Token { type: COLON, value: ":", line: 4, column: 23 },
      Token { type: IDENTIFIER, value: "string", line: 4, column: 25 },
      Token { type: RBRACE, value: "}", line: 4, column: 32 },

      Token { type: RBRACE, value: "}", line: 5, column: 3 },  # close frequencies

      # hyphae block
      Token { type: HYPHAE, value: "hyphae", line: 7, column: 3 },
      Token { type: LBRACE, value: "{", line: 7, column: 10 },

      # hyphal greeter
      Token { type: HYPHAL, value: "hyphal", line: 8, column: 5 },
      Token { type: IDENTIFIER, value: "greeter", line: 8, column: 12 },
      Token { type: LBRACE, value: "{", line: 8, column: 20 },

      # on signal rule
      Token { type: ON, value: "on", line: 9, column: 7 },
      Token { type: SIGNAL, value: "signal", line: 9, column: 10 },
      Token { type: LPAREN, value: "(", line: 9, column: 16 },
      Token { type: IDENTIFIER, value: "greeting", line: 9, column: 17 },
      Token { type: COMMA, value: ",", line: 9, column: 25 },
      Token { type: IDENTIFIER, value: "g", line: 9, column: 27 },
      Token { type: RPAREN, value: ")", line: 9, column: 28 },
      Token { type: LBRACE, value: "{", line: 9, column: 30 },

      # emit statement
      Token { type: EMIT, value: "emit", line: 10, column: 9 },
      Token { type: IDENTIFIER, value: "response", line: 10, column: 14 },
      Token { type: LBRACE, value: "{", line: 10, column: 23 },
      Token { type: IDENTIFIER, value: "message", line: 11, column: 11 },
      Token { type: COLON, value: ":", line: 11, column: 18 },
      Token { type: IDENTIFIER, value: "format", line: 11, column: 20 },
      Token { type: LPAREN, value: "(", line: 11, column: 26 },
      Token { type: STRING_LIT, value: "Hello, {}!", line: 11, column: 27 },
      Token { type: COMMA, value: ",", line: 11, column: 39 },
      Token { type: IDENTIFIER, value: "g", line: 11, column: 41 },
      Token { type: DOT, value: ".", line: 11, column: 42 },
      Token { type: IDENTIFIER, value: "name", line: 11, column: 43 },
      Token { type: RPAREN, value: ")", line: 11, column: 47 },
      Token { type: RBRACE, value: "}", line: 12, column: 9 },

      Token { type: RBRACE, value: "}", line: 13, column: 7 },  # close rule
      Token { type: RBRACE, value: "}", line: 14, column: 5 },  # close hyphal
      Token { type: RBRACE, value: "}", line: 15, column: 3 },  # close hyphae
      Token { type: RBRACE, value: "}", line: 16, column: 1 },  # close network

      Token { type: EOF, value: "", line: 16, column: 2 }
    ]

    # Simple expression test tokens: 1 + 2 * 3
    EXPR_PRECEDENCE_TOKENS = [
      Token { type: NETWORK, value: "network", line: 1, column: 1 },
      Token { type: IDENTIFIER, value: "Test", line: 1, column: 9 },
      Token { type: LBRACE, value: "{", line: 1, column: 14 },
      Token { type: HYPHAE, value: "hyphae", line: 2, column: 3 },
      Token { type: LBRACE, value: "{", line: 2, column: 10 },
      Token { type: HYPHAL, value: "hyphal", line: 3, column: 5 },
      Token { type: IDENTIFIER, value: "calc", line: 3, column: 12 },
      Token { type: LBRACE, value: "{", line: 3, column: 17 },
      Token { type: ON, value: "on", line: 4, column: 7 },
      Token { type: REST, value: "rest", line: 4, column: 10 },
      Token { type: LBRACE, value: "{", line: 4, column: 15 },
      Token { type: LET, value: "let", line: 5, column: 9 },
      Token { type: IDENTIFIER, value: "x", line: 5, column: 13 },
      Token { type: ASSIGN, value: "=", line: 5, column: 15 },
      Token { type: NUMBER, value: "1", line: 5, column: 17 },
      Token { type: PLUS, value: "+", line: 5, column: 19 },
      Token { type: NUMBER, value: "2", line: 5, column: 21 },
      Token { type: STAR, value: "*", line: 5, column: 23 },
      Token { type: NUMBER, value: "3", line: 5, column: 25 },
      Token { type: RBRACE, value: "}", line: 6, column: 7 },
      Token { type: RBRACE, value: "}", line: 7, column: 5 },
      Token { type: RBRACE, value: "}", line: 8, column: 3 },
      Token { type: RBRACE, value: "}", line: 9, column: 1 },
      Token { type: EOF, value: "", line: 9, column: 2 }
    ]

    # Conditional test tokens: if x > 0 { emit positive {} } else { emit negative {} }
    CONDITIONAL_TOKENS = [
      Token { type: NETWORK, value: "network", line: 1, column: 1 },
      Token { type: IDENTIFIER, value: "Test", line: 1, column: 9 },
      Token { type: LBRACE, value: "{", line: 1, column: 14 },
      Token { type: FREQUENCIES, value: "frequencies", line: 2, column: 3 },
      Token { type: LBRACE, value: "{", line: 2, column: 15 },
      Token { type: IDENTIFIER, value: "positive", line: 3, column: 5 },
      Token { type: LBRACE, value: "{", line: 3, column: 14 },
      Token { type: RBRACE, value: "}", line: 3, column: 15 },
      Token { type: IDENTIFIER, value: "negative", line: 4, column: 5 },
      Token { type: LBRACE, value: "{", line: 4, column: 14 },
      Token { type: RBRACE, value: "}", line: 4, column: 15 },
      Token { type: RBRACE, value: "}", line: 5, column: 3 },
      Token { type: HYPHAE, value: "hyphae", line: 6, column: 3 },
      Token { type: LBRACE, value: "{", line: 6, column: 10 },
      Token { type: HYPHAL, value: "hyphal", line: 7, column: 5 },
      Token { type: IDENTIFIER, value: "checker", line: 7, column: 12 },
      Token { type: LBRACE, value: "{", line: 7, column: 20 },
      Token { type: STATE, value: "state", line: 8, column: 7 },
      Token { type: LBRACE, value: "{", line: 8, column: 13 },
      Token { type: IDENTIFIER, value: "x", line: 9, column: 9 },
      Token { type: COLON, value: ":", line: 9, column: 10 },
      Token { type: IDENTIFIER, value: "i32", line: 9, column: 12 },
      Token { type: ASSIGN, value: "=", line: 9, column: 16 },
      Token { type: NUMBER, value: "5", line: 9, column: 18 },
      Token { type: RBRACE, value: "}", line: 10, column: 7 },
      Token { type: ON, value: "on", line: 11, column: 7 },
      Token { type: REST, value: "rest", line: 11, column: 10 },
      Token { type: LBRACE, value: "{", line: 11, column: 15 },
      Token { type: IF, value: "if", line: 12, column: 9 },
      Token { type: IDENTIFIER, value: "state", line: 12, column: 12 },
      Token { type: DOT, value: ".", line: 12, column: 17 },
      Token { type: IDENTIFIER, value: "x", line: 12, column: 18 },
      Token { type: GT, value: ">", line: 12, column: 20 },
      Token { type: NUMBER, value: "0", line: 12, column: 22 },
      Token { type: LBRACE, value: "{", line: 12, column: 24 },
      Token { type: EMIT, value: "emit", line: 13, column: 11 },
      Token { type: IDENTIFIER, value: "positive", line: 13, column: 16 },
      Token { type: LBRACE, value: "{", line: 13, column: 25 },
      Token { type: RBRACE, value: "}", line: 13, column: 26 },
      Token { type: RBRACE, value: "}", line: 14, column: 9 },
      Token { type: ELSE, value: "else", line: 14, column: 11 },
      Token { type: LBRACE, value: "{", line: 14, column: 16 },
      Token { type: EMIT, value: "emit", line: 15, column: 11 },
      Token { type: IDENTIFIER, value: "negative", line: 15, column: 16 },
      Token { type: LBRACE, value: "{", line: 15, column: 25 },
      Token { type: RBRACE, value: "}", line: 15, column: 26 },
      Token { type: RBRACE, value: "}", line: 16, column: 9 },
      Token { type: RBRACE, value: "}", line: 17, column: 7 },
      Token { type: RBRACE, value: "}", line: 18, column: 5 },
      Token { type: RBRACE, value: "}", line: 19, column: 3 },
      Token { type: RBRACE, value: "}", line: 20, column: 1 },
      Token { type: EOF, value: "", line: 20, column: 2 }
    ]
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TEST RUNNER AGENT
  # ═══════════════════════════════════════════════════════════════════════════

  hyphae {
    hyphal parser_test_runner {
      frequency tidal_cycle

      state {
        current_test: string
        test_tokens: vec<Token>
        received_ast: Program
        error_count: u32
        results: vec<parser_test_result>
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TEST EXECUTION
      # ─────────────────────────────────────────────────────────────────────────

      on signal(run_parser_test, test) {
        state.current_test = test.test_name
        state.error_count = 0

        match test.test_name {
          "hello_world" => {
            state.test_tokens = HELLO_WORLD_TOKENS
          }
          "expression_precedence" => {
            state.test_tokens = EXPR_PRECEDENCE_TOKENS
          }
          "conditional" => {
            state.test_tokens = CONDITIONAL_TOKENS
          }
          _ => {
            emit parser_test_result {
              test_name: test.test_name,
              passed: false,
              message: format("Unknown test: {}", test.test_name),
              ast_summary: ""
            }
            return
          }
        }

        # Send tokens to parser
        for tok in state.test_tokens {
          emit token {
            type: tok.type,
            value: tok.value,
            line: tok.line,
            column: tok.column
          }
        }

        emit lex_complete {
          token_count: vec_len(state.test_tokens)
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # CAPTURE RESULTS
      # ─────────────────────────────────────────────────────────────────────────

      on signal(ast_complete, ast) {
        state.received_ast = ast.program
        verify_test()
      }

      on signal(parse_error, err) {
        state.error_count = state.error_count + 1
      }

      on signal(parse_complete, done) {
        if state.error_count > 0 && state.current_test != "" {
          emit parser_test_result {
            test_name: state.current_test,
            passed: false,
            message: format("Parse errors: {}", state.error_count),
            ast_summary: ""
          }
          state.current_test = ""
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # VERIFICATION
      # ─────────────────────────────────────────────────────────────────────────

      rule verify_test() {
        let passed = true
        let message = ""
        let summary = ""

        match state.current_test {
          "hello_world" => {
            let result = verify_hello_world()
            passed = result.passed
            message = result.message
            summary = result.summary
          }
          "expression_precedence" => {
            let result = verify_expression_precedence()
            passed = result.passed
            message = result.message
            summary = result.summary
          }
          "conditional" => {
            let result = verify_conditional()
            passed = result.passed
            message = result.message
            summary = result.summary
          }
        }

        let test_result = parser_test_result {
          test_name: state.current_test,
          passed: passed,
          message: message,
          ast_summary: summary
        }

        vec_push(state.results, test_result)
        emit parser_test_result {
          test_name: test_result.test_name,
          passed: test_result.passed,
          message: test_result.message,
          ast_summary: test_result.ast_summary
        }

        state.current_test = ""
      }

      rule verify_hello_world() -> { passed: boolean, message: string, summary: string } {
        let ast = state.received_ast

        # Check program has exactly one network item
        if vec_len(ast.items) != 1 {
          return {
            passed: false,
            message: format("Expected 1 program item, got {}", vec_len(ast.items)),
            summary: ""
          }
        }

        let item = ast.items[0]
        match item {
          ProgramItem::Network(net) => {
            # Check network name
            if net.name != "HelloWorld" {
              return {
                passed: false,
                message: format("Expected network name 'HelloWorld', got '{}'", net.name),
                summary: ""
              }
            }

            # Check frequencies
            if vec_len(net.frequencies) != 2 {
              return {
                passed: false,
                message: format("Expected 2 frequencies, got {}", vec_len(net.frequencies)),
                summary: ""
              }
            }

            # Check greeting frequency
            let greeting = net.frequencies[0]
            if greeting.name != "greeting" {
              return {
                passed: false,
                message: format("Expected first frequency 'greeting', got '{}'", greeting.name),
                summary: ""
              }
            }

            # Check hyphae
            if vec_len(net.hyphae) != 1 {
              return {
                passed: false,
                message: format("Expected 1 hyphal, got {}", vec_len(net.hyphae)),
                summary: ""
              }
            }

            let hyphal = net.hyphae[0]
            if hyphal.name != "greeter" {
              return {
                passed: false,
                message: format("Expected hyphal 'greeter', got '{}'", hyphal.name),
                summary: ""
              }
            }

            # Check rules
            if vec_len(hyphal.rules) != 1 {
              return {
                passed: false,
                message: format("Expected 1 rule, got {}", vec_len(hyphal.rules)),
                summary: ""
              }
            }

            let rule = hyphal.rules[0]
            match rule.trigger {
              RuleTrigger::Signal(sig) => {
                if sig.frequency != "greeting" {
                  return {
                    passed: false,
                    message: format("Expected signal 'greeting', got '{}'", sig.frequency),
                    summary: ""
                  }
                }
              }
              _ => {
                return {
                  passed: false,
                  message: "Expected Signal trigger",
                  summary: ""
                }
              }
            }

            # Check emit statement
            if vec_len(rule.body) != 1 {
              return {
                passed: false,
                message: format("Expected 1 statement, got {}", vec_len(rule.body)),
                summary: ""
              }
            }

            let stmt = rule.body[0]
            match stmt {
              Statement::Emit(emit) => {
                if emit.frequency != "response" {
                  return {
                    passed: false,
                    message: format("Expected emit 'response', got '{}'", emit.frequency),
                    summary: ""
                  }
                }
              }
              _ => {
                return {
                  passed: false,
                  message: "Expected Emit statement",
                  summary: ""
                }
              }
            }

            return {
              passed: true,
              message: "hello_world.mycelial parsed correctly",
              summary: format("Network '{}' with {} frequencies, {} hyphae",
                              net.name, vec_len(net.frequencies), vec_len(net.hyphae))
            }
          }
          _ => {
            return {
              passed: false,
              message: "Expected Network item",
              summary: ""
            }
          }
        }
      }

      rule verify_expression_precedence() -> { passed: boolean, message: string, summary: string } {
        let ast = state.received_ast

        # Find the let statement and check expression structure
        # Expected: 1 + (2 * 3) due to precedence

        if vec_len(ast.items) != 1 {
          return {
            passed: false,
            message: "Expected 1 program item",
            summary: ""
          }
        }

        match ast.items[0] {
          ProgramItem::Network(net) => {
            if vec_len(net.hyphae) != 1 {
              return { passed: false, message: "Expected 1 hyphal", summary: "" }
            }

            let hyphal = net.hyphae[0]
            if vec_len(hyphal.rules) != 1 {
              return { passed: false, message: "Expected 1 rule", summary: "" }
            }

            let rule = hyphal.rules[0]
            if vec_len(rule.body) != 1 {
              return { passed: false, message: "Expected 1 statement", summary: "" }
            }

            match rule.body[0] {
              Statement::Let(let_stmt) => {
                # Check expression is Add(1, Mul(2, 3))
                match let_stmt.value {
                  Expression::BinaryOp(binop) => {
                    if binop.op != BinaryOperator::Add {
                      return {
                        passed: false,
                        message: "Top-level operator should be Add",
                        summary: ""
                      }
                    }

                    match binop.right {
                      Expression::BinaryOp(right_binop) => {
                        if right_binop.op != BinaryOperator::Mul {
                          return {
                            passed: false,
                            message: "Right subtree should be Mul (precedence)",
                            summary: ""
                          }
                        }

                        return {
                          passed: true,
                          message: "Operator precedence correct: 1 + (2 * 3)",
                          summary: "Add(1, Mul(2, 3))"
                        }
                      }
                      _ => {
                        return {
                          passed: false,
                          message: "Right operand should be BinaryOp",
                          summary: ""
                        }
                      }
                    }
                  }
                  _ => {
                    return {
                      passed: false,
                      message: "Expected BinaryOp expression",
                      summary: ""
                    }
                  }
                }
              }
              _ => {
                return { passed: false, message: "Expected Let statement", summary: "" }
              }
            }
          }
          _ => {
            return { passed: false, message: "Expected Network", summary: "" }
          }
        }
      }

      rule verify_conditional() -> { passed: boolean, message: string, summary: string } {
        let ast = state.received_ast

        if vec_len(ast.items) != 1 {
          return { passed: false, message: "Expected 1 program item", summary: "" }
        }

        match ast.items[0] {
          ProgramItem::Network(net) => {
            if vec_len(net.hyphae) != 1 {
              return { passed: false, message: "Expected 1 hyphal", summary: "" }
            }

            let hyphal = net.hyphae[0]
            if vec_len(hyphal.rules) != 1 {
              return { passed: false, message: "Expected 1 rule", summary: "" }
            }

            let rule = hyphal.rules[0]
            if vec_len(rule.body) != 1 {
              return { passed: false, message: "Expected 1 statement", summary: "" }
            }

            match rule.body[0] {
              Statement::Conditional(cond) => {
                # Check condition is state.x > 0
                match cond.condition {
                  Expression::BinaryOp(binop) => {
                    if binop.op != BinaryOperator::Gt {
                      return {
                        passed: false,
                        message: "Condition should be > comparison",
                        summary: ""
                      }
                    }
                  }
                  _ => {
                    return {
                      passed: false,
                      message: "Expected BinaryOp condition",
                      summary: ""
                    }
                  }
                }

                # Check then and else branches exist
                if vec_len(cond.then_body) != 1 {
                  return {
                    passed: false,
                    message: format("Expected 1 then statement, got {}", vec_len(cond.then_body)),
                    summary: ""
                  }
                }

                if vec_len(cond.else_body) != 1 {
                  return {
                    passed: false,
                    message: format("Expected 1 else statement, got {}", vec_len(cond.else_body)),
                    summary: ""
                  }
                }

                return {
                  passed: true,
                  message: "Conditional parsed correctly with both branches",
                  summary: "if state.x > 0 { emit positive } else { emit negative }"
                }
              }
              _ => {
                return {
                  passed: false,
                  message: "Expected Conditional statement",
                  summary: ""
                }
              }
            }
          }
          _ => {
            return { passed: false, message: "Expected Network", summary: "" }
          }
        }
      }
    }

    # ─────────────────────────────────────────────────────────────────────────
    # TEST REPORTER
    # ─────────────────────────────────────────────────────────────────────────

    hyphal parser_test_reporter {
      frequency tidal_cycle

      state {
        total: u32
        passed: u32
        failed: u32
      }

      on signal(parser_test_result, result) {
        state.total = state.total + 1
        if result.passed {
          state.passed = state.passed + 1
          log_info(format("  [PASS] {} - {}", result.test_name, result.message))
          if result.ast_summary != "" {
            log_info(format("         AST: {}", result.ast_summary))
          }
        } else {
          state.failed = state.failed + 1
          log_error(format("  [FAIL] {} - {}", result.test_name, result.message))
        }
      }

      on signal(all_parser_tests_complete, summary) {
        log_info("")
        log_info("════════════════════════════════════════════════")
        log_info("  PARSER TEST SUMMARY")
        log_info("════════════════════════════════════════════════")
        log_info(format("  Total:  {}", state.total))
        log_info(format("  Passed: {} [PASS]", state.passed))
        log_info(format("  Failed: {} [FAIL]", state.failed))
        log_info("════════════════════════════════════════════════")

        if state.failed == 0 {
          log_info("  ALL PARSER TESTS PASSED!")
        } else {
          log_error(format("  {} PARSER TESTS FAILED", state.failed))
        }
      }
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TOPOLOGY
  # ═══════════════════════════════════════════════════════════════════════════

  topology {
    spawn parser::Parser as Parser
    spawn parser_test_runner as Runner
    spawn parser_test_reporter as Reporter

    fruiting_body test_control
    fruiting_body test_results

    # Test control
    socket test_control -> Runner (frequency: run_parser_test)

    # Runner to Parser
    socket Runner -> Parser (frequency: token)
    socket Runner -> Parser (frequency: lex_complete)

    # Parser output to Runner
    socket Parser -> Runner (frequency: ast_complete)
    socket Parser -> Runner (frequency: parse_error)
    socket Parser -> Runner (frequency: parse_complete)

    # Results
    socket Runner -> Reporter (frequency: parser_test_result)
    socket Runner -> Reporter (frequency: all_parser_tests_complete)
    socket Reporter -> test_results (frequency: all_parser_tests_complete)
  }
}

# ═══════════════════════════════════════════════════════════════════════════
# USAGE
# ═══════════════════════════════════════════════════════════════════════════
#
# To run parser tests:
#   1. Instantiate ParserTest network
#   2. Send: run_parser_test(test_name="hello_world")
#   3. Send: run_parser_test(test_name="expression_precedence")
#   4. Send: run_parser_test(test_name="conditional")
#   5. Monitor: parser_test_result signals
#
# Expected output:
#   [PASS] hello_world - hello_world.mycelial parsed correctly
#          AST: Network 'HelloWorld' with 2 frequencies, 1 hyphae
#   [PASS] expression_precedence - Operator precedence correct: 1 + (2 * 3)
#          AST: Add(1, Mul(2, 3))
#   [PASS] conditional - Conditional parsed correctly with both branches
#          AST: if state.x > 0 { emit positive } else { emit negative }
#
#   ════════════════════════════════════════════════
#     PARSER TEST SUMMARY
#   ════════════════════════════════════════════════
#     Total:  3
#     Passed: 3 [PASS]
#     Failed: 0 [FAIL]
#   ════════════════════════════════════════════════
#     ALL PARSER TESTS PASSED!
#
