# Code Generator Unit Tests
#
# Purpose: Test individual LIR instruction translations
# Each test verifies a specific opcode maps correctly to x86-64
#
# Test Coverage:
#   - Data movement: MOVE, CONST, LOAD, STORE
#   - Arithmetic: ADD, SUB, MUL, DIV, MOD, NEG
#   - Logical: AND, OR, XOR, NOT, SHL, SHR
#   - Comparison: CMP_EQ, CMP_NE, CMP_LT, CMP_LE, CMP_GT, CMP_GE
#   - Control flow: JUMP, BRANCH, RET, CALL
#   - Special: GET_FIELD_ADDR, BITCAST

network CodeGenUnitTests {

  import x86_codegen

  # ═══════════════════════════════════════════════════════════════════════════
  # TEST CASES
  # ═══════════════════════════════════════════════════════════════════════════

  constants {
    # Test: ADD instruction
    TEST_ADD = [
      IRInstruction { op: CONST, dst: "%a", src1: "10", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: CONST, dst: "%b", src1: "20", src2: "", type_size: 8, label: "" },
      IRInstruction { op: ADD, dst: "%c", src1: "%a", src2: "%b", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%c", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_ADD = [
      "movq $10",        # Load constant 10
      "movq $20",        # Load constant 20
      "addq",            # Add operation
      "movq %rbp, %rsp", # Epilogue
      "ret"              # Return
    ]

    # Test: MUL instruction (uses imul)
    TEST_MUL = [
      IRInstruction { op: CONST, dst: "%x", src1: "5", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: CONST, dst: "%y", src1: "7", src2: "", type_size: 8, label: "" },
      IRInstruction { op: MUL, dst: "%z", src1: "%x", src2: "%y", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%z", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_MUL = [
      "movq $5",         # Load constant 5
      "movq $7",         # Load constant 7
      "movq",            # Move to rax
      "imulq",           # Multiply
      "ret"
    ]

    # Test: DIV instruction (uses idiv with cqo)
    TEST_DIV = [
      IRInstruction { op: CONST, dst: "%n", src1: "100", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: CONST, dst: "%d", src1: "7", src2: "", type_size: 8, label: "" },
      IRInstruction { op: DIV, dst: "%q", src1: "%n", src2: "%d", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%q", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_DIV = [
      "cqo",             # Sign-extend rax to rdx:rax
      "idivq",           # Divide
      "ret"
    ]

    # Test: Comparison (uses cmp, setX, movzbq)
    TEST_CMP = [
      IRInstruction { op: CONST, dst: "%a", src1: "42", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: CONST, dst: "%b", src1: "42", src2: "", type_size: 8, label: "" },
      IRInstruction { op: CMP_EQ, dst: "%eq", src1: "%a", src2: "%b", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%eq", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_CMP = [
      "cmpq",            # Compare
      "sete %al",        # Set equal flag
      "movzbq %al",      # Zero-extend to 64-bit
      "ret"
    ]

    # Test: Shift operations
    TEST_SHIFT = [
      IRInstruction { op: CONST, dst: "%val", src1: "8", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: SHL, dst: "%shifted", src1: "%val", src2: "2", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%shifted", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_SHIFT = [
      "shlq $2",         # Shift left by 2 (immediate)
      "ret"
    ]

    # Test: Branch (conditional jump)
    TEST_BRANCH = [
      IRInstruction { op: CONST, dst: "%cond", src1: "1", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: BRANCH, dst: "bb_false", src1: "%cond", src2: "bb_true", type_size: 0, label: "" },
      IRInstruction { op: LABEL, dst: "", src1: "", src2: "", type_size: 0, label: "bb_true" },
      IRInstruction { op: CONST, dst: "%r", src1: "1", src2: "", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%r", src2: "", type_size: 8, label: "" },
      IRInstruction { op: LABEL, dst: "", src1: "", src2: "", type_size: 0, label: "bb_false" },
      IRInstruction { op: CONST, dst: "%r2", src1: "0", src2: "", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%r2", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_BRANCH = [
      "testq",           # Test condition
      "jnz bb_true",     # Jump if not zero
      "jmp bb_false",    # Jump to false label
      "bb_true:",        # True label
      "bb_false:"        # False label
    ]

    # Test: Function call with arguments
    TEST_CALL = [
      IRInstruction { op: CONST, dst: "%arg1", src1: "100", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: CONST, dst: "%arg2", src1: "200", src2: "", type_size: 8, label: "" },
      IRInstruction { op: CALL, dst: "%result", src1: "some_function", src2: "%arg1,%arg2", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%result", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_CALL = [
      "movq",            # Move args to registers
      "%rdi",            # First arg register
      "%rsi",            # Second arg register
      "call some_function", # Call instruction
      "%rax",            # Return value
      "ret"
    ]

    # Test: Memory operations (LOAD, STORE)
    TEST_MEMORY = [
      IRInstruction { op: CONST, dst: "%addr", src1: "0x1000", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: LOAD, dst: "%val", src1: "%addr", src2: "", type_size: 8, label: "" },
      IRInstruction { op: CONST, dst: "%new_val", src1: "42", src2: "", type_size: 8, label: "" },
      IRInstruction { op: STORE, dst: "%addr", src1: "%new_val", src2: "", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "", src2: "", type_size: 0, label: "" }
    ]

    EXPECTED_MEMORY = [
      "movq (",          # Load from memory (indirect)
      "movq",            # Store to memory
      ")",               # Memory operand bracket
      "ret"
    ]

    # Test: Field address calculation (LEA)
    TEST_LEA = [
      IRInstruction { op: CONST, dst: "%base", src1: "0x2000", src2: "", type_size: 8, label: "bb0" },
      IRInstruction { op: GET_FIELD_ADDR, dst: "%field", src1: "%base", src2: "16", type_size: 8, label: "" },
      IRInstruction { op: RET, dst: "", src1: "%field", src2: "", type_size: 8, label: "" }
    ]

    EXPECTED_LEA = [
      "leaq 16(",        # Load effective address with offset
      "ret"
    ]

    # All tests
    ALL_TESTS = [
      { name: "add", lir: TEST_ADD, expected: EXPECTED_ADD },
      { name: "mul", lir: TEST_MUL, expected: EXPECTED_MUL },
      { name: "div", lir: TEST_DIV, expected: EXPECTED_DIV },
      { name: "cmp", lir: TEST_CMP, expected: EXPECTED_CMP },
      { name: "shift", lir: TEST_SHIFT, expected: EXPECTED_SHIFT },
      { name: "branch", lir: TEST_BRANCH, expected: EXPECTED_BRANCH },
      { name: "call", lir: TEST_CALL, expected: EXPECTED_CALL },
      { name: "memory", lir: TEST_MEMORY, expected: EXPECTED_MEMORY },
      { name: "lea", lir: TEST_LEA, expected: EXPECTED_LEA }
    ]
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TEST RUNNER AGENT
  # ═══════════════════════════════════════════════════════════════════════════

  frequencies {
    run_all_tests {}

    unit_test_result {
      test_name: string
      passed: boolean
      expected: vec<string>
      actual: string
    }

    all_tests_complete {
      total: u32
      passed: u32
      failed: u32
    }
  }

  hyphae {
    hyphal unit_test_runner {
      frequency tidal_cycle

      state {
        current_test_idx: u32
        current_test_name: string
        current_expected: vec<string>
        asm_output: vec<AsmInstruction>
        running: boolean
        results: vec<unit_test_result>
      }

      on signal(run_all_tests, _) {
        state.current_test_idx = 0
        vec_clear(state.results)
        run_next_test()
      }

      rule run_next_test() {
        if state.current_test_idx >= vec_len(ALL_TESTS) {
          # All tests complete
          summarize_results()
          return
        }

        let test = ALL_TESTS[state.current_test_idx]
        state.current_test_name = test.name
        state.current_expected = test.expected
        state.running = true
        vec_clear(state.asm_output)

        # Emit function start
        emit ir_function_start {
          name: format("test_{}", test.name),
          params: vec_new(),
          return_type: I64
        }

        # Emit LIR instructions
        for lir in test.lir {
          emit ir_node { instruction: lir }
        }

        # Emit function end
        emit ir_function_end {
          name: format("test_{}", test.name)
        }
      }

      on signal(asm_instruction, asm) {
        if state.running {
          vec_push(state.asm_output, asm)
        }
      }

      on signal(codegen_complete, _) {
        if state.running {
          verify_current_test()
          state.running = false
          state.current_test_idx = state.current_test_idx + 1
          run_next_test()
        }
      }

      rule verify_current_test() {
        let asm_text = build_asm_text(state.asm_output)
        let all_patterns_found = true

        for pattern in state.current_expected {
          if !string_contains(asm_text, pattern) {
            all_patterns_found = false
            break
          }
        }

        let result = unit_test_result {
          test_name: state.current_test_name,
          passed: all_patterns_found,
          expected: state.current_expected,
          actual: asm_text
        }
        vec_push(state.results, result)

        emit unit_test_result {
          test_name: state.current_test_name,
          passed: all_patterns_found,
          expected: state.current_expected,
          actual: asm_text
        }
      }

      rule summarize_results() {
        let passed = 0u32
        let failed = 0u32

        for result in state.results {
          if result.passed {
            passed = passed + 1
          } else {
            failed = failed + 1
          }
        }

        emit all_tests_complete {
          total: vec_len(state.results),
          passed: passed,
          failed: failed
        }
      }

      rule build_asm_text(instructions: vec<AsmInstruction>) -> string {
        let lines: vec<string> = vec_new()
        for asm in instructions {
          if asm.label != "" {
            vec_push(lines, format("{}:", asm.label))
          }
          if asm.mnemonic != "" {
            let operands_str = string_join(asm.operands, ", ")
            vec_push(lines, format("{} {}", asm.mnemonic, operands_str))
          }
        }
        return string_join(lines, "\n")
      }
    }

    # ─────────────────────────────────────────────────────────────────────────
    # TEST REPORTER
    # ─────────────────────────────────────────────────────────────────────────

    hyphal unit_test_reporter {
      frequency tidal_cycle

      on signal(unit_test_result, result) {
        if result.passed {
          log_info(format("  ✓ {}", result.test_name))
        } else {
          log_error(format("  ✗ {} - Expected patterns not found", result.test_name))
          log_error(format("    Expected: {}", string_join(result.expected, ", ")))
          log_error(format("    Actual:\n{}", result.actual))
        }
      }

      on signal(all_tests_complete, summary) {
        log_info("")
        log_info(format("════════════════════════════════════════════════"))
        log_info(format("  UNIT TEST SUMMARY"))
        log_info(format("════════════════════════════════════════════════"))
        log_info(format("  Total:  {}", summary.total))
        log_info(format("  Passed: {} ✓", summary.passed))
        log_info(format("  Failed: {} ✗", summary.failed))
        log_info(format("════════════════════════════════════════════════"))

        if summary.failed == 0 {
          log_info("  ALL TESTS PASSED!")
        } else {
          log_error(format("  {} TESTS FAILED", summary.failed))
        }
      }
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TOPOLOGY
  # ═══════════════════════════════════════════════════════════════════════════

  topology {
    spawn x86_codegen::CodeGen as CodeGen
    spawn unit_test_runner as Runner
    spawn unit_test_reporter as Reporter

    fruiting_body test_control
    fruiting_body test_results

    # Test control
    socket test_control -> Runner (frequency: run_all_tests)

    # Runner to CodeGen
    socket Runner -> CodeGen (frequency: ir_node)
    socket Runner -> CodeGen (frequency: ir_function_start)
    socket Runner -> CodeGen (frequency: ir_function_end)

    # CodeGen output to Runner
    socket CodeGen -> Runner (frequency: asm_instruction)
    socket CodeGen -> Runner (frequency: codegen_complete)

    # Results
    socket Runner -> Reporter (frequency: unit_test_result)
    socket Runner -> Reporter (frequency: all_tests_complete)
    socket Reporter -> test_results (frequency: all_tests_complete)
  }
}

# ═══════════════════════════════════════════════════════════════════════════
# USAGE
# ═══════════════════════════════════════════════════════════════════════════
#
# To run unit tests:
#   1. Instantiate CodeGenUnitTests network
#   2. Send: run_all_tests{}
#   3. Monitor: unit_test_result signals for each test
#   4. Final: all_tests_complete signal with summary
#
# Expected output:
#   ✓ add
#   ✓ mul
#   ✓ div
#   ✓ cmp
#   ✓ shift
#   ✓ branch
#   ✓ call
#   ✓ memory
#   ✓ lea
#
#   ════════════════════════════════════════════════
#     UNIT TEST SUMMARY
#   ════════════════════════════════════════════════
#     Total:  9
#     Passed: 9 ✓
#     Failed: 0 ✗
#   ════════════════════════════════════════════════
#     ALL TESTS PASSED!
#
