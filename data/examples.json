{
  "examples": [
    {
      "id": "hello_world",
      "title": "Hello World",
      "description": "Start here - the simplest Mycelial program",
      "difficulty": "beginner",
      "code": "# Hello World in Mycelial\n# The simplest possible program: receive input, emit output.\n\nnetwork HelloWorld {\n  frequencies {\n    greeting {\n      name: string\n    }\n\n    response {\n      message: string\n    }\n  }\n\n  hyphae {\n    hyphal greeter {\n      on signal(greeting, g) {\n        emit response {\n          message: format(\"Hello, {}!\", g.name)\n        }\n      }\n    }\n  }\n\n  topology {\n    fruiting_body input\n    fruiting_body output\n\n    spawn greeter as G1\n\n    socket input -> G1 (frequency: greeting)\n    socket G1 -> output (frequency: response)\n  }\n}\n\n# USAGE:\n#   Send:    greeting(name=\"World\")\n#   Receive: response(message=\"Hello, World!\")"
    },
    {
      "id": "pipeline",
      "title": "Message Pipeline",
      "description": "Agents passing data through a chain - 3 stages of processing",
      "difficulty": "intermediate",
      "code": "# Pipeline Pattern in Mycelial\n# Sequential processing stages: each stage transforms data and passes to next\n\nnetwork Pipeline {\n  frequencies {\n    raw_data {\n      id: u32\n      payload: string\n    }\n\n    validated_data {\n      id: u32\n      payload: string\n    }\n\n    processed_data {\n      id: u32\n      result: i64\n    }\n\n    formatted_output {\n      id: u32\n      message: string\n    }\n  }\n\n  hyphae {\n    # Stage 1: Validation\n    hyphal validator {\n      state {\n        validated_count: u32 = 0\n        failed_count: u32 = 0\n      }\n\n      on signal(raw_data, d) {\n        if len(d.payload) > 0 && len(d.payload) <= 100 {\n          state.validated_count = state.validated_count + 1\n          emit validated_data {\n            id: d.id,\n            payload: d.payload\n          }\n        } else {\n          state.failed_count = state.failed_count + 1\n          report error: format(\"validation_failed_id_{}\", d.id)\n        }\n      }\n\n      on rest {\n        report validation_stats: state.validated_count\n      }\n    }\n\n    # Stage 2: Processing\n    hyphal processor {\n      state {\n        processed_count: u32 = 0\n      }\n\n      on signal(validated_data, d) {\n        let result = compute(d.payload)\n        state.processed_count = state.processed_count + 1\n\n        emit processed_data {\n          id: d.id,\n          result: result\n        }\n      }\n\n      on rest {\n        report processed_count: state.processed_count\n      }\n    }\n\n    # Stage 3: Formatting\n    hyphal formatter {\n      state {\n        formatted_count: u32 = 0\n      }\n\n      on signal(processed_data, d) {\n        state.formatted_count = state.formatted_count + 1\n\n        emit formatted_output {\n          id: d.id,\n          message: format(\"[{}] Result: {}\", d.id, d.result)\n        }\n      }\n\n      on rest {\n        report formatted_count: state.formatted_count\n      }\n    }\n  }\n\n  topology {\n    fruiting_body input\n    fruiting_body output\n\n    spawn validator as V\n    spawn processor as P\n    spawn formatter as F\n\n    # Pipeline: each stage feeds the next\n    socket input -> V (frequency: raw_data)\n    socket V -> P (frequency: validated_data)\n    socket P -> F (frequency: processed_data)\n    socket F -> output (frequency: formatted_output)\n  }\n}"
    },
    {
      "id": "map_reduce",
      "title": "Map Reduce",
      "description": "Distributed data processing - split, process in parallel, aggregate",
      "difficulty": "advanced",
      "code": "# Map-Reduce Pattern in Mycelial\n# Demonstrates data parallelism: split work, process in parallel, aggregate results\n\nnetwork MapReduce {\n  frequencies {\n    batch {\n      id: u32\n      data: vec<i64>\n    }\n\n    chunk {\n      task_id: u32\n      partition: u32\n      values: vec<i64>\n    }\n\n    partial_sum {\n      task_id: u32\n      worker_id: u32\n      sum: i64\n    }\n\n    final_result {\n      task_id: u32\n      total_sum: i64\n      count: u32\n    }\n  }\n\n  hyphae {\n    # Mapper: splits input into chunks and distributes\n    hyphal mapper {\n      state {\n        partitions: u32 = 3\n      }\n\n      on signal(batch, b) {\n        # Divide data into chunks\n        let chunk_size = len(b.data) / state.partitions\n\n        for i in 0..state.partitions {\n          let start = i * chunk_size\n          let end = (i + 1) * chunk_size\n          let chunk_data = b.data[start..end]\n\n          emit chunk {\n            task_id: b.id,\n            partition: i,\n            values: chunk_data\n          }\n        }\n      }\n    }\n\n    # Reducer: sums a chunk\n    hyphal reducer {\n      state {\n        worker_id: u32 = 0\n      }\n\n      on signal(chunk, c) {\n        let sum = sum(c.values)\n\n        emit partial_sum {\n          task_id: c.task_id,\n          worker_id: state.worker_id,\n          sum: sum\n        }\n      }\n    }\n\n    # Aggregator: collects partial results and produces final result\n    hyphal aggregator {\n      state {\n        partial_results: map<u32, vec<i64>> = {}\n        expected_partitions: u32 = 3\n      }\n\n      on signal(partial_sum, ps) {\n        # Store this partial result\n        if !state.partial_results.contains_key(ps.task_id) {\n          state.partial_results[ps.task_id] = []\n        }\n\n        state.partial_results[ps.task_id].push(ps.sum)\n\n        # Check if we have all partitions\n        if len(state.partial_results[ps.task_id]) == state.expected_partitions {\n          let total = sum(state.partial_results[ps.task_id])\n\n          emit final_result {\n            task_id: ps.task_id,\n            total_sum: total,\n            count: state.expected_partitions\n          }\n\n          state.partial_results.remove(ps.task_id)\n        }\n      }\n    }\n  }\n\n  topology {\n    fruiting_body input\n    fruiting_body output\n\n    spawn mapper as MAP\n    spawn reducer as R1\n    spawn reducer as R2\n    spawn reducer as R3\n    spawn aggregator as AGG\n\n    # Input to mapper\n    socket input -> MAP (frequency: batch)\n\n    # Mapper distributes chunks to reducers\n    socket MAP -> R1 (frequency: chunk)\n    socket MAP -> R2 (frequency: chunk)\n    socket MAP -> R3 (frequency: chunk)\n\n    # Reducers send partial results to aggregator\n    socket R1 -> AGG (frequency: partial_sum)\n    socket R2 -> AGG (frequency: partial_sum)\n    socket R3 -> AGG (frequency: partial_sum)\n\n    # Aggregator sends final result to output\n    socket AGG -> output (frequency: final_result)\n  }\n}"
    },
    {
      "id": "broadcast",
      "title": "Signal Broadcast",
      "description": "One agent, many listeners - fan-out communication pattern",
      "difficulty": "intermediate",
      "code": "# Broadcast Pattern in Mycelial\n# One broadcaster sends to multiple listeners\n\nnetwork Broadcast {\n  frequencies {\n    announcement {\n      message: string\n      priority: u32\n    }\n\n    ack {\n      listener_id: string\n      received: boolean\n    }\n  }\n\n  hyphae {\n    # Broadcaster: sends messages to all\n    hyphal broadcaster {\n      state {\n        message_count: u32 = 0\n      }\n\n      on cycle(10) {\n        state.message_count = state.message_count + 1\n        emit announcement {\n          message: format(\"Broadcast #{}\", state.message_count),\n          priority: 1\n        }\n      }\n    }\n\n    # Listener: receives and acknowledges\n    hyphal listener {\n      state {\n        id: string = \"unknown\"\n        received_count: u32 = 0\n      }\n\n      on signal(announcement, a) {\n        state.received_count = state.received_count + 1\n        report received: format(\"{} got: {}\", state.id, a.message)\n\n        emit ack {\n          listener_id: state.id,\n          received: true\n        }\n      }\n    }\n  }\n\n  topology {\n    fruiting_body output\n\n    spawn broadcaster as B\n    spawn listener as L1\n    spawn listener as L2\n    spawn listener as L3\n\n    # Broadcaster sends to all listeners\n    socket B -> L1 (frequency: announcement)\n    socket B -> L2 (frequency: announcement)\n    socket B -> L3 (frequency: announcement)\n\n    # Listeners acknowledge\n    socket L1 -> output (frequency: ack)\n    socket L2 -> output (frequency: ack)\n    socket L3 -> output (frequency: ack)\n  }\n}"
    }
  ]
}
