# Parser Agent
#
# Owner: Opus (Claude Opus 4.5)
# Purpose: Transform token stream into Abstract Syntax Tree (AST)
# Input: token signals from Lexer Agent
# Output: ast_node signals to Type Checker Agent
#
# Implementation: Recursive Descent Parser with Precedence Climbing
#
# Reference: /home/lewey/Desktop/MyLanguage/01-SPECIFICATION/GRAMMAR.md

network parser {

  # ═══════════════════════════════════════════════════════════════════════════
  # FREQUENCY DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  frequencies {
    # Input signals (from Lexer)
    token {
      type: TokenType
      value: string
      line: u32
      column: u32
    }

    lex_complete {
      token_count: u32
    }

    # Output signals (to Type Checker)
    ast_node {
      node_type: ASTNodeType
      location: SourceLocation
      data: NodeData
    }

    ast_complete {
      program: Program
    }

    parse_error {
      message: string
      location: SourceLocation
      expected: string
      found: string
    }

    parse_complete {
      program_id: u32
      error_count: u32
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TYPE DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  types {
    # ─────────────────────────────────────────────────────────────────────────
    # Token Types (from Lexer)
    # ─────────────────────────────────────────────────────────────────────────

    enum TokenType {
      # Keywords
      NETWORK, FREQUENCY, FREQUENCIES, HYPHAL, HYPHAE, STATE, ON, SIGNAL,
      REST, CYCLE, EMIT, REPORT, SPAWN, DIE, IF, ELSE, LET, WHERE,
      TOPOLOGY, SOCKET, FRUITING_BODY, IMPORT, TYPES, STRUCT, ENUM,
      CONSTANTS, CONFIG,

      # Literals
      NUMBER, STRING_LIT, TRUE, FALSE,

      # Identifiers
      IDENTIFIER,

      # Operators
      PLUS, MINUS, STAR, SLASH, PERCENT,      # + - * / %
      EQ, NE, LT, GT, LE, GE,                 # == != < > <= >=
      AND, OR, NOT,                            # && || !
      ASSIGN, COLON, ARROW,                    # = : ->

      # Delimiters
      LPAREN, RPAREN,     # ( )
      LBRACE, RBRACE,     # { }
      LBRACKET, RBRACKET, # [ ]
      COMMA, DOT, SEMICOLON,

      # Special
      EOF, ERROR
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Source Location (for error reporting)
    # ─────────────────────────────────────────────────────────────────────────

    struct SourceLocation {
      line: u32
      column: u32
    }

    # ─────────────────────────────────────────────────────────────────────────
    # AST Node Types
    # ─────────────────────────────────────────────────────────────────────────

    enum ASTNodeType {
      PROGRAM, NETWORK_DEF, FREQUENCY_DEF, HYPHAL_DEF, STATE_BLOCK,
      STATE_FIELD, RULE, TOPOLOGY_RULE, SOCKET_DEF, FRUITING_BODY_DEF,
      STATEMENT, EXPRESSION, TYPE_REF, LITERAL
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Program (Top Level)
    # ─────────────────────────────────────────────────────────────────────────

    struct Program {
      items: vec<ProgramItem>
      location: SourceLocation
    }

    enum ProgramItem {
      Frequency(FrequencyDef),
      Network(NetworkDef),
      Import(ImportDef)
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Definitions
    # ─────────────────────────────────────────────────────────────────────────

    struct ImportDef {
      path: string
      location: SourceLocation
    }

    struct FrequencyDef {
      name: string
      fields: vec<FieldDef>
      location: SourceLocation
    }

    struct FieldDef {
      name: string
      field_type: TypeRef
      location: SourceLocation
    }

    struct NetworkDef {
      name: string
      frequencies: vec<FrequencyDef>
      types: vec<TypeDef>
      constants: vec<ConstantDef>
      hyphae: vec<HyphalDef>
      topology: vec<TopologyItem>
      config: vec<ConfigItem>
      location: SourceLocation
    }

    struct TypeDef {
      name: string
      type_kind: TypeDefKind
      location: SourceLocation
    }

    enum TypeDefKind {
      Struct(vec<FieldDef>),
      Enum(vec<EnumVariant>)
    }

    struct EnumVariant {
      name: string
      fields: vec<FieldDef>
      location: SourceLocation
    }

    struct ConstantDef {
      name: string
      value: Expression
      location: SourceLocation
    }

    struct ConfigItem {
      key: string
      value: Expression
      location: SourceLocation
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Hyphal (Agent) Definitions
    # ─────────────────────────────────────────────────────────────────────────

    struct HyphalDef {
      name: string
      frequency_ref: string       # Optional: "frequency X"
      state: StateBlock
      rules: vec<Rule>
      location: SourceLocation
    }

    struct StateBlock {
      fields: vec<StateField>
      location: SourceLocation
    }

    struct StateField {
      name: string
      field_type: TypeRef
      init_value: Expression      # Optional initial value
      location: SourceLocation
    }

    struct Rule {
      trigger: RuleTrigger
      guard: Expression           # Optional "where" predicate
      body: vec<Statement>
      location: SourceLocation
    }

    enum RuleTrigger {
      Signal(SignalMatch),
      Rest,
      Cycle(u32)
    }

    struct SignalMatch {
      frequency: string
      binding: string             # Variable binding name
      location: SourceLocation
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Topology
    # ─────────────────────────────────────────────────────────────────────────

    enum TopologyItem {
      Spawn(SpawnDef),
      Socket(SocketDef),
      FruitingBody(FruitingBodyDef)
    }

    struct SpawnDef {
      hyphal: string
      instance: string
      location: SourceLocation
    }

    struct SocketDef {
      from: string
      to: string
      frequency: string
      location: SourceLocation
    }

    struct FruitingBodyDef {
      name: string
      location: SourceLocation
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Statements
    # ─────────────────────────────────────────────────────────────────────────

    enum Statement {
      Let(LetStatement),
      Assignment(AssignmentStatement),
      Conditional(ConditionalStatement),
      Emit(EmitStatement),
      Report(ReportStatement),
      Spawn(SpawnStatement),
      Die(DieStatement),
      ForLoop(ForLoopStatement),
      WhileLoop(WhileLoopStatement),
      Return(ReturnStatement),
      Break(BreakStatement),
      Continue(ContinueStatement),
      Expression(ExpressionStatement)
    }

    struct LetStatement {
      name: string
      type_annotation: TypeRef    # Optional
      value: Expression
      location: SourceLocation
    }

    struct AssignmentStatement {
      target: AssignmentTarget
      value: Expression
      location: SourceLocation
    }

    enum AssignmentTarget {
      Variable(string),
      StateField(string),
      FieldAccess(Expression, string),
      IndexAccess(Expression, Expression)
    }

    struct ConditionalStatement {
      condition: Expression
      then_body: vec<Statement>
      else_body: vec<Statement>   # Empty if no else
      location: SourceLocation
    }

    struct EmitStatement {
      frequency: string
      fields: vec<FieldInit>
      location: SourceLocation
    }

    struct FieldInit {
      name: string
      value: Expression
      location: SourceLocation
    }

    struct ReportStatement {
      metric: string
      value: Expression
      location: SourceLocation
    }

    struct SpawnStatement {
      hyphal: string
      instance: string
      location: SourceLocation
    }

    struct DieStatement {
      location: SourceLocation
    }

    struct ForLoopStatement {
      variable: string
      iterable: Expression
      body: vec<Statement>
      location: SourceLocation
    }

    struct WhileLoopStatement {
      condition: Expression
      body: vec<Statement>
      location: SourceLocation
    }

    struct ReturnStatement {
      value: Expression           # Optional
      location: SourceLocation
    }

    struct BreakStatement {
      location: SourceLocation
    }

    struct ContinueStatement {
      location: SourceLocation
    }

    struct ExpressionStatement {
      expression: Expression
      location: SourceLocation
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Expressions
    # ─────────────────────────────────────────────────────────────────────────

    enum Expression {
      Literal(LiteralExpr),
      Identifier(IdentifierExpr),
      BinaryOp(BinaryOpExpr),
      UnaryOp(UnaryOpExpr),
      FieldAccess(FieldAccessExpr),
      IndexAccess(IndexAccessExpr),
      Call(CallExpr),
      MethodCall(MethodCallExpr),
      StateAccess(StateAccessExpr),
      SignalAccess(SignalAccessExpr),
      ListLiteral(ListLiteralExpr),
      MapLiteral(MapLiteralExpr),
      StructLiteral(StructLiteralExpr),
      Grouped(GroupedExpr),
      None
    }

    struct LiteralExpr {
      value: Literal
      location: SourceLocation
    }

    struct IdentifierExpr {
      name: string
      location: SourceLocation
    }

    struct BinaryOpExpr {
      op: BinaryOperator
      left: Expression
      right: Expression
      location: SourceLocation
    }

    enum BinaryOperator {
      # Arithmetic
      Add, Sub, Mul, Div, Mod,
      # Comparison
      Eq, Ne, Lt, Gt, Le, Ge,
      # Logical
      And, Or
    }

    struct UnaryOpExpr {
      op: UnaryOperator
      operand: Expression
      location: SourceLocation
    }

    enum UnaryOperator {
      Not, Neg, Pos
    }

    struct FieldAccessExpr {
      object: Expression
      field: string
      location: SourceLocation
    }

    struct IndexAccessExpr {
      object: Expression
      index: Expression
      location: SourceLocation
    }

    struct CallExpr {
      name: string
      args: vec<Expression>
      location: SourceLocation
    }

    struct MethodCallExpr {
      object: Expression
      method: string
      args: vec<Expression>
      location: SourceLocation
    }

    struct StateAccessExpr {
      field: string
      location: SourceLocation
    }

    struct SignalAccessExpr {
      binding: string
      field: string
      location: SourceLocation
    }

    struct ListLiteralExpr {
      elements: vec<Expression>
      location: SourceLocation
    }

    struct MapLiteralExpr {
      entries: vec<MapEntry>
      location: SourceLocation
    }

    struct MapEntry {
      key: Expression
      value: Expression
      location: SourceLocation
    }

    struct StructLiteralExpr {
      type_name: string
      fields: vec<FieldInit>
      location: SourceLocation
    }

    struct GroupedExpr {
      inner: Expression
      location: SourceLocation
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Literals
    # ─────────────────────────────────────────────────────────────────────────

    enum Literal {
      Number(i64),
      Float(f64),
      String(string),
      Bool(boolean),
      Null
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Type References
    # ─────────────────────────────────────────────────────────────────────────

    enum TypeRef {
      Primitive(PrimitiveType),
      Vec(TypeRef),
      Queue(TypeRef),
      Map(TypeRef, TypeRef),
      Custom(string),
      None
    }

    enum PrimitiveType {
      U8, U16, U32, U64,
      I8, I16, I32, I64,
      F32, F64,
      Boolean, String, Binary
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # PARSER AGENT
  # ═══════════════════════════════════════════════════════════════════════════

  hyphae {
    hyphal parser {
      frequency tidal_cycle

      state {
        # Token buffer
        tokens: vec<Token>
        current: u32

        # Error tracking
        errors: vec<ParseError>
        panic_mode: boolean

        # Output
        program: Program

        # Parsing state
        in_rule_body: boolean
        current_binding: string    # Signal binding in scope
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TOKEN BUFFER MANAGEMENT
      # ─────────────────────────────────────────────────────────────────────────

      on signal(token, t) {
        # Buffer tokens as they arrive
        vec_push(state.tokens, Token {
          type: t.type,
          value: t.value,
          line: t.line,
          column: t.column
        })
      }

      on signal(lex_complete, lc) {
        # All tokens received - start parsing
        state.current = 0
        state.panic_mode = false
        vec_clear(state.errors)

        # Parse the program
        let program = parse_program()

        # Emit result
        if vec_len(state.errors) == 0 {
          emit ast_complete {
            program: program
          }
        }

        emit parse_complete {
          program_id: 1,
          error_count: vec_len(state.errors)
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TOKEN HELPERS
      # ─────────────────────────────────────────────────────────────────────────

      rule peek() -> Token {
        if state.current >= vec_len(state.tokens) {
          return Token { type: EOF, value: "", line: 0, column: 0 }
        }
        return state.tokens[state.current]
      }

      rule peek_ahead(n: u32) -> Token {
        let idx = state.current + n
        if idx >= vec_len(state.tokens) {
          return Token { type: EOF, value: "", line: 0, column: 0 }
        }
        return state.tokens[idx]
      }

      rule advance() -> Token {
        let tok = peek()
        if tok.type != EOF {
          state.current = state.current + 1
        }
        return tok
      }

      rule check(expected: TokenType) -> boolean {
        return peek().type == expected
      }

      rule match_token(expected: TokenType) -> boolean {
        if check(expected) {
          advance()
          return true
        }
        return false
      }

      rule expect(expected: TokenType, message: string) -> Token {
        if check(expected) {
          return advance()
        }
        error(message, expected)
        return Token { type: ERROR, value: "", line: peek().line, column: peek().column }
      }

      rule current_location() -> SourceLocation {
        let tok = peek()
        return SourceLocation { line: tok.line, column: tok.column }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # ERROR HANDLING
      # ─────────────────────────────────────────────────────────────────────────

      rule error(message: string, expected: TokenType) {
        let tok = peek()
        let err = ParseError {
          message: message,
          location: SourceLocation { line: tok.line, column: tok.column },
          expected: token_type_to_string(expected),
          found: tok.value
        }
        vec_push(state.errors, err)

        emit parse_error {
          message: message,
          location: err.location,
          expected: err.expected,
          found: err.found
        }

        state.panic_mode = true
      }

      rule synchronize() {
        state.panic_mode = false
        advance()

        while !check(EOF) {
          # Synchronize at statement boundaries
          match peek().type {
            NETWORK | FREQUENCY | HYPHAL | ON | EMIT | IF | LET => {
              return
            }
            _ => {
              advance()
            }
          }
        }
      }

      rule token_type_to_string(tt: TokenType) -> string {
        match tt {
          NETWORK => "network"
          FREQUENCY => "frequency"
          FREQUENCIES => "frequencies"
          HYPHAL => "hyphal"
          HYPHAE => "hyphae"
          STATE => "state"
          ON => "on"
          SIGNAL => "signal"
          REST => "rest"
          CYCLE => "cycle"
          EMIT => "emit"
          REPORT => "report"
          SPAWN => "spawn"
          DIE => "die"
          IF => "if"
          ELSE => "else"
          LET => "let"
          WHERE => "where"
          TOPOLOGY => "topology"
          SOCKET => "socket"
          FRUITING_BODY => "fruiting_body"
          LBRACE => "{"
          RBRACE => "}"
          LPAREN => "("
          RPAREN => ")"
          COMMA => ","
          COLON => ":"
          IDENTIFIER => "identifier"
          NUMBER => "number"
          STRING_LIT => "string"
          EOF => "end of file"
          _ => "token"
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # PROGRAM PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_program() -> Program {
        let items: vec<ProgramItem> = vec_new()
        let loc = current_location()

        while !check(EOF) {
          let item = parse_program_item()
          if item != None {
            vec_push(items, item)
          }

          if state.panic_mode {
            synchronize()
          }
        }

        return Program { items: items, location: loc }
      }

      rule parse_program_item() -> ProgramItem {
        match peek().type {
          NETWORK => {
            return ProgramItem::Network(parse_network_def())
          }
          FREQUENCY => {
            return ProgramItem::Frequency(parse_frequency_def())
          }
          IMPORT => {
            return ProgramItem::Import(parse_import_def())
          }
          _ => {
            error("Expected 'network', 'frequency', or 'import'", NETWORK)
            return None
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # NETWORK PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_network_def() -> NetworkDef {
        let loc = current_location()
        expect(NETWORK, "Expected 'network'")

        let name_tok = expect(IDENTIFIER, "Expected network name")
        let name = name_tok.value

        expect(LBRACE, "Expected '{' after network name")

        let frequencies: vec<FrequencyDef> = vec_new()
        let types: vec<TypeDef> = vec_new()
        let constants: vec<ConstantDef> = vec_new()
        let hyphae: vec<HyphalDef> = vec_new()
        let topology: vec<TopologyItem> = vec_new()
        let config: vec<ConfigItem> = vec_new()

        while !check(RBRACE) && !check(EOF) {
          match peek().type {
            FREQUENCIES => {
              advance()
              expect(LBRACE, "Expected '{' after 'frequencies'")
              while !check(RBRACE) && !check(EOF) {
                vec_push(frequencies, parse_inline_frequency_def())
              }
              expect(RBRACE, "Expected '}' to close frequencies block")
            }
            TYPES => {
              advance()
              expect(LBRACE, "Expected '{' after 'types'")
              while !check(RBRACE) && !check(EOF) {
                vec_push(types, parse_type_def())
              }
              expect(RBRACE, "Expected '}' to close types block")
            }
            CONSTANTS => {
              advance()
              expect(LBRACE, "Expected '{' after 'constants'")
              while !check(RBRACE) && !check(EOF) {
                vec_push(constants, parse_constant_def())
              }
              expect(RBRACE, "Expected '}' to close constants block")
            }
            HYPHAE => {
              advance()
              expect(LBRACE, "Expected '{' after 'hyphae'")
              while !check(RBRACE) && !check(EOF) {
                vec_push(hyphae, parse_hyphal_def())
              }
              expect(RBRACE, "Expected '}' to close hyphae block")
            }
            TOPOLOGY => {
              advance()
              expect(LBRACE, "Expected '{' after 'topology'")
              while !check(RBRACE) && !check(EOF) {
                vec_push(topology, parse_topology_item())
              }
              expect(RBRACE, "Expected '}' to close topology block")
            }
            CONFIG => {
              advance()
              expect(LBRACE, "Expected '{' after 'config'")
              while !check(RBRACE) && !check(EOF) {
                vec_push(config, parse_config_item())
              }
              expect(RBRACE, "Expected '}' to close config block")
            }
            _ => {
              error("Unexpected token in network definition", RBRACE)
              advance()
            }
          }
        }

        expect(RBRACE, "Expected '}' to close network")

        return NetworkDef {
          name: name,
          frequencies: frequencies,
          types: types,
          constants: constants,
          hyphae: hyphae,
          topology: topology,
          config: config,
          location: loc
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # FREQUENCY PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_frequency_def() -> FrequencyDef {
        let loc = current_location()
        expect(FREQUENCY, "Expected 'frequency'")

        let name_tok = expect(IDENTIFIER, "Expected frequency name")
        let name = name_tok.value

        expect(LBRACE, "Expected '{' after frequency name")

        let fields: vec<FieldDef> = vec_new()
        while !check(RBRACE) && !check(EOF) {
          vec_push(fields, parse_field_def())
        }

        expect(RBRACE, "Expected '}' to close frequency")

        return FrequencyDef {
          name: name,
          fields: fields,
          location: loc
        }
      }

      rule parse_inline_frequency_def() -> FrequencyDef {
        let loc = current_location()

        let name_tok = expect(IDENTIFIER, "Expected frequency name")
        let name = name_tok.value

        expect(LBRACE, "Expected '{' after frequency name")

        let fields: vec<FieldDef> = vec_new()
        while !check(RBRACE) && !check(EOF) {
          vec_push(fields, parse_field_def())
        }

        expect(RBRACE, "Expected '}' to close frequency")

        return FrequencyDef {
          name: name,
          fields: fields,
          location: loc
        }
      }

      rule parse_field_def() -> FieldDef {
        let loc = current_location()

        let name_tok = expect(IDENTIFIER, "Expected field name")
        let name = name_tok.value

        expect(COLON, "Expected ':' after field name")

        let field_type = parse_type_ref()

        return FieldDef {
          name: name,
          field_type: field_type,
          location: loc
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TYPE PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_type_ref() -> TypeRef {
        let tok = peek()

        match tok.value {
          "u8" => { advance(); return TypeRef::Primitive(PrimitiveType::U8) }
          "u16" => { advance(); return TypeRef::Primitive(PrimitiveType::U16) }
          "u32" => { advance(); return TypeRef::Primitive(PrimitiveType::U32) }
          "u64" => { advance(); return TypeRef::Primitive(PrimitiveType::U64) }
          "i8" => { advance(); return TypeRef::Primitive(PrimitiveType::I8) }
          "i16" => { advance(); return TypeRef::Primitive(PrimitiveType::I16) }
          "i32" => { advance(); return TypeRef::Primitive(PrimitiveType::I32) }
          "i64" => { advance(); return TypeRef::Primitive(PrimitiveType::I64) }
          "f32" => { advance(); return TypeRef::Primitive(PrimitiveType::F32) }
          "f64" => { advance(); return TypeRef::Primitive(PrimitiveType::F64) }
          "boolean" | "bool" => { advance(); return TypeRef::Primitive(PrimitiveType::Boolean) }
          "string" => { advance(); return TypeRef::Primitive(PrimitiveType::String) }
          "binary" => { advance(); return TypeRef::Primitive(PrimitiveType::Binary) }
          "vec" => {
            advance()
            expect(LT, "Expected '<' after 'vec'")
            let inner = parse_type_ref()
            expect(GT, "Expected '>' to close vec type")
            return TypeRef::Vec(inner)
          }
          "queue" => {
            advance()
            expect(LT, "Expected '<' after 'queue'")
            let inner = parse_type_ref()
            expect(GT, "Expected '>' to close queue type")
            return TypeRef::Queue(inner)
          }
          "map" => {
            advance()
            expect(LT, "Expected '<' after 'map'")
            let key = parse_type_ref()
            expect(COMMA, "Expected ',' between map key and value types")
            let val = parse_type_ref()
            expect(GT, "Expected '>' to close map type")
            return TypeRef::Map(key, val)
          }
          _ => {
            if tok.type == IDENTIFIER {
              advance()
              return TypeRef::Custom(tok.value)
            }
            error("Expected type", IDENTIFIER)
            return TypeRef::None
          }
        }
      }

      rule parse_type_def() -> TypeDef {
        let loc = current_location()

        if check(STRUCT) {
          advance()
          let name_tok = expect(IDENTIFIER, "Expected struct name")
          expect(LBRACE, "Expected '{' after struct name")

          let fields: vec<FieldDef> = vec_new()
          while !check(RBRACE) && !check(EOF) {
            vec_push(fields, parse_field_def())
          }
          expect(RBRACE, "Expected '}' to close struct")

          return TypeDef {
            name: name_tok.value,
            type_kind: TypeDefKind::Struct(fields),
            location: loc
          }
        } else if check(ENUM) {
          advance()
          let name_tok = expect(IDENTIFIER, "Expected enum name")
          expect(LBRACE, "Expected '{' after enum name")

          let variants: vec<EnumVariant> = vec_new()
          while !check(RBRACE) && !check(EOF) {
            vec_push(variants, parse_enum_variant())
            match_token(COMMA)  # Optional comma
          }
          expect(RBRACE, "Expected '}' to close enum")

          return TypeDef {
            name: name_tok.value,
            type_kind: TypeDefKind::Enum(variants),
            location: loc
          }
        } else {
          error("Expected 'struct' or 'enum'", STRUCT)
          return TypeDef { name: "", type_kind: TypeDefKind::Struct(vec_new()), location: loc }
        }
      }

      rule parse_enum_variant() -> EnumVariant {
        let loc = current_location()
        let name_tok = expect(IDENTIFIER, "Expected variant name")

        let fields: vec<FieldDef> = vec_new()
        if match_token(LPAREN) {
          while !check(RPAREN) && !check(EOF) {
            vec_push(fields, parse_field_def())
            if !check(RPAREN) {
              expect(COMMA, "Expected ',' between variant fields")
            }
          }
          expect(RPAREN, "Expected ')' to close variant fields")
        }

        return EnumVariant {
          name: name_tok.value,
          fields: fields,
          location: loc
        }
      }

      rule parse_constant_def() -> ConstantDef {
        let loc = current_location()
        let name_tok = expect(IDENTIFIER, "Expected constant name")
        expect(ASSIGN, "Expected '=' after constant name")
        let value = parse_expression()

        return ConstantDef {
          name: name_tok.value,
          value: value,
          location: loc
        }
      }

      rule parse_config_item() -> ConfigItem {
        let loc = current_location()
        let key_tok = expect(IDENTIFIER, "Expected config key")
        expect(COLON, "Expected ':' after config key")
        let value = parse_expression()

        return ConfigItem {
          key: key_tok.value,
          value: value,
          location: loc
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # HYPHAL PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_hyphal_def() -> HyphalDef {
        let loc = current_location()
        expect(HYPHAL, "Expected 'hyphal'")

        let name_tok = expect(IDENTIFIER, "Expected hyphal name")
        let name = name_tok.value

        # Optional frequency reference
        let freq_ref = ""
        if match_token(FREQUENCY) {
          let freq_tok = expect(IDENTIFIER, "Expected frequency name")
          freq_ref = freq_tok.value
        }

        expect(LBRACE, "Expected '{' after hyphal name")

        let state_block = StateBlock { fields: vec_new(), location: loc }
        let rules: vec<Rule> = vec_new()

        while !check(RBRACE) && !check(EOF) {
          match peek().type {
            STATE => {
              state_block = parse_state_block()
            }
            ON => {
              vec_push(rules, parse_rule())
            }
            _ => {
              error("Expected 'state' or 'on' in hyphal definition", ON)
              advance()
            }
          }
        }

        expect(RBRACE, "Expected '}' to close hyphal")

        return HyphalDef {
          name: name,
          frequency_ref: freq_ref,
          state: state_block,
          rules: rules,
          location: loc
        }
      }

      rule parse_state_block() -> StateBlock {
        let loc = current_location()
        expect(STATE, "Expected 'state'")
        expect(LBRACE, "Expected '{' after 'state'")

        let fields: vec<StateField> = vec_new()
        while !check(RBRACE) && !check(EOF) {
          vec_push(fields, parse_state_field())
        }

        expect(RBRACE, "Expected '}' to close state block")

        return StateBlock { fields: fields, location: loc }
      }

      rule parse_state_field() -> StateField {
        let loc = current_location()
        let name_tok = expect(IDENTIFIER, "Expected field name")
        expect(COLON, "Expected ':' after field name")
        let field_type = parse_type_ref()

        let init_value = Expression::None
        if match_token(ASSIGN) {
          init_value = parse_expression()
        }

        return StateField {
          name: name_tok.value,
          field_type: field_type,
          init_value: init_value,
          location: loc
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # RULE PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_rule() -> Rule {
        let loc = current_location()
        expect(ON, "Expected 'on'")

        let trigger = parse_rule_trigger()

        # Optional guard
        let guard = Expression::None
        if match_token(WHERE) {
          guard = parse_expression()
        }

        expect(LBRACE, "Expected '{' after rule trigger")

        state.in_rule_body = true
        let body = parse_statement_list()
        state.in_rule_body = false

        expect(RBRACE, "Expected '}' to close rule")

        return Rule {
          trigger: trigger,
          guard: guard,
          body: body,
          location: loc
        }
      }

      rule parse_rule_trigger() -> RuleTrigger {
        match peek().type {
          SIGNAL => {
            advance()
            expect(LPAREN, "Expected '(' after 'signal'")

            let freq_tok = expect(IDENTIFIER, "Expected frequency name")
            let frequency = freq_tok.value

            let binding = ""
            if match_token(COMMA) {
              let binding_tok = expect(IDENTIFIER, "Expected binding name")
              binding = binding_tok.value
              state.current_binding = binding
            }

            expect(RPAREN, "Expected ')' to close signal pattern")

            return RuleTrigger::Signal(SignalMatch {
              frequency: frequency,
              binding: binding,
              location: current_location()
            })
          }
          REST => {
            advance()
            return RuleTrigger::Rest
          }
          CYCLE => {
            advance()
            let num_tok = expect(NUMBER, "Expected cycle number")
            let num = parse_i64(num_tok.value)
            return RuleTrigger::Cycle(num as u32)
          }
          _ => {
            error("Expected 'signal', 'rest', or 'cycle'", SIGNAL)
            return RuleTrigger::Rest
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TOPOLOGY PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_topology_item() -> TopologyItem {
        match peek().type {
          SPAWN => {
            return TopologyItem::Spawn(parse_spawn_def())
          }
          SOCKET => {
            return TopologyItem::Socket(parse_socket_def())
          }
          FRUITING_BODY => {
            return TopologyItem::FruitingBody(parse_fruiting_body_def())
          }
          _ => {
            error("Expected 'spawn', 'socket', or 'fruiting_body'", SPAWN)
            advance()
            return TopologyItem::FruitingBody(FruitingBodyDef { name: "", location: current_location() })
          }
        }
      }

      rule parse_spawn_def() -> SpawnDef {
        let loc = current_location()
        expect(SPAWN, "Expected 'spawn'")

        let hyphal_tok = expect(IDENTIFIER, "Expected hyphal name")
        expect(IDENTIFIER, "Expected 'as'")  # "as" keyword
        let instance_tok = expect(IDENTIFIER, "Expected instance name")

        return SpawnDef {
          hyphal: hyphal_tok.value,
          instance: instance_tok.value,
          location: loc
        }
      }

      rule parse_socket_def() -> SocketDef {
        let loc = current_location()
        expect(SOCKET, "Expected 'socket'")

        let from_tok = expect(IDENTIFIER, "Expected source name")
        expect(ARROW, "Expected '->' in socket definition")
        let to_tok = expect(IDENTIFIER, "Expected destination name")

        let frequency = ""
        if match_token(LPAREN) {
          expect(IDENTIFIER, "Expected 'frequency'")  # "frequency" keyword
          expect(COLON, "Expected ':' after 'frequency'")
          let freq_tok = expect(IDENTIFIER, "Expected frequency name")
          frequency = freq_tok.value
          expect(RPAREN, "Expected ')' to close socket options")
        }

        return SocketDef {
          from: from_tok.value,
          to: to_tok.value,
          frequency: frequency,
          location: loc
        }
      }

      rule parse_fruiting_body_def() -> FruitingBodyDef {
        let loc = current_location()
        expect(FRUITING_BODY, "Expected 'fruiting_body'")

        let name_tok = expect(IDENTIFIER, "Expected fruiting body name")

        return FruitingBodyDef {
          name: name_tok.value,
          location: loc
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # IMPORT PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_import_def() -> ImportDef {
        let loc = current_location()
        expect(IMPORT, "Expected 'import'")

        let path_tok = expect(IDENTIFIER, "Expected import path")

        return ImportDef {
          path: path_tok.value,
          location: loc
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STATEMENT PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_statement_list() -> vec<Statement> {
        let statements: vec<Statement> = vec_new()

        while !check(RBRACE) && !check(EOF) {
          let stmt = parse_statement()
          if stmt != Statement::None {
            vec_push(statements, stmt)
          }

          if state.panic_mode {
            synchronize()
          }
        }

        return statements
      }

      rule parse_statement() -> Statement {
        match peek().type {
          LET => {
            return Statement::Let(parse_let_statement())
          }
          IF => {
            return Statement::Conditional(parse_conditional_statement())
          }
          EMIT => {
            return Statement::Emit(parse_emit_statement())
          }
          REPORT => {
            return Statement::Report(parse_report_statement())
          }
          SPAWN => {
            return Statement::Spawn(parse_spawn_statement())
          }
          DIE => {
            return Statement::Die(parse_die_statement())
          }
          IDENTIFIER => {
            # Could be assignment or expression statement
            return parse_assignment_or_expression()
          }
          _ => {
            # Try to parse as expression statement
            let expr = parse_expression()
            if expr != Expression::None {
              return Statement::Expression(ExpressionStatement {
                expression: expr,
                location: current_location()
              })
            }
            return Statement::None
          }
        }
      }

      rule parse_let_statement() -> LetStatement {
        let loc = current_location()
        expect(LET, "Expected 'let'")

        let name_tok = expect(IDENTIFIER, "Expected variable name")

        # Optional type annotation
        let type_annotation = TypeRef::None
        if match_token(COLON) {
          type_annotation = parse_type_ref()
        }

        expect(ASSIGN, "Expected '=' after variable name")
        let value = parse_expression()

        return LetStatement {
          name: name_tok.value,
          type_annotation: type_annotation,
          value: value,
          location: loc
        }
      }

      rule parse_conditional_statement() -> ConditionalStatement {
        let loc = current_location()
        expect(IF, "Expected 'if'")

        let condition = parse_expression()
        expect(LBRACE, "Expected '{' after condition")
        let then_body = parse_statement_list()
        expect(RBRACE, "Expected '}' to close then branch")

        let else_body: vec<Statement> = vec_new()
        if match_token(ELSE) {
          if check(IF) {
            # else if
            let nested = parse_conditional_statement()
            vec_push(else_body, Statement::Conditional(nested))
          } else {
            expect(LBRACE, "Expected '{' after 'else'")
            else_body = parse_statement_list()
            expect(RBRACE, "Expected '}' to close else branch")
          }
        }

        return ConditionalStatement {
          condition: condition,
          then_body: then_body,
          else_body: else_body,
          location: loc
        }
      }

      rule parse_emit_statement() -> EmitStatement {
        let loc = current_location()
        expect(EMIT, "Expected 'emit'")

        let freq_tok = expect(IDENTIFIER, "Expected frequency name")
        expect(LBRACE, "Expected '{' after frequency name")

        let fields: vec<FieldInit> = vec_new()
        while !check(RBRACE) && !check(EOF) {
          vec_push(fields, parse_field_init())
          if !check(RBRACE) {
            match_token(COMMA)  # Optional comma
          }
        }

        expect(RBRACE, "Expected '}' to close emit")

        return EmitStatement {
          frequency: freq_tok.value,
          fields: fields,
          location: loc
        }
      }

      rule parse_field_init() -> FieldInit {
        let loc = current_location()
        let name_tok = expect(IDENTIFIER, "Expected field name")
        expect(COLON, "Expected ':' after field name")
        let value = parse_expression()

        return FieldInit {
          name: name_tok.value,
          value: value,
          location: loc
        }
      }

      rule parse_report_statement() -> ReportStatement {
        let loc = current_location()
        expect(REPORT, "Expected 'report'")

        let metric_tok = expect(IDENTIFIER, "Expected metric name")
        expect(COLON, "Expected ':' after metric name")
        let value = parse_expression()

        return ReportStatement {
          metric: metric_tok.value,
          value: value,
          location: loc
        }
      }

      rule parse_spawn_statement() -> SpawnStatement {
        let loc = current_location()
        expect(SPAWN, "Expected 'spawn'")

        let hyphal_tok = expect(IDENTIFIER, "Expected hyphal name")
        expect(IDENTIFIER, "Expected 'as'")  # "as" keyword
        let instance_tok = expect(IDENTIFIER, "Expected instance name")

        return SpawnStatement {
          hyphal: hyphal_tok.value,
          instance: instance_tok.value,
          location: loc
        }
      }

      rule parse_die_statement() -> DieStatement {
        let loc = current_location()
        expect(DIE, "Expected 'die'")
        return DieStatement { location: loc }
      }

      rule parse_assignment_or_expression() -> Statement {
        let loc = current_location()

        # Look ahead to determine if this is an assignment
        let expr = parse_expression()

        if match_token(ASSIGN) {
          # This is an assignment
          let target = expression_to_assignment_target(expr)
          let value = parse_expression()

          return Statement::Assignment(AssignmentStatement {
            target: target,
            value: value,
            location: loc
          })
        }

        # Expression statement
        return Statement::Expression(ExpressionStatement {
          expression: expr,
          location: loc
        })
      }

      rule expression_to_assignment_target(expr: Expression) -> AssignmentTarget {
        match expr {
          Expression::Identifier(id) => {
            return AssignmentTarget::Variable(id.name)
          }
          Expression::StateAccess(sa) => {
            return AssignmentTarget::StateField(sa.field)
          }
          Expression::FieldAccess(fa) => {
            return AssignmentTarget::FieldAccess(fa.object, fa.field)
          }
          Expression::IndexAccess(ia) => {
            return AssignmentTarget::IndexAccess(ia.object, ia.index)
          }
          _ => {
            error("Invalid assignment target", IDENTIFIER)
            return AssignmentTarget::Variable("")
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # EXPRESSION PARSING (Precedence Climbing)
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_expression() -> Expression {
        return parse_logical_or()
      }

      # Precedence level 1: || (lowest)
      rule parse_logical_or() -> Expression {
        let loc = current_location()
        let left = parse_logical_and()

        while match_token(OR) {
          let right = parse_logical_and()
          left = Expression::BinaryOp(BinaryOpExpr {
            op: BinaryOperator::Or,
            left: left,
            right: right,
            location: loc
          })
        }

        return left
      }

      # Precedence level 2: &&
      rule parse_logical_and() -> Expression {
        let loc = current_location()
        let left = parse_equality()

        while match_token(AND) {
          let right = parse_equality()
          left = Expression::BinaryOp(BinaryOpExpr {
            op: BinaryOperator::And,
            left: left,
            right: right,
            location: loc
          })
        }

        return left
      }

      # Precedence level 3: == !=
      rule parse_equality() -> Expression {
        let loc = current_location()
        let left = parse_relational()

        while true {
          if match_token(EQ) {
            let right = parse_relational()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Eq,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(NE) {
            let right = parse_relational()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Ne,
              left: left,
              right: right,
              location: loc
            })
          } else {
            break
          }
        }

        return left
      }

      # Precedence level 4: < > <= >=
      rule parse_relational() -> Expression {
        let loc = current_location()
        let left = parse_additive()

        while true {
          if match_token(LT) {
            let right = parse_additive()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Lt,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(GT) {
            let right = parse_additive()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Gt,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(LE) {
            let right = parse_additive()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Le,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(GE) {
            let right = parse_additive()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Ge,
              left: left,
              right: right,
              location: loc
            })
          } else {
            break
          }
        }

        return left
      }

      # Precedence level 5: + -
      rule parse_additive() -> Expression {
        let loc = current_location()
        let left = parse_multiplicative()

        while true {
          if match_token(PLUS) {
            let right = parse_multiplicative()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Add,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(MINUS) {
            let right = parse_multiplicative()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Sub,
              left: left,
              right: right,
              location: loc
            })
          } else {
            break
          }
        }

        return left
      }

      # Precedence level 6: * / %
      rule parse_multiplicative() -> Expression {
        let loc = current_location()
        let left = parse_unary()

        while true {
          if match_token(STAR) {
            let right = parse_unary()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Mul,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(SLASH) {
            let right = parse_unary()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Div,
              left: left,
              right: right,
              location: loc
            })
          } else if match_token(PERCENT) {
            let right = parse_unary()
            left = Expression::BinaryOp(BinaryOpExpr {
              op: BinaryOperator::Mod,
              left: left,
              right: right,
              location: loc
            })
          } else {
            break
          }
        }

        return left
      }

      # Precedence level 7: ! - + (unary)
      rule parse_unary() -> Expression {
        let loc = current_location()

        if match_token(NOT) {
          let operand = parse_unary()
          return Expression::UnaryOp(UnaryOpExpr {
            op: UnaryOperator::Not,
            operand: operand,
            location: loc
          })
        }

        if match_token(MINUS) {
          let operand = parse_unary()
          return Expression::UnaryOp(UnaryOpExpr {
            op: UnaryOperator::Neg,
            operand: operand,
            location: loc
          })
        }

        if match_token(PLUS) {
          let operand = parse_unary()
          return Expression::UnaryOp(UnaryOpExpr {
            op: UnaryOperator::Pos,
            operand: operand,
            location: loc
          })
        }

        return parse_postfix()
      }

      # Precedence level 8: postfix (. [] () - highest)
      rule parse_postfix() -> Expression {
        let expr = parse_primary()

        while true {
          if match_token(DOT) {
            let loc = current_location()
            let field_tok = expect(IDENTIFIER, "Expected field name after '.'")

            # Check if it's a method call
            if check(LPAREN) {
              advance()
              let args = parse_argument_list()
              expect(RPAREN, "Expected ')' after method arguments")

              expr = Expression::MethodCall(MethodCallExpr {
                object: expr,
                method: field_tok.value,
                args: args,
                location: loc
              })
            } else {
              expr = Expression::FieldAccess(FieldAccessExpr {
                object: expr,
                field: field_tok.value,
                location: loc
              })
            }
          } else if match_token(LBRACKET) {
            let loc = current_location()
            let index = parse_expression()
            expect(RBRACKET, "Expected ']' after index")

            expr = Expression::IndexAccess(IndexAccessExpr {
              object: expr,
              index: index,
              location: loc
            })
          } else if match_token(LPAREN) {
            # Function call on identifier
            match expr {
              Expression::Identifier(id) => {
                let loc = id.location
                let args = parse_argument_list()
                expect(RPAREN, "Expected ')' after arguments")

                expr = Expression::Call(CallExpr {
                  name: id.name,
                  args: args,
                  location: loc
                })
              }
              _ => {
                error("Expected function name", IDENTIFIER)
              }
            }
          } else {
            break
          }
        }

        return expr
      }

      rule parse_argument_list() -> vec<Expression> {
        let args: vec<Expression> = vec_new()

        if !check(RPAREN) {
          vec_push(args, parse_expression())

          while match_token(COMMA) {
            vec_push(args, parse_expression())
          }
        }

        return args
      }

      # Primary expressions (literals, identifiers, grouped)
      rule parse_primary() -> Expression {
        let loc = current_location()
        let tok = peek()

        match tok.type {
          NUMBER => {
            advance()
            let value = parse_number(tok.value)
            return Expression::Literal(LiteralExpr {
              value: value,
              location: loc
            })
          }
          STRING_LIT => {
            advance()
            return Expression::Literal(LiteralExpr {
              value: Literal::String(tok.value),
              location: loc
            })
          }
          TRUE => {
            advance()
            return Expression::Literal(LiteralExpr {
              value: Literal::Bool(true),
              location: loc
            })
          }
          FALSE => {
            advance()
            return Expression::Literal(LiteralExpr {
              value: Literal::Bool(false),
              location: loc
            })
          }
          IDENTIFIER => {
            advance()

            # Check for state access: state.field
            if tok.value == "state" && check(DOT) {
              advance()  # consume '.'
              let field_tok = expect(IDENTIFIER, "Expected field name after 'state.'")
              return Expression::StateAccess(StateAccessExpr {
                field: field_tok.value,
                location: loc
              })
            }

            # Check for signal binding access
            if tok.value == state.current_binding && check(DOT) {
              advance()  # consume '.'
              let field_tok = expect(IDENTIFIER, "Expected field name")
              return Expression::SignalAccess(SignalAccessExpr {
                binding: tok.value,
                field: field_tok.value,
                location: loc
              })
            }

            # Check for struct literal: TypeName { ... }
            if check(LBRACE) {
              advance()
              let fields: vec<FieldInit> = vec_new()
              while !check(RBRACE) && !check(EOF) {
                vec_push(fields, parse_field_init())
                if !check(RBRACE) {
                  match_token(COMMA)
                }
              }
              expect(RBRACE, "Expected '}' to close struct literal")

              return Expression::StructLiteral(StructLiteralExpr {
                type_name: tok.value,
                fields: fields,
                location: loc
              })
            }

            return Expression::Identifier(IdentifierExpr {
              name: tok.value,
              location: loc
            })
          }
          LPAREN => {
            advance()
            let inner = parse_expression()
            expect(RPAREN, "Expected ')' after expression")
            return Expression::Grouped(GroupedExpr {
              inner: inner,
              location: loc
            })
          }
          LBRACKET => {
            # List literal
            advance()
            let elements: vec<Expression> = vec_new()
            while !check(RBRACKET) && !check(EOF) {
              vec_push(elements, parse_expression())
              if !check(RBRACKET) {
                expect(COMMA, "Expected ',' between list elements")
              }
            }
            expect(RBRACKET, "Expected ']' to close list")

            return Expression::ListLiteral(ListLiteralExpr {
              elements: elements,
              location: loc
            })
          }
          _ => {
            error("Expected expression", IDENTIFIER)
            return Expression::None
          }
        }
      }

      rule parse_number(s: string) -> Literal {
        if string_contains(s, ".") {
          return Literal::Float(parse_f64(s))
        }
        return Literal::Number(parse_i64(s))
      }
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TOPOLOGY
  # ═══════════════════════════════════════════════════════════════════════════

  topology {
    spawn parser as Parser

    # Input: Receive tokens from Lexer
    socket token_input -> Parser (frequency: token)
    socket lex_done -> Parser (frequency: lex_complete)

    # Output: Send AST to Type Checker
    socket Parser -> ast_output (frequency: ast_node)
    socket Parser -> ast_done (frequency: ast_complete)
    socket Parser -> parse_errors (frequency: parse_error)
    socket Parser -> parse_done (frequency: parse_complete)
  }
}
