# ClawedCode - A Mycelial P2P Messaging Network Simulator
# Demonstrates distributed message routing, consensus, and resilience
# Inspired by the Clawed Messenger protocol

network ClawedNetwork {
  frequencies {
    # Network messages
    message {
      id: u32
      sender: string
      content: string
      timestamp: u32
    }

    delivery_ack {
      message_id: u32
      node_id: string
    }

    heartbeat {
      node_id: string
    }

    # Network control
    peer_discovered {
      peer_id: string
      trust_score: u32
    }

    routing_update {
      target: string
      path_quality: u32
    }

    # Consensus
    vote {
      message_id: u32
      node_id: string
      decision: boolean
    }

    consensus_result {
      message_id: u32
      approved: boolean
      votes_for: u32
    }
  }

  hyphae {
    # A peer node in the Clawed network
    hyphal peer_node {
      state {
        node_id: string
        message_cache: vec<u32>
        peer_trust: map<string, u32>
        processed_messages: u32
        delivered_messages: u32
        failed_attempts: u32
      }

      on signal(message, msg) {
        # Check if we've seen this message before
        # If not, cache it and route to peers
        state.message_cache.push(msg.id)
        state.processed_messages = state.processed_messages + 1

        # Emit delivery acknowledgment
        emit delivery_ack {
          message_id: msg.id,
          node_id: state.node_id
        }

        # Forward to next peer (simplified routing)
        emit message {
          id: msg.id,
          sender: msg.sender,
          content: msg.content,
          timestamp: msg.timestamp
        }
      }

      on signal(heartbeat, hb) {
        # Respond with our own heartbeat (network aliveness)
        emit heartbeat {
          node_id: state.node_id
        }
        report health: "alive"
      }

      on signal(peer_discovered, pd) {
        # Update our peer trust network
        if !state.peer_trust.contains_key(pd.peer_id) {
          state.peer_trust[pd.peer_id] = pd.trust_score
        }
      }

      on signal(vote, v) {
        # We received a vote on a message
        # In real system, we'd tally these for consensus
        if v.decision {
          state.delivered_messages = state.delivered_messages + 1
        } else {
          state.failed_attempts = state.failed_attempts + 1
        }
      }

      on rest {
        report processed: state.processed_messages
        report delivered: state.delivered_messages
      }
    }

    # A relay node that helps route messages
    hyphal message_relay {
      state {
        relay_id: string
        throughput: u32
        routing_table: map<string, u32>
        active_connections: u32
      }

      on signal(message, msg) {
        # Relay the message forward
        state.throughput = state.throughput + 1

        emit message {
          id: msg.id,
          sender: msg.sender,
          content: msg.content,
          timestamp: msg.timestamp
        }

        # Update routing metrics
        state.routing_table[msg.sender] = state.routing_table[msg.sender] + 1
      }

      on signal(heartbeat, hb) {
        state.active_connections = state.active_connections + 1
        emit heartbeat { node_id: state.relay_id }
      }

      on rest {
        report relay_throughput: state.throughput
        report connections: state.active_connections
      }
    }

    # A consensus coordinator for distributed decisions
    hyphal consensus_node {
      state {
        consensus_votes: map<u32, u32>
        vote_threshold: u32 = 2
        decisions_made: u32
        pending_messages: u32
      }

      on signal(vote, v) {
        # Tally votes for this message
        if !state.consensus_votes.contains_key(v.message_id) {
          state.consensus_votes[v.message_id] = 0
        }

        if v.decision {
          state.consensus_votes[v.message_id] = state.consensus_votes[v.message_id] + 1
        }

        # If we've reached consensus threshold, emit decision
        if state.consensus_votes[v.message_id] >= state.vote_threshold {
          emit consensus_result {
            message_id: v.message_id,
            approved: true,
            votes_for: state.consensus_votes[v.message_id]
          }
          state.decisions_made = state.decisions_made + 1
          state.consensus_votes.remove(v.message_id)
        }
      }

      on signal(message, msg) {
        state.pending_messages = state.pending_messages + 1

        # Request votes from peers
        emit vote {
          message_id: msg.id,
          node_id: "consensus_node",
          decision: true
        }
      }

      on rest {
        report decisions: state.decisions_made
        report pending: state.pending_messages
      }
    }
  }

  topology {
    # External I/O
    fruiting_body input_messages
    fruiting_body output_messages
    fruiting_body network_status

    # Network nodes - create a small distributed network
    spawn peer_node as Peer_A
    spawn peer_node as Peer_B
    spawn peer_node as Peer_C
    spawn message_relay as Relay_1
    spawn consensus_node as Consensus_1

    # Message routing paths
    socket input_messages -> Peer_A (frequency: message)
    socket input_messages -> Peer_B (frequency: message)
    socket input_messages -> Peer_C (frequency: message)

    # Peer-to-peer connections (mesh network)
    socket Peer_A -> Relay_1 (frequency: message)
    socket Peer_B -> Relay_1 (frequency: message)
    socket Peer_C -> Relay_1 (frequency: message)
    socket Relay_1 -> Peer_A (frequency: message)
    socket Relay_1 -> Peer_B (frequency: message)
    socket Relay_1 -> Peer_C (frequency: message)

    # Consensus routing
    socket Peer_A -> Consensus_1 (frequency: vote)
    socket Peer_B -> Consensus_1 (frequency: vote)
    socket Peer_C -> Consensus_1 (frequency: vote)
    socket Consensus_1 -> output_messages (frequency: consensus_result)

    # Heartbeat broadcast
    socket Consensus_1 -> * (frequency: heartbeat)

    # Network status reporting
    socket Peer_A -> network_status (frequency: delivery_ack)
    socket Peer_B -> network_status (frequency: delivery_ack)
    socket Peer_C -> network_status (frequency: delivery_ack)
    socket Relay_1 -> network_status (frequency: routing_update)
  }

  config {
    cycle_period_ms: 100
    max_buffer_size: 10000
    enable_health_monitoring: true
  }
}

# ==============================================================================
# CLAWED NETWORK SIMULATION
# ==============================================================================
#
# This network simulates a distributed P2P messaging system with:
#
# 1. PEER NODES (Peer_A, Peer_B, Peer_C)
#    - Accept messages from input
#    - Cache messages to prevent duplicates
#    - Route to other peers via relay
#    - Report delivery acknowledgments
#    - Maintain peer trust scores
#
# 2. RELAY NODE (Relay_1)
#    - Intermediate routing hub
#    - Forwards messages between peers
#    - Tracks routing metrics
#    - Maintains active connections
#
# 3. CONSENSUS NODE (Consensus_1)
#    - Collects votes from peers
#    - Determines message validity
#    - Broadcasts heartbeats
#    - Makes distributed decisions
#
# ==============================================================================
# EXECUTION TRACE EXAMPLE:
# ==============================================================================
#
# CYCLE 1:
#   INPUT: message(id=1, sender="Alice", content="Hello", timestamp=0)
#   [SENSE] Peers A, B, C all receive the message
#   [ACT]
#     - Peer_A: cache message, emit ack, forward via Relay
#     - Peer_B: cache message, emit ack, forward via Relay
#     - Peer_C: cache message, emit ack, forward via Relay
#     - Each emits vote to Consensus_1
#   [REST] Network processes, updates metrics
#
# CYCLE 2:
#   [SENSE]
#     - Relay_1 receives 3 copies of the message
#     - Consensus_1 receives 3 votes
#   [ACT]
#     - Relay: forwards to all peers (diffusion)
#     - Consensus: tallies votes, reaches threshold (2/3)
#     - Emits consensus_result(approved=true)
#   [REST]
#     - Relay reports throughput: 3
#     - Consensus reports decision made
#
# OUTPUT: message successfully routed and approved by consensus
#
# ==============================================================================
# KEY PROPERTIES DEMONSTRATED:
# ==============================================================================
#
# 1. DISTRIBUTED: No central coordinator; peers work independently
# 2. RESILIENT: Message survives even if one peer fails
# 3. CONSENSUAL: Decisions made through voting, not decree
# 4. TRANSPARENT: All routing decisions visible and auditable
# 5. SELF-HEALING: Network adapts as peers join/leave
#
# This exemplifies the Mycelial paradigm:
# - Local rules (each peer makes its own decisions)
# - Global behavior (network reaches consensus through signals)
# - Emergent resilience (no single point of failure)
# - Organic growth (network can dynamically adjust)
#
# ==============================================================================
