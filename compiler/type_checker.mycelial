# Type Checker Agent
#
# Owner: Opus (Claude Opus 4.5)
# Purpose: Validate AST types and build symbol tables
# Input: ast_complete signal from Parser Agent
# Output: typed_ast signals to IR Generator Agent
#
# Implementation: Three-phase type checking
#   Phase 1: Build symbol table (frequencies, hyphae, state fields)
#   Phase 2: Type check all expressions and statements
#   Phase 3: Emit typed AST with type annotations
#
# Reference: /home/lewey/Desktop/mycelial-compiler/docs/architecture/ir-specification.md

network type_checker {

  # ═══════════════════════════════════════════════════════════════════════════
  # FREQUENCY DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  frequencies {
    # Input signals (from Parser)
    ast_complete {
      program: Program
      node_count: u32
    }

    # Output signals (to IR Generator)
    typed_ast_complete {
      program: TypedProgram
      type_map: map<u32, TypeInfo>
    }

    typed_ast_node {
      id: u32
      type_info: TypeInfo
      data: string
    }

    typecheck_complete {
      success: boolean
      error_count: u32
      warning_count: u32
    }

    typecheck_error {
      message: string
      line: u32
      column: u32
      hint: string
    }

    typecheck_warning {
      message: string
      line: u32
      column: u32
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TYPE DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  types {
    # ─────────────────────────────────────────────────────────────────────────
    # Type System (from ir-specification.md Section 2)
    # ─────────────────────────────────────────────────────────────────────────

    enum Type {
      # Primitive types
      U8, U16, U32, U64,
      I8, I16, I32, I64,
      F32, F64,
      Boolean, String, Binary,
      Void,

      # Complex types
      Vec(Type),
      Queue(Type),
      Map(Type, Type),

      # User-defined types
      Frequency(string),
      Struct(string),
      Agent(string),

      # Special types
      Unknown,        # Type not yet resolved
      Error,          # Type error occurred
      Any             # Accepts any type (for builtins)
    }

    struct TypeInfo {
      resolved_type: Type
      is_mutable: boolean
      source_line: u32
      source_column: u32
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Symbol Tables
    # ─────────────────────────────────────────────────────────────────────────

    struct FrequencySymbol {
      name: string
      fields: vec<FieldSymbol>
      freq_id: u32
      location: SourceLocation
    }

    struct FieldSymbol {
      name: string
      field_type: Type
      offset: u32
    }

    struct HyphalSymbol {
      name: string
      state_fields: vec<StateSymbol>
      rules: vec<RuleSymbol>
      location: SourceLocation
    }

    struct StateSymbol {
      name: string
      state_type: Type
      has_init: boolean
      location: SourceLocation
    }

    struct RuleSymbol {
      trigger_type: string      # "signal", "rest", "cycle"
      frequency_name: string    # For signal triggers
      binding_name: string      # Signal variable binding
      location: SourceLocation
    }

    struct SocketSymbol {
      from_agent: string
      to_agent: string
      frequency: string
      location: SourceLocation
    }

    struct LocalSymbol {
      name: string
      local_type: Type
      is_mutable: boolean
      location: SourceLocation
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Type Checking Context
    # ─────────────────────────────────────────────────────────────────────────

    struct TypeContext {
      current_hyphal: string
      current_rule: u32
      signal_binding: string
      signal_frequency: string
      in_loop: boolean
      return_type: Type
    }

    struct TypeError {
      message: string
      line: u32
      column: u32
      hint: string
    }

    struct SourceLocation {
      line: u32
      column: u32
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TYPE CHECKER AGENT
  # ═══════════════════════════════════════════════════════════════════════════

  hyphae {
    hyphal type_checker {
      state {
        # Symbol tables
        frequencies: map<string, FrequencySymbol>
        hyphae: map<string, HyphalSymbol>
        sockets: vec<SocketSymbol>
        fruiting_bodies: vec<string>

        # Type map for all AST nodes
        type_map: map<u32, TypeInfo>
        next_node_id: u32

        # Current context
        context: TypeContext
        local_scope: map<string, LocalSymbol>

        # Error tracking
        errors: vec<TypeError>
        warnings: vec<TypeError>

        # Input AST
        program: Program

        # Builtin functions
        builtins: map<string, Type>
      }

      # ─────────────────────────────────────────────────────────────────────────
      # INITIALIZATION
      # ─────────────────────────────────────────────────────────────────────────

      on rest {
        # Initialize symbol tables
        state.frequencies = map_new()
        state.hyphae = map_new()
        state.sockets = vec_new()
        state.fruiting_bodies = vec_new()
        state.type_map = map_new()
        state.next_node_id = 0
        state.local_scope = map_new()
        state.errors = vec_new()
        state.warnings = vec_new()

        # Initialize builtin functions
        state.builtins = map_new()
        map_insert(state.builtins, "format", Type::String)
        map_insert(state.builtins, "len", Type::U32)
        map_insert(state.builtins, "sum", Type::I64)
        map_insert(state.builtins, "min", Type::Any)
        map_insert(state.builtins, "max", Type::Any)
        map_insert(state.builtins, "abs", Type::Any)
        map_insert(state.builtins, "sqrt", Type::F64)
        map_insert(state.builtins, "to_string", Type::String)
        map_insert(state.builtins, "parse_int", Type::I64)
        map_insert(state.builtins, "parse_float", Type::F64)
        map_insert(state.builtins, "vec_new", Type::Any)
        map_insert(state.builtins, "vec_push", Type::Void)
        map_insert(state.builtins, "vec_pop", Type::Any)
        map_insert(state.builtins, "vec_len", Type::U32)
        map_insert(state.builtins, "vec_get", Type::Any)
        map_insert(state.builtins, "vec_clear", Type::Void)
        map_insert(state.builtins, "map_new", Type::Any)
        map_insert(state.builtins, "map_insert", Type::Void)
        map_insert(state.builtins, "map_get", Type::Any)
        map_insert(state.builtins, "map_contains", Type::Boolean)
        map_insert(state.builtins, "map_remove", Type::Void)
        map_insert(state.builtins, "queue_new", Type::Any)
        map_insert(state.builtins, "queue_push", Type::Void)
        map_insert(state.builtins, "queue_pop", Type::Any)
        map_insert(state.builtins, "string_len", Type::U32)
        map_insert(state.builtins, "string_concat", Type::String)
        map_insert(state.builtins, "string_char_at", Type::String)
        map_insert(state.builtins, "time_now", Type::U64)
        map_insert(state.builtins, "read_file", Type::String)
        map_insert(state.builtins, "write_file", Type::Void)
        map_insert(state.builtins, "hex_decode", Type::Vec(Type::U8))
        map_insert(state.builtins, "hex_encode", Type::String)
        map_insert(state.builtins, "json_encode", Type::String)
        map_insert(state.builtins, "json_decode", Type::Any)
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MAIN ENTRY POINT
      # ─────────────────────────────────────────────────────────────────────────

      on signal(ast_complete, ast) {
        state.program = ast.program
        vec_clear(state.errors)
        vec_clear(state.warnings)

        # Phase 1: Build symbol tables
        build_symbol_tables()

        # Phase 2: Type check the program
        if vec_len(state.errors) == 0 {
          typecheck_program()
        }

        # Phase 3: Emit results
        if vec_len(state.errors) == 0 {
          emit_typed_ast()

          emit typecheck_complete {
            success: true,
            error_count: 0,
            warning_count: vec_len(state.warnings)
          }
        } else {
          # Emit all errors
          for err in state.errors {
            emit typecheck_error {
              message: err.message,
              line: err.line,
              column: err.column,
              hint: err.hint
            }
          }

          emit typecheck_complete {
            success: false,
            error_count: vec_len(state.errors),
            warning_count: vec_len(state.warnings)
          }
        }
      }

      # ═══════════════════════════════════════════════════════════════════════
      # PHASE 1: BUILD SYMBOL TABLES
      # ═══════════════════════════════════════════════════════════════════════

      rule build_symbol_tables() {
        let freq_id = 0

        for item in state.program.items {
          match item {
            ProgramItem::Network(network) => {
              # Process frequencies
              for freq in network.frequencies {
                let fields = vec_new()
                for f in freq.fields {
                  vec_push(fields, FieldSymbol {
                    name: f.name,
                    field_type: resolve_type_ref(f.field_type),
                    offset: 0
                  })
                }

                map_insert(state.frequencies, freq.name, FrequencySymbol {
                  name: freq.name,
                  fields: fields,
                  freq_id: freq_id,
                  location: freq.location
                })
                freq_id = freq_id + 1
              }

              # Process hyphae
              for hyphal in network.hyphae {
                let state_fields = vec_new()
                for sf in hyphal.state.fields {
                  vec_push(state_fields, StateSymbol {
                    name: sf.name,
                    state_type: resolve_type_ref(sf.field_type),
                    has_init: !is_none_expr(sf.init_value),
                    location: sf.location
                  })
                }

                let rules = vec_new()
                for rule in hyphal.rules {
                  match rule.trigger {
                    RuleTrigger::Signal(sig) => {
                      vec_push(rules, RuleSymbol {
                        trigger_type: "signal",
                        frequency_name: sig.frequency,
                        binding_name: sig.binding,
                        location: rule.location
                      })
                    }
                    RuleTrigger::Rest => {
                      vec_push(rules, RuleSymbol {
                        trigger_type: "rest",
                        frequency_name: "",
                        binding_name: "",
                        location: rule.location
                      })
                    }
                    RuleTrigger::Cycle(n) => {
                      vec_push(rules, RuleSymbol {
                        trigger_type: "cycle",
                        frequency_name: "",
                        binding_name: "",
                        location: rule.location
                      })
                    }
                  }
                }

                map_insert(state.hyphae, hyphal.name, HyphalSymbol {
                  name: hyphal.name,
                  state_fields: state_fields,
                  rules: rules,
                  location: hyphal.location
                })
              }

              # Process topology
              for topo_item in network.topology {
                match topo_item {
                  TopologyItem::Socket(sock) => {
                    vec_push(state.sockets, SocketSymbol {
                      from_agent: sock.from,
                      to_agent: sock.to,
                      frequency: sock.frequency,
                      location: sock.location
                    })
                  }
                  TopologyItem::FruitingBody(fb) => {
                    vec_push(state.fruiting_bodies, fb.name)
                  }
                  TopologyItem::Spawn(sp) => {
                    # Validate hyphal exists
                    if !map_contains(state.hyphae, sp.hyphal) {
                      add_error(sp.location,
                        format("Unknown hyphal type: '{}'", sp.hyphal),
                        format("Available hyphae: {}", get_hyphal_names()))
                    }
                  }
                }
              }
            }
            _ => {}
          }
        }
      }

      # ═══════════════════════════════════════════════════════════════════════
      # PHASE 2: TYPE CHECK PROGRAM
      # ═══════════════════════════════════════════════════════════════════════

      rule typecheck_program() {
        for item in state.program.items {
          match item {
            ProgramItem::Network(network) => {
              typecheck_network(network)
            }
            _ => {}
          }
        }
      }

      rule typecheck_network(network: NetworkDef) {
        # Type check each hyphal
        for hyphal in network.hyphae {
          typecheck_hyphal(hyphal)
        }

        # Validate socket connections
        for sock in state.sockets {
          validate_socket(sock)
        }
      }

      rule typecheck_hyphal(hyphal: HyphalDef) {
        state.context.current_hyphal = hyphal.name

        # Type check state field initializers
        for sf in hyphal.state.fields {
          if !is_none_expr(sf.init_value) {
            let init_type = typecheck_expression(sf.init_value)
            let field_type = resolve_type_ref(sf.field_type)

            if !types_compatible(field_type, init_type) {
              add_error(sf.location,
                format("State field '{}' has type {} but initializer has type {}",
                  sf.name, type_to_string(field_type), type_to_string(init_type)),
                "Ensure the initializer matches the declared type")
            }
          }
        }

        # Type check each rule
        let rule_idx = 0
        for rule in hyphal.rules {
          state.context.current_rule = rule_idx
          typecheck_rule(rule, hyphal)
          rule_idx = rule_idx + 1
        }
      }

      rule typecheck_rule(rule: Rule, hyphal: HyphalDef) {
        # Set up context for signal triggers
        match rule.trigger {
          RuleTrigger::Signal(sig) => {
            # Validate frequency exists
            if !map_contains(state.frequencies, sig.frequency) {
              add_error(sig.location,
                format("Unknown frequency: '{}'", sig.frequency),
                format("Available frequencies: {}", get_frequency_names()))
              return
            }

            state.context.signal_binding = sig.binding
            state.context.signal_frequency = sig.frequency
          }
          _ => {
            state.context.signal_binding = ""
            state.context.signal_frequency = ""
          }
        }

        # Clear local scope
        state.local_scope = map_new()

        # Type check guard if present
        if !is_none_expr(rule.guard) {
          let guard_type = typecheck_expression(rule.guard)
          if guard_type != Type::Boolean && guard_type != Type::Error {
            add_error(get_expr_location(rule.guard),
              format("Guard expression must be boolean, found {}", type_to_string(guard_type)),
              "Use a comparison or logical expression")
          }
        }

        # Type check rule body
        for stmt in rule.body {
          typecheck_statement(stmt, hyphal)
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # STATEMENT TYPE CHECKING
      # ─────────────────────────────────────────────────────────────────────────

      rule typecheck_statement(stmt: Statement, hyphal: HyphalDef) {
        match stmt {
          Statement::Let(let_stmt) => {
            let value_type = typecheck_expression(let_stmt.value)

            # Check for type annotation
            if !is_none_type_ref(let_stmt.type_annotation) {
              let declared_type = resolve_type_ref(let_stmt.type_annotation)
              if !types_compatible(declared_type, value_type) {
                add_error(let_stmt.location,
                  format("Variable '{}' declared as {} but assigned {}",
                    let_stmt.name, type_to_string(declared_type), type_to_string(value_type)),
                  "")
              }
              value_type = declared_type
            }

            # Add to local scope
            map_insert(state.local_scope, let_stmt.name, LocalSymbol {
              name: let_stmt.name,
              local_type: value_type,
              is_mutable: false,
              location: let_stmt.location
            })
          }

          Statement::Assignment(assign) => {
            let value_type = typecheck_expression(assign.value)
            let target_type = typecheck_assignment_target(assign.target, hyphal)

            if !types_compatible(target_type, value_type) {
              add_error(assign.location,
                format("Cannot assign {} to {}",
                  type_to_string(value_type), type_to_string(target_type)),
                "")
            }
          }

          Statement::Conditional(cond) => {
            let cond_type = typecheck_expression(cond.condition)
            if cond_type != Type::Boolean && cond_type != Type::Error {
              add_error(cond.location,
                format("Condition must be boolean, found {}", type_to_string(cond_type)),
                "")
            }

            for s in cond.then_body {
              typecheck_statement(s, hyphal)
            }
            for s in cond.else_body {
              typecheck_statement(s, hyphal)
            }
          }

          Statement::Emit(emit) => {
            # Validate frequency exists
            if !map_contains(state.frequencies, emit.frequency) {
              add_error(emit.location,
                format("Unknown frequency: '{}'", emit.frequency),
                format("Available frequencies: {}", get_frequency_names()))
              return
            }

            let freq = map_get(state.frequencies, emit.frequency)

            # Validate all required fields are provided
            let provided_fields = map_new()
            for fi in emit.fields {
              map_insert(provided_fields, fi.name, true)

              # Find field in frequency definition
              let found = false
              let expected_type = Type::Unknown
              for ff in freq.fields {
                if ff.name == fi.name {
                  found = true
                  expected_type = ff.field_type
                  break
                }
              }

              if !found {
                add_error(fi.location,
                  format("Unknown field '{}' in frequency '{}'", fi.name, emit.frequency),
                  format("Available fields: {}", get_frequency_field_names(freq)))
              } else {
                let value_type = typecheck_expression(fi.value)
                if !types_compatible(expected_type, value_type) {
                  add_error(fi.location,
                    format("Field '{}' expects {} but got {}",
                      fi.name, type_to_string(expected_type), type_to_string(value_type)),
                    "")
                }
              }
            }

            # Check for missing required fields
            for ff in freq.fields {
              if !map_contains(provided_fields, ff.name) {
                add_error(emit.location,
                  format("Missing required field '{}' in emit for '{}'", ff.name, emit.frequency),
                  "")
              }
            }
          }

          Statement::Report(rpt) => {
            typecheck_expression(rpt.value)
          }

          Statement::Spawn(spawn) => {
            if !map_contains(state.hyphae, spawn.hyphal) {
              add_error(spawn.location,
                format("Unknown hyphal type: '{}'", spawn.hyphal),
                format("Available hyphae: {}", get_hyphal_names()))
            }
          }

          Statement::Die(die) => {
            # Die statement always valid
          }

          Statement::ForLoop(for_loop) => {
            let iter_type = typecheck_expression(for_loop.iterable)
            let elem_type = get_element_type(iter_type)

            state.context.in_loop = true
            map_insert(state.local_scope, for_loop.variable, LocalSymbol {
              name: for_loop.variable,
              local_type: elem_type,
              is_mutable: false,
              location: for_loop.location
            })

            for s in for_loop.body {
              typecheck_statement(s, hyphal)
            }
            state.context.in_loop = false
          }

          Statement::WhileLoop(while_loop) => {
            let cond_type = typecheck_expression(while_loop.condition)
            if cond_type != Type::Boolean && cond_type != Type::Error {
              add_error(while_loop.location,
                format("While condition must be boolean, found {}", type_to_string(cond_type)),
                "")
            }

            state.context.in_loop = true
            for s in while_loop.body {
              typecheck_statement(s, hyphal)
            }
            state.context.in_loop = false
          }

          Statement::Break(brk) => {
            if !state.context.in_loop {
              add_error(brk.location, "Break statement outside of loop", "")
            }
          }

          Statement::Continue(cont) => {
            if !state.context.in_loop {
              add_error(cont.location, "Continue statement outside of loop", "")
            }
          }

          Statement::Return(ret) => {
            if !is_none_expr(ret.value) {
              typecheck_expression(ret.value)
            }
          }

          Statement::Expression(expr_stmt) => {
            typecheck_expression(expr_stmt.expression)
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # EXPRESSION TYPE CHECKING
      # ─────────────────────────────────────────────────────────────────────────

      rule typecheck_expression(expr: Expression) -> Type {
        match expr {
          Expression::Literal(lit) => {
            return typecheck_literal(lit.value)
          }

          Expression::Identifier(ident) => {
            # Check local scope first
            if map_contains(state.local_scope, ident.name) {
              return map_get(state.local_scope, ident.name).local_type
            }

            # Check if it's a signal binding
            if ident.name == state.context.signal_binding && state.context.signal_binding != "" {
              return Type::Frequency(state.context.signal_frequency)
            }

            add_error(ident.location,
              format("Undefined variable: '{}'", ident.name),
              "Check variable name spelling or declare it first")
            return Type::Error
          }

          Expression::StateAccess(sa) => {
            return typecheck_state_access(sa.field)
          }

          Expression::SignalAccess(sig_acc) => {
            return typecheck_signal_access(sig_acc.binding, sig_acc.field, sig_acc.location)
          }

          Expression::BinaryOp(binop) => {
            let left_type = typecheck_expression(binop.left)
            let right_type = typecheck_expression(binop.right)
            return typecheck_binary_op(binop.op, left_type, right_type, binop.location)
          }

          Expression::UnaryOp(unop) => {
            let operand_type = typecheck_expression(unop.operand)
            return typecheck_unary_op(unop.op, operand_type, unop.location)
          }

          Expression::FieldAccess(fa) => {
            let obj_type = typecheck_expression(fa.object)
            return typecheck_field_access(obj_type, fa.field, fa.location)
          }

          Expression::IndexAccess(idx) => {
            let obj_type = typecheck_expression(idx.object)
            let index_type = typecheck_expression(idx.index)
            return typecheck_index_access(obj_type, index_type, idx.location)
          }

          Expression::Call(call) => {
            return typecheck_call(call.name, call.args, call.location)
          }

          Expression::MethodCall(method) => {
            let obj_type = typecheck_expression(method.object)
            return typecheck_method_call(obj_type, method.method, method.args, method.location)
          }

          Expression::ListLiteral(list) => {
            if vec_len(list.elements) == 0 {
              return Type::Vec(Type::Unknown)
            }
            let elem_type = typecheck_expression(list.elements[0])
            for i in 1..vec_len(list.elements) {
              let t = typecheck_expression(list.elements[i])
              if !types_compatible(elem_type, t) {
                add_error(list.location,
                  format("Inconsistent list element types: {} and {}",
                    type_to_string(elem_type), type_to_string(t)),
                  "All list elements must have the same type")
              }
            }
            return Type::Vec(elem_type)
          }

          Expression::MapLiteral(map_lit) => {
            if vec_len(map_lit.entries) == 0 {
              return Type::Map(Type::Unknown, Type::Unknown)
            }
            let key_type = typecheck_expression(map_lit.entries[0].key)
            let val_type = typecheck_expression(map_lit.entries[0].value)
            return Type::Map(key_type, val_type)
          }

          Expression::StructLiteral(struct_lit) => {
            # Check if it's a frequency
            if map_contains(state.frequencies, struct_lit.type_name) {
              return Type::Frequency(struct_lit.type_name)
            }
            return Type::Struct(struct_lit.type_name)
          }

          Expression::Grouped(grp) => {
            return typecheck_expression(grp.inner)
          }

          Expression::None => {
            return Type::Void
          }
        }

        return Type::Unknown
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TYPE CHECKING HELPERS
      # ─────────────────────────────────────────────────────────────────────────

      rule typecheck_literal(lit: Literal) -> Type {
        match lit {
          Literal::Number(n) => { return Type::I64 }
          Literal::Float(f) => { return Type::F64 }
          Literal::String(s) => { return Type::String }
          Literal::Bool(b) => { return Type::Boolean }
          Literal::Null => { return Type::Void }
        }
        return Type::Unknown
      }

      rule typecheck_state_access(field: string) -> Type {
        let hyphal_name = state.context.current_hyphal
        if !map_contains(state.hyphae, hyphal_name) {
          return Type::Error
        }

        let hyphal = map_get(state.hyphae, hyphal_name)
        for sf in hyphal.state_fields {
          if sf.name == field {
            return sf.state_type
          }
        }

        add_error(SourceLocation { line: 0, column: 0 },
          format("Unknown state field '{}' in hyphal '{}'", field, hyphal_name),
          format("Available state fields: {}", get_state_field_names(hyphal)))
        return Type::Error
      }

      rule typecheck_signal_access(binding: string, field: string, loc: SourceLocation) -> Type {
        if binding != state.context.signal_binding {
          add_error(loc,
            format("Unknown signal binding: '{}'", binding),
            format("Current signal binding is: '{}'", state.context.signal_binding))
          return Type::Error
        }

        let freq_name = state.context.signal_frequency
        if !map_contains(state.frequencies, freq_name) {
          return Type::Error
        }

        let freq = map_get(state.frequencies, freq_name)
        for ff in freq.fields {
          if ff.name == field {
            return ff.field_type
          }
        }

        add_error(loc,
          format("Unknown field '{}' in frequency '{}'", field, freq_name),
          format("Available fields: {}", get_frequency_field_names(freq)))
        return Type::Error
      }

      rule typecheck_binary_op(op: BinaryOperator, left: Type, right: Type, loc: SourceLocation) -> Type {
        if left == Type::Error || right == Type::Error {
          return Type::Error
        }

        match op {
          # Arithmetic operators
          BinaryOperator::Add | BinaryOperator::Sub |
          BinaryOperator::Mul | BinaryOperator::Div | BinaryOperator::Mod => {
            if is_numeric_type(left) && is_numeric_type(right) {
              return promote_numeric_types(left, right)
            }
            if op == BinaryOperator::Add && left == Type::String && right == Type::String {
              return Type::String
            }
            add_error(loc,
              format("Invalid operand types for {}: {} and {}",
                binop_to_string(op), type_to_string(left), type_to_string(right)),
              "Arithmetic operators require numeric types")
            return Type::Error
          }

          # Comparison operators
          BinaryOperator::Eq | BinaryOperator::Ne => {
            if types_compatible(left, right) {
              return Type::Boolean
            }
            add_error(loc,
              format("Cannot compare {} with {}", type_to_string(left), type_to_string(right)),
              "")
            return Type::Error
          }

          BinaryOperator::Lt | BinaryOperator::Gt |
          BinaryOperator::Le | BinaryOperator::Ge => {
            if is_numeric_type(left) && is_numeric_type(right) {
              return Type::Boolean
            }
            if left == Type::String && right == Type::String {
              return Type::Boolean
            }
            add_error(loc,
              format("Invalid comparison types: {} and {}", type_to_string(left), type_to_string(right)),
              "Comparison requires numeric or string types")
            return Type::Error
          }

          # Logical operators
          BinaryOperator::And | BinaryOperator::Or => {
            if left == Type::Boolean && right == Type::Boolean {
              return Type::Boolean
            }
            add_error(loc,
              format("Logical operators require boolean operands, found {} and {}",
                type_to_string(left), type_to_string(right)),
              "")
            return Type::Error
          }
        }

        return Type::Unknown
      }

      rule typecheck_unary_op(op: UnaryOperator, operand: Type, loc: SourceLocation) -> Type {
        if operand == Type::Error {
          return Type::Error
        }

        match op {
          UnaryOperator::Not => {
            if operand == Type::Boolean {
              return Type::Boolean
            }
            add_error(loc, format("Cannot apply 'not' to {}", type_to_string(operand)), "")
            return Type::Error
          }
          UnaryOperator::Neg => {
            if is_numeric_type(operand) {
              return operand
            }
            add_error(loc, format("Cannot negate {}", type_to_string(operand)), "")
            return Type::Error
          }
          UnaryOperator::Pos => {
            if is_numeric_type(operand) {
              return operand
            }
            return Type::Error
          }
        }

        return Type::Unknown
      }

      rule typecheck_field_access(obj_type: Type, field: string, loc: SourceLocation) -> Type {
        if obj_type == Type::Error {
          return Type::Error
        }

        match obj_type {
          Type::Frequency(freq_name) => {
            if !map_contains(state.frequencies, freq_name) {
              return Type::Error
            }
            let freq = map_get(state.frequencies, freq_name)
            for ff in freq.fields {
              if ff.name == field {
                return ff.field_type
              }
            }
            add_error(loc,
              format("No field '{}' in frequency '{}'", field, freq_name),
              "")
            return Type::Error
          }
          _ => {
            add_error(loc,
              format("Cannot access field '{}' on type {}", field, type_to_string(obj_type)),
              "")
            return Type::Error
          }
        }
      }

      rule typecheck_index_access(obj_type: Type, index_type: Type, loc: SourceLocation) -> Type {
        match obj_type {
          Type::Vec(elem_type) => {
            if !is_integer_type(index_type) {
              add_error(loc, "Vector index must be an integer", "")
              return Type::Error
            }
            return elem_type
          }
          Type::Map(key_type, val_type) => {
            if !types_compatible(key_type, index_type) {
              add_error(loc,
                format("Map key type mismatch: expected {}, got {}",
                  type_to_string(key_type), type_to_string(index_type)),
                "")
              return Type::Error
            }
            return val_type
          }
          Type::String => {
            if !is_integer_type(index_type) {
              add_error(loc, "String index must be an integer", "")
              return Type::Error
            }
            return Type::String
          }
          _ => {
            add_error(loc,
              format("Cannot index into type {}", type_to_string(obj_type)),
              "Only vectors, maps, and strings can be indexed")
            return Type::Error
          }
        }
      }

      rule typecheck_call(name: string, args: vec<Expression>, loc: SourceLocation) -> Type {
        # Check builtin functions
        if map_contains(state.builtins, name) {
          let ret_type = map_get(state.builtins, name)
          for arg in args {
            typecheck_expression(arg)
          }
          return ret_type
        }

        add_error(loc,
          format("Unknown function: '{}'", name),
          "")
        return Type::Error
      }

      rule typecheck_method_call(obj_type: Type, method: string, args: vec<Expression>, loc: SourceLocation) -> Type {
        # Type check all arguments
        for arg in args {
          typecheck_expression(arg)
        }

        # Common collection methods
        match obj_type {
          Type::Vec(elem_type) => {
            if method == "push" { return Type::Void }
            if method == "pop" { return elem_type }
            if method == "len" { return Type::U32 }
            if method == "get" { return elem_type }
            if method == "clear" { return Type::Void }
          }
          Type::Map(key_type, val_type) => {
            if method == "insert" { return Type::Void }
            if method == "get" { return val_type }
            if method == "contains" { return Type::Boolean }
            if method == "remove" { return Type::Void }
          }
          Type::Queue(elem_type) => {
            if method == "push" { return Type::Void }
            if method == "pop" { return elem_type }
            if method == "len" { return Type::U32 }
          }
          Type::String => {
            if method == "len" { return Type::U32 }
            if method == "concat" { return Type::String }
            if method == "char_at" { return Type::String }
            if method == "substring" { return Type::String }
          }
          _ => {}
        }

        add_error(loc,
          format("Unknown method '{}' on type {}", method, type_to_string(obj_type)),
          "")
        return Type::Error
      }

      rule typecheck_assignment_target(target: AssignmentTarget, hyphal: HyphalDef) -> Type {
        match target {
          AssignmentTarget::Variable(name) => {
            if map_contains(state.local_scope, name) {
              return map_get(state.local_scope, name).local_type
            }
            return Type::Error
          }
          AssignmentTarget::StateField(field) => {
            return typecheck_state_access(field)
          }
          AssignmentTarget::FieldAccess(obj, field) => {
            let obj_type = typecheck_expression(obj)
            return typecheck_field_access(obj_type, field, get_expr_location(obj))
          }
          AssignmentTarget::IndexAccess(obj, idx) => {
            let obj_type = typecheck_expression(obj)
            let idx_type = typecheck_expression(idx)
            return typecheck_index_access(obj_type, idx_type, get_expr_location(obj))
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # SOCKET VALIDATION
      # ─────────────────────────────────────────────────────────────────────────

      rule validate_socket(sock: SocketSymbol) {
        # Validate frequency exists
        if !map_contains(state.frequencies, sock.frequency) {
          add_error(sock.location,
            format("Socket uses unknown frequency: '{}'", sock.frequency),
            format("Available frequencies: {}", get_frequency_names()))
        }

        # Validate from/to are valid agents or fruiting bodies
        let from_valid = map_contains(state.hyphae, sock.from_agent) ||
                         vec_contains(state.fruiting_bodies, sock.from_agent)
        let to_valid = map_contains(state.hyphae, sock.to_agent) ||
                       vec_contains(state.fruiting_bodies, sock.to_agent)

        if !from_valid {
          add_error(sock.location,
            format("Socket source '{}' is not a valid agent or fruiting body", sock.from_agent),
            "")
        }
        if !to_valid {
          add_error(sock.location,
            format("Socket target '{}' is not a valid agent or fruiting body", sock.to_agent),
            "")
        }
      }

      # ═══════════════════════════════════════════════════════════════════════
      # PHASE 3: EMIT TYPED AST
      # ═══════════════════════════════════════════════════════════════════════

      rule emit_typed_ast() {
        # Emit typed AST complete signal
        emit typed_ast_complete {
          program: state.program,
          type_map: state.type_map
        }

        # Emit individual typed nodes for streaming
        for entry in state.type_map {
          emit typed_ast_node {
            id: entry.key,
            type_info: entry.value,
            data: ""
          }
        }
      }

      # ═══════════════════════════════════════════════════════════════════════
      # UTILITY FUNCTIONS
      # ═══════════════════════════════════════════════════════════════════════

      rule resolve_type_ref(type_ref: TypeRef) -> Type {
        match type_ref {
          TypeRef::Primitive(prim) => {
            match prim {
              PrimitiveType::U8 => { return Type::U8 }
              PrimitiveType::U16 => { return Type::U16 }
              PrimitiveType::U32 => { return Type::U32 }
              PrimitiveType::U64 => { return Type::U64 }
              PrimitiveType::I8 => { return Type::I8 }
              PrimitiveType::I16 => { return Type::I16 }
              PrimitiveType::I32 => { return Type::I32 }
              PrimitiveType::I64 => { return Type::I64 }
              PrimitiveType::F32 => { return Type::F32 }
              PrimitiveType::F64 => { return Type::F64 }
              PrimitiveType::Boolean => { return Type::Boolean }
              PrimitiveType::String => { return Type::String }
              PrimitiveType::Binary => { return Type::Binary }
            }
          }
          TypeRef::Vec(inner) => {
            return Type::Vec(resolve_type_ref(inner))
          }
          TypeRef::Queue(inner) => {
            return Type::Queue(resolve_type_ref(inner))
          }
          TypeRef::Map(key, val) => {
            return Type::Map(resolve_type_ref(key), resolve_type_ref(val))
          }
          TypeRef::Custom(name) => {
            if map_contains(state.frequencies, name) {
              return Type::Frequency(name)
            }
            return Type::Struct(name)
          }
          TypeRef::None => {
            return Type::Unknown
          }
        }
        return Type::Unknown
      }

      rule types_compatible(expected: Type, actual: Type) -> boolean {
        if expected == actual { return true }
        if expected == Type::Any || actual == Type::Any { return true }
        if expected == Type::Unknown || actual == Type::Unknown { return true }

        # Numeric promotion
        if is_numeric_type(expected) && is_numeric_type(actual) {
          return true
        }

        # Vec type compatibility
        match expected {
          Type::Vec(exp_elem) => {
            match actual {
              Type::Vec(act_elem) => {
                return types_compatible(exp_elem, act_elem)
              }
              _ => { return false }
            }
          }
          _ => {}
        }

        # Map type compatibility
        match expected {
          Type::Map(exp_key, exp_val) => {
            match actual {
              Type::Map(act_key, act_val) => {
                return types_compatible(exp_key, act_key) && types_compatible(exp_val, act_val)
              }
              _ => { return false }
            }
          }
          _ => {}
        }

        return false
      }

      rule is_numeric_type(t: Type) -> boolean {
        return t == Type::U8 || t == Type::U16 || t == Type::U32 || t == Type::U64 ||
               t == Type::I8 || t == Type::I16 || t == Type::I32 || t == Type::I64 ||
               t == Type::F32 || t == Type::F64
      }

      rule is_integer_type(t: Type) -> boolean {
        return t == Type::U8 || t == Type::U16 || t == Type::U32 || t == Type::U64 ||
               t == Type::I8 || t == Type::I16 || t == Type::I32 || t == Type::I64
      }

      rule promote_numeric_types(a: Type, b: Type) -> Type {
        # Float wins
        if a == Type::F64 || b == Type::F64 { return Type::F64 }
        if a == Type::F32 || b == Type::F32 { return Type::F32 }

        # Larger integer wins
        if a == Type::I64 || b == Type::I64 { return Type::I64 }
        if a == Type::U64 || b == Type::U64 { return Type::U64 }
        if a == Type::I32 || b == Type::I32 { return Type::I32 }
        if a == Type::U32 || b == Type::U32 { return Type::U32 }

        return Type::I32
      }

      rule get_element_type(t: Type) -> Type {
        match t {
          Type::Vec(elem) => { return elem }
          Type::Queue(elem) => { return elem }
          Type::String => { return Type::String }
          _ => { return Type::Unknown }
        }
      }

      rule type_to_string(t: Type) -> string {
        match t {
          Type::U8 => { return "u8" }
          Type::U16 => { return "u16" }
          Type::U32 => { return "u32" }
          Type::U64 => { return "u64" }
          Type::I8 => { return "i8" }
          Type::I16 => { return "i16" }
          Type::I32 => { return "i32" }
          Type::I64 => { return "i64" }
          Type::F32 => { return "f32" }
          Type::F64 => { return "f64" }
          Type::Boolean => { return "boolean" }
          Type::String => { return "string" }
          Type::Binary => { return "binary" }
          Type::Void => { return "void" }
          Type::Vec(inner) => { return format("vec<{}>", type_to_string(inner)) }
          Type::Queue(inner) => { return format("queue<{}>", type_to_string(inner)) }
          Type::Map(k, v) => { return format("map<{}, {}>", type_to_string(k), type_to_string(v)) }
          Type::Frequency(name) => { return format("frequency:{}", name) }
          Type::Struct(name) => { return format("struct:{}", name) }
          Type::Agent(name) => { return format("agent:{}", name) }
          Type::Unknown => { return "unknown" }
          Type::Error => { return "error" }
          Type::Any => { return "any" }
        }
        return "?"
      }

      rule binop_to_string(op: BinaryOperator) -> string {
        match op {
          BinaryOperator::Add => { return "+" }
          BinaryOperator::Sub => { return "-" }
          BinaryOperator::Mul => { return "*" }
          BinaryOperator::Div => { return "/" }
          BinaryOperator::Mod => { return "%" }
          BinaryOperator::Eq => { return "==" }
          BinaryOperator::Ne => { return "!=" }
          BinaryOperator::Lt => { return "<" }
          BinaryOperator::Gt => { return ">" }
          BinaryOperator::Le => { return "<=" }
          BinaryOperator::Ge => { return ">=" }
          BinaryOperator::And => { return "&&" }
          BinaryOperator::Or => { return "||" }
        }
        return "?"
      }

      rule get_frequency_names() -> string {
        let names = vec_new()
        for entry in state.frequencies {
          vec_push(names, entry.key)
        }
        return vec_join(names, ", ")
      }

      rule get_hyphal_names() -> string {
        let names = vec_new()
        for entry in state.hyphae {
          vec_push(names, entry.key)
        }
        return vec_join(names, ", ")
      }

      rule get_frequency_field_names(freq: FrequencySymbol) -> string {
        let names = vec_new()
        for f in freq.fields {
          vec_push(names, f.name)
        }
        return vec_join(names, ", ")
      }

      rule get_state_field_names(hyphal: HyphalSymbol) -> string {
        let names = vec_new()
        for sf in hyphal.state_fields {
          vec_push(names, sf.name)
        }
        return vec_join(names, ", ")
      }

      rule is_none_expr(expr: Expression) -> boolean {
        match expr {
          Expression::None => { return true }
          _ => { return false }
        }
      }

      rule is_none_type_ref(tr: TypeRef) -> boolean {
        match tr {
          TypeRef::None => { return true }
          _ => { return false }
        }
      }

      rule get_expr_location(expr: Expression) -> SourceLocation {
        match expr {
          Expression::Literal(lit) => { return lit.location }
          Expression::Identifier(ident) => { return ident.location }
          Expression::BinaryOp(binop) => { return binop.location }
          Expression::UnaryOp(unop) => { return unop.location }
          Expression::FieldAccess(fa) => { return fa.location }
          Expression::IndexAccess(idx) => { return idx.location }
          Expression::Call(call) => { return call.location }
          Expression::MethodCall(mc) => { return mc.location }
          Expression::StateAccess(sa) => { return sa.location }
          Expression::SignalAccess(sig) => { return sig.location }
          Expression::ListLiteral(list) => { return list.location }
          Expression::MapLiteral(map) => { return map.location }
          Expression::StructLiteral(st) => { return st.location }
          Expression::Grouped(grp) => { return grp.location }
          Expression::None => { return SourceLocation { line: 0, column: 0 } }
        }
        return SourceLocation { line: 0, column: 0 }
      }

      rule vec_contains(v: vec<string>, item: string) -> boolean {
        for s in v {
          if s == item { return true }
        }
        return false
      }

      rule vec_join(v: vec<string>, sep: string) -> string {
        let result = ""
        let first = true
        for s in v {
          if !first { result = string_concat(result, sep) }
          result = string_concat(result, s)
          first = false
        }
        return result
      }

      rule add_error(loc: SourceLocation, message: string, hint: string) {
        vec_push(state.errors, TypeError {
          message: message,
          line: loc.line,
          column: loc.column,
          hint: hint
        })
      }

      rule add_warning(loc: SourceLocation, message: string) {
        vec_push(state.warnings, TypeError {
          message: message,
          line: loc.line,
          column: loc.column,
          hint: ""
        })
      }
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TOPOLOGY
  # ═══════════════════════════════════════════════════════════════════════════

  topology {
    spawn type_checker as TC1
  }
}
