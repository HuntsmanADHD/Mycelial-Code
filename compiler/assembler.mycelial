# x86-64 Assembler Agent
#
# Owner: Opus (Claude Opus 4.5)
# Purpose: Convert x86-64 assembly instructions to machine code bytes
# Input: asm_instruction signals from Code Generator Agent
# Output: machine_code signals to Linker Agent
#
# Reference: /docs/knowledge-base/x86-64-instructions.md
#
# Encoding follows Intel x86-64 instruction format:
#   [Prefixes] [REX] [Opcode] [ModR/M] [SIB] [Displacement] [Immediate]

network assembler {

  # ═══════════════════════════════════════════════════════════════════════════
  # FREQUENCY DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  frequencies {
    # Input signals (from Code Generator)
    asm_instruction {
      label: string           # Optional label at this address
      mnemonic: string        # Instruction mnemonic (mov, add, etc.)
      operands: vec<string>   # Operand strings
    }

    asm_data {
      label: string
      data_type: string       # "asciz", "quad", "byte", "align"
      value: string
    }

    asm_section {
      name: string            # ".text", ".rodata", ".data", ".bss"
    }

    codegen_complete {
      instruction_count: u32
      function_count: u32
    }

    # Output signals (to Linker)
    machine_code {
      section: string
      offset: u32
      bytes: vec<u8>
    }

    relocation {
      section: string
      offset: u32
      symbol: string
      reloc_type: RelocationType
      addend: i64
    }

    symbol_def {
      name: string
      section: string
      offset: u32
      is_global: boolean
    }

    section_info {
      name: string
      size: u32
      flags: u32              # SHF_ALLOC, SHF_EXECINSTR, etc.
    }

    asm_complete {
      total_bytes: u32
      symbol_count: u32
      relocation_count: u32
    }

    # Error signals
    asm_error {
      message: string
      line: u32
      instruction: string
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TYPE DEFINITIONS
  # ═══════════════════════════════════════════════════════════════════════════

  types {
    # ─────────────────────────────────────────────────────────────────────────
    # Relocation Types
    # ─────────────────────────────────────────────────────────────────────────

    enum RelocationType {
      R_X86_64_NONE,        # No relocation
      R_X86_64_64,          # 64-bit absolute
      R_X86_64_PC32,        # 32-bit PC-relative
      R_X86_64_GOT32,       # GOT entry
      R_X86_64_PLT32,       # PLT entry
      R_X86_64_32,          # 32-bit absolute
      R_X86_64_32S          # 32-bit signed
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Operand Types (parsed from string)
    # ─────────────────────────────────────────────────────────────────────────

    enum Operand {
      Reg(RegisterInfo),
      Mem(MemoryOperand),
      Imm(i64),
      Label(string)
    }

    struct RegisterInfo {
      name: string
      code: u8              # 3-bit register code (0-7)
      is_extended: boolean   # r8-r15 (needs REX.B or REX.R)
      size: u8              # 8, 16, 32, or 64 bits
    }

    struct MemoryOperand {
      base: string          # Base register (empty if none)
      index: string         # Index register (empty if none)
      scale: u8             # 1, 2, 4, or 8
      displacement: i32     # Offset
      is_rip_relative: boolean
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Instruction Encoding Info
    # ─────────────────────────────────────────────────────────────────────────

    struct EncodedInstruction {
      bytes: vec<u8>
      relocations: vec<InstrRelocation>
    }

    struct InstrRelocation {
      offset: u8            # Offset within instruction
      symbol: string
      reloc_type: RelocationType
      addend: i64
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Assembly Line (internal representation)
    # ─────────────────────────────────────────────────────────────────────────

    struct AsmLine {
      label: string
      mnemonic: string
      operands: vec<Operand>
      line_num: u32
    }

    struct DataLine {
      label: string
      data_type: string
      value: string
      line_num: u32
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Symbol Table Entry
    # ─────────────────────────────────────────────────────────────────────────

    struct Symbol {
      name: string
      section: string
      offset: u32
      is_global: boolean
      is_defined: boolean
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Section Data
    # ─────────────────────────────────────────────────────────────────────────

    struct Section {
      name: string
      data: vec<u8>
      relocations: vec<SectionRelocation>
    }

    struct SectionRelocation {
      offset: u32
      symbol: string
      reloc_type: RelocationType
      addend: i64
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # ASSEMBLER AGENT
  # ═══════════════════════════════════════════════════════════════════════════

  hyphae {
    hyphal assembler {
      frequency tidal_cycle

      state {
        # Input buffers
        asm_lines: vec<AsmLine>
        data_lines: vec<DataLine>
        current_section: string

        # Symbol table
        symbols: map<string, Symbol>

        # Section data
        text_section: Section
        rodata_section: Section
        data_section: Section
        bss_section: Section

        # Counters
        line_num: u32
        error_count: u32

        # Register encoding tables (initialized on first use)
        reg_codes: map<string, u8>
        reg_extended: map<string, boolean>
        reg_sizes: map<string, u8>
      }

      # ─────────────────────────────────────────────────────────────────────────
      # INITIALIZATION
      # ─────────────────────────────────────────────────────────────────────────

      on rest {
        if map_len(state.reg_codes) == 0 {
          init_register_tables()
          init_sections()
        }
      }

      rule init_register_tables() {
        # 64-bit registers (code, is_extended)
        state.reg_codes["rax"] = 0; state.reg_extended["rax"] = false; state.reg_sizes["rax"] = 64
        state.reg_codes["rcx"] = 1; state.reg_extended["rcx"] = false; state.reg_sizes["rcx"] = 64
        state.reg_codes["rdx"] = 2; state.reg_extended["rdx"] = false; state.reg_sizes["rdx"] = 64
        state.reg_codes["rbx"] = 3; state.reg_extended["rbx"] = false; state.reg_sizes["rbx"] = 64
        state.reg_codes["rsp"] = 4; state.reg_extended["rsp"] = false; state.reg_sizes["rsp"] = 64
        state.reg_codes["rbp"] = 5; state.reg_extended["rbp"] = false; state.reg_sizes["rbp"] = 64
        state.reg_codes["rsi"] = 6; state.reg_extended["rsi"] = false; state.reg_sizes["rsi"] = 64
        state.reg_codes["rdi"] = 7; state.reg_extended["rdi"] = false; state.reg_sizes["rdi"] = 64

        # Extended 64-bit registers (r8-r15)
        state.reg_codes["r8"]  = 0; state.reg_extended["r8"]  = true; state.reg_sizes["r8"]  = 64
        state.reg_codes["r9"]  = 1; state.reg_extended["r9"]  = true; state.reg_sizes["r9"]  = 64
        state.reg_codes["r10"] = 2; state.reg_extended["r10"] = true; state.reg_sizes["r10"] = 64
        state.reg_codes["r11"] = 3; state.reg_extended["r11"] = true; state.reg_sizes["r11"] = 64
        state.reg_codes["r12"] = 4; state.reg_extended["r12"] = true; state.reg_sizes["r12"] = 64
        state.reg_codes["r13"] = 5; state.reg_extended["r13"] = true; state.reg_sizes["r13"] = 64
        state.reg_codes["r14"] = 6; state.reg_extended["r14"] = true; state.reg_sizes["r14"] = 64
        state.reg_codes["r15"] = 7; state.reg_extended["r15"] = true; state.reg_sizes["r15"] = 64

        # 32-bit registers
        state.reg_codes["eax"] = 0; state.reg_extended["eax"] = false; state.reg_sizes["eax"] = 32
        state.reg_codes["ecx"] = 1; state.reg_extended["ecx"] = false; state.reg_sizes["ecx"] = 32
        state.reg_codes["edx"] = 2; state.reg_extended["edx"] = false; state.reg_sizes["edx"] = 32
        state.reg_codes["ebx"] = 3; state.reg_extended["ebx"] = false; state.reg_sizes["ebx"] = 32
        state.reg_codes["esp"] = 4; state.reg_extended["esp"] = false; state.reg_sizes["esp"] = 32
        state.reg_codes["ebp"] = 5; state.reg_extended["ebp"] = false; state.reg_sizes["ebp"] = 32
        state.reg_codes["esi"] = 6; state.reg_extended["esi"] = false; state.reg_sizes["esi"] = 32
        state.reg_codes["edi"] = 7; state.reg_extended["edi"] = false; state.reg_sizes["edi"] = 32

        # Extended 32-bit registers
        state.reg_codes["r8d"]  = 0; state.reg_extended["r8d"]  = true; state.reg_sizes["r8d"]  = 32
        state.reg_codes["r9d"]  = 1; state.reg_extended["r9d"]  = true; state.reg_sizes["r9d"]  = 32
        state.reg_codes["r10d"] = 2; state.reg_extended["r10d"] = true; state.reg_sizes["r10d"] = 32
        state.reg_codes["r11d"] = 3; state.reg_extended["r11d"] = true; state.reg_sizes["r11d"] = 32
        state.reg_codes["r12d"] = 4; state.reg_extended["r12d"] = true; state.reg_sizes["r12d"] = 32
        state.reg_codes["r13d"] = 5; state.reg_extended["r13d"] = true; state.reg_sizes["r13d"] = 32
        state.reg_codes["r14d"] = 6; state.reg_extended["r14d"] = true; state.reg_sizes["r14d"] = 32
        state.reg_codes["r15d"] = 7; state.reg_extended["r15d"] = true; state.reg_sizes["r15d"] = 32

        # 8-bit registers (low byte)
        state.reg_codes["al"] = 0; state.reg_extended["al"] = false; state.reg_sizes["al"] = 8
        state.reg_codes["cl"] = 1; state.reg_extended["cl"] = false; state.reg_sizes["cl"] = 8
        state.reg_codes["dl"] = 2; state.reg_extended["dl"] = false; state.reg_sizes["dl"] = 8
        state.reg_codes["bl"] = 3; state.reg_extended["bl"] = false; state.reg_sizes["bl"] = 8
        state.reg_codes["spl"] = 4; state.reg_extended["spl"] = false; state.reg_sizes["spl"] = 8
        state.reg_codes["bpl"] = 5; state.reg_extended["bpl"] = false; state.reg_sizes["bpl"] = 8
        state.reg_codes["sil"] = 6; state.reg_extended["sil"] = false; state.reg_sizes["sil"] = 8
        state.reg_codes["dil"] = 7; state.reg_extended["dil"] = false; state.reg_sizes["dil"] = 8
      }

      rule init_sections() {
        state.text_section = Section {
          name: ".text",
          data: vec_new(),
          relocations: vec_new()
        }
        state.rodata_section = Section {
          name: ".rodata",
          data: vec_new(),
          relocations: vec_new()
        }
        state.data_section = Section {
          name: ".data",
          data: vec_new(),
          relocations: vec_new()
        }
        state.bss_section = Section {
          name: ".bss",
          data: vec_new(),
          relocations: vec_new()
        }
        state.current_section = ".text"
      }

      # ─────────────────────────────────────────────────────────────────────────
      # SIGNAL HANDLERS - SENSE PHASE
      # ─────────────────────────────────────────────────────────────────────────

      on signal(asm_section, sect) {
        state.current_section = sect.name
      }

      on signal(asm_instruction, instr) {
        state.line_num = state.line_num + 1

        # Parse operands
        let parsed_operands: vec<Operand> = vec_new()
        for op_str in instr.operands {
          let op = parse_operand(op_str)
          vec_push(parsed_operands, op)
        }

        # Record label if present
        if instr.label != "" {
          let offset = get_current_section_offset()
          let sym = Symbol {
            name: instr.label,
            section: state.current_section,
            offset: offset,
            is_global: starts_with(instr.label, "_") || !starts_with(instr.label, "."),
            is_defined: true
          }
          map_set(state.symbols, instr.label, sym)
        }

        # Buffer the instruction
        let line = AsmLine {
          label: instr.label,
          mnemonic: string_lower(instr.mnemonic),
          operands: parsed_operands,
          line_num: state.line_num
        }
        vec_push(state.asm_lines, line)
      }

      on signal(asm_data, data) {
        state.line_num = state.line_num + 1

        # Record label if present
        if data.label != "" {
          let offset = get_current_section_offset()
          let sym = Symbol {
            name: data.label,
            section: state.current_section,
            offset: offset,
            is_global: starts_with(data.label, "_") || !starts_with(data.label, "."),
            is_defined: true
          }
          map_set(state.symbols, data.label, sym)
        }

        # Buffer the data
        let line = DataLine {
          label: data.label,
          data_type: data.data_type,
          value: data.value,
          line_num: state.line_num
        }
        vec_push(state.data_lines, line)
      }

      on signal(codegen_complete, done) {
        # All input received - perform two-pass assembly
        assemble_all()
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TWO-PASS ASSEMBLY
      # ─────────────────────────────────────────────────────────────────────────

      rule assemble_all() {
        # Pass 1: Calculate instruction sizes, finalize symbol offsets
        pass1_calculate_sizes()

        # Pass 2: Encode all instructions, resolve labels
        pass2_encode_instructions()

        # Encode data sections
        encode_data_sections()

        # Emit results to Linker
        emit_results()
      }

      rule pass1_calculate_sizes() {
        let offset = 0u32

        for line in state.asm_lines {
          # Update label offset if present
          if line.label != "" && map_has(state.symbols, line.label) {
            let sym = map_get(state.symbols, line.label)
            sym.offset = offset
            map_set(state.symbols, line.label, sym)
          }

          # Calculate instruction size (conservative estimate)
          let size = estimate_instruction_size(line.mnemonic, line.operands)
          offset = offset + size
        }
      }

      rule pass2_encode_instructions() {
        for line in state.asm_lines {
          let encoded = encode_instruction(line.mnemonic, line.operands, line.line_num)

          # Add bytes to section
          let section = get_current_section_mut()
          for byte in encoded.bytes {
            vec_push(section.data, byte)
          }

          # Add relocations
          for reloc in encoded.relocations {
            let section_reloc = SectionRelocation {
              offset: vec_len(section.data) - vec_len(encoded.bytes) + reloc.offset,
              symbol: reloc.symbol,
              reloc_type: reloc.reloc_type,
              addend: reloc.addend
            }
            vec_push(section.relocations, section_reloc)
          }
        }
      }

      rule encode_data_sections() {
        for data in state.data_lines {
          match data.data_type {
            "asciz" | "ascii" => {
              let bytes = string_to_bytes(data.value)
              let section = get_section_by_name_mut(state.current_section)
              for byte in bytes {
                vec_push(section.data, byte)
              }
              if data.data_type == "asciz" {
                vec_push(section.data, 0u8)  # Null terminator
              }
            }
            "quad" => {
              let val = parse_i64(data.value)
              let bytes = i64_to_le_bytes(val)
              let section = get_section_by_name_mut(state.current_section)
              for byte in bytes {
                vec_push(section.data, byte)
              }
            }
            "byte" => {
              let val = parse_u8(data.value)
              let section = get_section_by_name_mut(state.current_section)
              vec_push(section.data, val)
            }
            "align" => {
              let alignment = parse_u32(data.value)
              let section = get_section_by_name_mut(state.current_section)
              let current = vec_len(section.data)
              let padding = (alignment - (current % alignment)) % alignment
              for i in 0..padding {
                vec_push(section.data, 0u8)
              }
            }
            _ => {
              # Unknown data type
            }
          }
        }
      }

      rule emit_results() {
        # Emit text section
        if vec_len(state.text_section.data) > 0 {
          emit machine_code {
            section: ".text",
            offset: 0,
            bytes: state.text_section.data
          }

          for reloc in state.text_section.relocations {
            emit relocation {
              section: ".text",
              offset: reloc.offset,
              symbol: reloc.symbol,
              reloc_type: reloc.reloc_type,
              addend: reloc.addend
            }
          }

          emit section_info {
            name: ".text",
            size: vec_len(state.text_section.data),
            flags: 0x6  # SHF_ALLOC | SHF_EXECINSTR
          }
        }

        # Emit rodata section
        if vec_len(state.rodata_section.data) > 0 {
          emit machine_code {
            section: ".rodata",
            offset: 0,
            bytes: state.rodata_section.data
          }

          emit section_info {
            name: ".rodata",
            size: vec_len(state.rodata_section.data),
            flags: 0x2  # SHF_ALLOC
          }
        }

        # Emit symbols
        for name, sym in state.symbols {
          emit symbol_def {
            name: sym.name,
            section: sym.section,
            offset: sym.offset,
            is_global: sym.is_global
          }
        }

        # Emit completion
        let total_relocs = vec_len(state.text_section.relocations) +
                           vec_len(state.rodata_section.relocations) +
                           vec_len(state.data_section.relocations)

        emit asm_complete {
          total_bytes: vec_len(state.text_section.data) +
                       vec_len(state.rodata_section.data) +
                       vec_len(state.data_section.data),
          symbol_count: map_len(state.symbols),
          relocation_count: total_relocs
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # OPERAND PARSING
      # ─────────────────────────────────────────────────────────────────────────

      rule parse_operand(op_str: string) -> Operand {
        let s = string_trim(op_str)

        # Check for register (with or without % prefix)
        let reg_name = if starts_with(s, "%") { string_slice(s, 1, string_len(s)) } else { s }
        if map_has(state.reg_codes, reg_name) {
          return Operand::Reg(RegisterInfo {
            name: reg_name,
            code: map_get(state.reg_codes, reg_name),
            is_extended: map_get(state.reg_extended, reg_name),
            size: map_get(state.reg_sizes, reg_name)
          })
        }

        # Check for immediate (with $ prefix or plain number)
        if starts_with(s, "$") {
          let val_str = string_slice(s, 1, string_len(s))
          let val = parse_number_value(val_str)
          return Operand::Imm(val)
        }
        if is_numeric_string(s) {
          return Operand::Imm(parse_number_value(s))
        }

        # Check for memory operand: [base + index*scale + disp] or offset(base, index, scale)
        if starts_with(s, "(") || contains(s, "(") {
          return Operand::Mem(parse_memory_operand(s))
        }

        # Otherwise, it's a label reference
        return Operand::Label(s)
      }

      rule parse_memory_operand(s: string) -> MemoryOperand {
        # Parse AT&T syntax: disp(base, index, scale) or (base)
        # Also handle: offset(%reg) or (%reg)

        let base = ""
        let index = ""
        let scale = 1u8
        let displacement = 0i32
        let is_rip = false

        # Find displacement (before parenthesis)
        let paren_pos = string_index_of(s, "(")
        if paren_pos > 0 {
          let disp_str = string_slice(s, 0, paren_pos)
          if disp_str != "" && is_numeric_string(disp_str) {
            displacement = parse_i32(disp_str)
          }
        }

        # Extract content inside parentheses
        let start = paren_pos + 1
        let end = string_index_of(s, ")")
        let inner = string_slice(s, start, end)

        # Parse base, index, scale
        let parts = string_split(inner, ",")
        if vec_len(parts) >= 1 && parts[0] != "" {
          base = string_trim(parts[0])
          if starts_with(base, "%") {
            base = string_slice(base, 1, string_len(base))
          }
          if base == "rip" {
            is_rip = true
          }
        }
        if vec_len(parts) >= 2 && parts[1] != "" {
          index = string_trim(parts[1])
          if starts_with(index, "%") {
            index = string_slice(index, 1, string_len(index))
          }
        }
        if vec_len(parts) >= 3 && parts[2] != "" {
          scale = parse_u8(string_trim(parts[2]))
        }

        return MemoryOperand {
          base: base,
          index: index,
          scale: scale,
          displacement: displacement,
          is_rip_relative: is_rip
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # INSTRUCTION ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_instruction(mnemonic: string, operands: vec<Operand>, line: u32) -> EncodedInstruction {
        let bytes: vec<u8> = vec_new()
        let relocs: vec<InstrRelocation> = vec_new()

        match mnemonic {
          # ─── DATA MOVEMENT ───
          "mov" | "movq" | "movl" | "movw" | "movb" => {
            encode_mov(operands, bytes, relocs)
          }
          "movabs" | "movabsq" => {
            encode_movabs(operands, bytes, relocs)
          }
          "lea" | "leaq" => {
            encode_lea(operands, bytes, relocs)
          }
          "push" | "pushq" => {
            encode_push(operands, bytes)
          }
          "pop" | "popq" => {
            encode_pop(operands, bytes)
          }

          # ─── ARITHMETIC ───
          "add" | "addq" | "addl" => {
            encode_alu(operands, bytes, relocs, 0x01, 0x03, 0x81, 0x83, 0)
          }
          "sub" | "subq" | "subl" => {
            encode_alu(operands, bytes, relocs, 0x29, 0x2B, 0x81, 0x83, 5)
          }
          "imul" | "imulq" => {
            encode_imul(operands, bytes)
          }
          "idiv" | "idivq" => {
            encode_idiv(operands, bytes)
          }
          "neg" | "negq" => {
            encode_unary(operands, bytes, 0xF7, 3)
          }
          "inc" | "incq" => {
            encode_unary(operands, bytes, 0xFF, 0)
          }
          "dec" | "decq" => {
            encode_unary(operands, bytes, 0xFF, 1)
          }

          # ─── BITWISE LOGIC ───
          "and" | "andq" | "andl" => {
            encode_alu(operands, bytes, relocs, 0x21, 0x23, 0x81, 0x83, 4)
          }
          "or" | "orq" | "orl" => {
            encode_alu(operands, bytes, relocs, 0x09, 0x0B, 0x81, 0x83, 1)
          }
          "xor" | "xorq" | "xorl" => {
            encode_alu(operands, bytes, relocs, 0x31, 0x33, 0x81, 0x83, 6)
          }
          "not" | "notq" => {
            encode_unary(operands, bytes, 0xF7, 2)
          }
          "shl" | "shlq" | "sal" | "salq" => {
            encode_shift(operands, bytes, 4)
          }
          "shr" | "shrq" => {
            encode_shift(operands, bytes, 5)
          }
          "sar" | "sarq" => {
            encode_shift(operands, bytes, 7)
          }

          # ─── COMPARISON ───
          "cmp" | "cmpq" | "cmpl" => {
            encode_alu(operands, bytes, relocs, 0x39, 0x3B, 0x81, 0x83, 7)
          }
          "test" | "testq" | "testl" => {
            encode_test(operands, bytes)
          }

          # ─── CONTROL FLOW ───
          "jmp" => {
            encode_jmp(operands, bytes, relocs)
          }
          "je" | "jz" => {
            encode_jcc(operands, bytes, relocs, 0x84, 0x74)
          }
          "jne" | "jnz" => {
            encode_jcc(operands, bytes, relocs, 0x85, 0x75)
          }
          "jl" | "jnge" => {
            encode_jcc(operands, bytes, relocs, 0x8C, 0x7C)
          }
          "jle" | "jng" => {
            encode_jcc(operands, bytes, relocs, 0x8E, 0x7E)
          }
          "jg" | "jnle" => {
            encode_jcc(operands, bytes, relocs, 0x8F, 0x7F)
          }
          "jge" | "jnl" => {
            encode_jcc(operands, bytes, relocs, 0x8D, 0x7D)
          }
          "ja" | "jnbe" => {
            encode_jcc(operands, bytes, relocs, 0x87, 0x77)
          }
          "jae" | "jnb" | "jnc" => {
            encode_jcc(operands, bytes, relocs, 0x83, 0x73)
          }
          "jb" | "jnae" | "jc" => {
            encode_jcc(operands, bytes, relocs, 0x82, 0x72)
          }
          "jbe" | "jna" => {
            encode_jcc(operands, bytes, relocs, 0x86, 0x76)
          }
          "call" => {
            encode_call(operands, bytes, relocs)
          }
          "ret" | "retq" => {
            vec_push(bytes, 0xC3)
          }

          # ─── SET BYTE ───
          "sete" | "setz" => {
            encode_setcc(operands, bytes, 0x94)
          }
          "setne" | "setnz" => {
            encode_setcc(operands, bytes, 0x95)
          }
          "setl" | "setnge" => {
            encode_setcc(operands, bytes, 0x9C)
          }
          "setle" | "setng" => {
            encode_setcc(operands, bytes, 0x9E)
          }
          "setg" | "setnle" => {
            encode_setcc(operands, bytes, 0x9F)
          }
          "setge" | "setnl" => {
            encode_setcc(operands, bytes, 0x9D)
          }

          # ─── ZERO/SIGN EXTEND ───
          "movzbq" | "movzbl" => {
            encode_movzx(operands, bytes)
          }
          "movsbq" | "movsbl" => {
            encode_movsx(operands, bytes)
          }
          "movsxd" | "movslq" => {
            encode_movsxd(operands, bytes)
          }
          "cqo" | "cqto" => {
            vec_push(bytes, 0x48)  # REX.W
            vec_push(bytes, 0x99)  # CQO
          }
          "cdq" | "cltd" => {
            vec_push(bytes, 0x99)  # CDQ
          }

          # ─── EXCHANGE ───
          "xchg" | "xchgq" => {
            encode_xchg(operands, bytes)
          }

          # ─── UNSIGNED MULTIPLY/DIVIDE ───
          "mul" | "mulq" => {
            encode_unary(operands, bytes, 0xF7, 4)  # MUL r/m64
          }
          "div" | "divq" => {
            encode_unary(operands, bytes, 0xF7, 6)  # DIV r/m64
          }

          # ─── ADDITIONAL CONDITIONAL JUMPS ───
          "js" => {
            encode_jcc(operands, bytes, relocs, 0x88, 0x78)
          }
          "jns" => {
            encode_jcc(operands, bytes, relocs, 0x89, 0x79)
          }
          "jo" => {
            encode_jcc(operands, bytes, relocs, 0x80, 0x70)
          }
          "jno" => {
            encode_jcc(operands, bytes, relocs, 0x81, 0x71)
          }
          "jp" | "jpe" => {
            encode_jcc(operands, bytes, relocs, 0x8A, 0x7A)
          }
          "jnp" | "jpo" => {
            encode_jcc(operands, bytes, relocs, 0x8B, 0x7B)
          }

          # ─── ADDITIONAL SET BYTE ───
          "seta" | "setnbe" => {
            encode_setcc(operands, bytes, 0x97)
          }
          "setae" | "setnb" | "setnc" => {
            encode_setcc(operands, bytes, 0x93)
          }
          "setb" | "setnae" | "setc" => {
            encode_setcc(operands, bytes, 0x92)
          }
          "setbe" | "setna" => {
            encode_setcc(operands, bytes, 0x96)
          }
          "sets" => {
            encode_setcc(operands, bytes, 0x98)
          }
          "setns" => {
            encode_setcc(operands, bytes, 0x99)
          }
          "seto" => {
            encode_setcc(operands, bytes, 0x90)
          }
          "setno" => {
            encode_setcc(operands, bytes, 0x91)
          }
          "setp" | "setpe" => {
            encode_setcc(operands, bytes, 0x9A)
          }
          "setnp" | "setpo" => {
            encode_setcc(operands, bytes, 0x9B)
          }

          # ─── CONDITIONAL MOVE ───
          "cmove" | "cmovz" => {
            encode_cmovcc(operands, bytes, 0x44)
          }
          "cmovne" | "cmovnz" => {
            encode_cmovcc(operands, bytes, 0x45)
          }
          "cmovl" | "cmovnge" => {
            encode_cmovcc(operands, bytes, 0x4C)
          }
          "cmovle" | "cmovng" => {
            encode_cmovcc(operands, bytes, 0x4E)
          }
          "cmovg" | "cmovnle" => {
            encode_cmovcc(operands, bytes, 0x4F)
          }
          "cmovge" | "cmovnl" => {
            encode_cmovcc(operands, bytes, 0x4D)
          }
          "cmova" | "cmovnbe" => {
            encode_cmovcc(operands, bytes, 0x47)
          }
          "cmovae" | "cmovnb" | "cmovnc" => {
            encode_cmovcc(operands, bytes, 0x43)
          }
          "cmovb" | "cmovnae" | "cmovc" => {
            encode_cmovcc(operands, bytes, 0x42)
          }
          "cmovbe" | "cmovna" => {
            encode_cmovcc(operands, bytes, 0x46)
          }
          "cmovs" => {
            encode_cmovcc(operands, bytes, 0x48)
          }
          "cmovns" => {
            encode_cmovcc(operands, bytes, 0x49)
          }

          # ─── SYSTEM ───
          "syscall" => {
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0x05)
          }
          "nop" => {
            vec_push(bytes, 0x90)
          }
          "hlt" => {
            vec_push(bytes, 0xF4)
          }
          "ud2" => {
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0x0B)
          }

          _ => {
            emit asm_error {
              message: format("Unknown instruction: {}", mnemonic),
              line: line,
              instruction: mnemonic
            }
            state.error_count = state.error_count + 1
          }
        }

        return EncodedInstruction {
          bytes: bytes,
          relocations: relocs
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MOV ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_mov(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 2 {
          return
        }

        let src = operands[0]
        let dst = operands[1]

        match (src, dst) {
          # mov reg, reg
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(dst_reg, src_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x89)  # MOV r/m64, r64
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }

          # mov imm, reg
          (Operand::Imm(val), Operand::Reg(dst_reg)) => {
            if val >= -2147483648 && val <= 2147483647 {
              # 32-bit immediate (sign-extended)
              let rex = build_rex_r(dst_reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0xC7)  # MOV r/m64, imm32
              vec_push(bytes, build_modrm(3, 0, dst_reg.code))
              append_imm32(bytes, val as i32)
            } else {
              # 64-bit immediate (movabs)
              let rex = 0x48 | (if dst_reg.is_extended { 0x01 } else { 0 })
              vec_push(bytes, rex)
              vec_push(bytes, 0xB8 + dst_reg.code)  # MOV r64, imm64
              append_imm64(bytes, val)
            }
          }

          # mov mem, reg (load)
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            encode_mem_reg(bytes, relocs, mem, dst_reg, 0x8B, true)
          }

          # mov reg, mem (store)
          (Operand::Reg(src_reg), Operand::Mem(mem)) => {
            encode_reg_mem(bytes, relocs, src_reg, mem, 0x89, true)
          }

          # mov label, reg
          (Operand::Label(label), Operand::Reg(dst_reg)) => {
            # lea with RIP-relative addressing
            let rex = build_rex_r(dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x8D)  # LEA
            vec_push(bytes, build_modrm(0, dst_reg.code, 5))  # RIP-relative
            # Add relocation
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }

          _ => {
            # Unsupported operand combination
          }
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MOVABS ENCODING (64-bit immediate)
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_movabs(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Imm(val), Operand::Reg(dst_reg)) => {
            let rex = 0x48 | (if dst_reg.is_extended { 0x01 } else { 0 })
            vec_push(bytes, rex)
            vec_push(bytes, 0xB8 + dst_reg.code)  # MOV r64, imm64
            append_imm64(bytes, val)
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # LEA ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_lea(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            encode_mem_reg(bytes, relocs, mem, dst_reg, 0x8D, true)
          }
          (Operand::Label(label), Operand::Reg(dst_reg)) => {
            # RIP-relative LEA
            let rex = build_rex_r(dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x8D)  # LEA
            vec_push(bytes, build_modrm(0, dst_reg.code, 5))  # RIP-relative
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # PUSH/POP ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_push(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Reg(reg) => {
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0x50 + reg.code)
          }
          Operand::Imm(val) => {
            if val >= -128 && val <= 127 {
              vec_push(bytes, 0x6A)  # PUSH imm8
              vec_push(bytes, val as u8)
            } else {
              vec_push(bytes, 0x68)  # PUSH imm32
              append_imm32(bytes, val as i32)
            }
          }
          _ => {}
        }
      }

      rule encode_pop(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Reg(reg) => {
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0x58 + reg.code)
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # ALU OPERATIONS (add, sub, and, or, xor, cmp)
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_alu(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>,
                      opcode_rm_r: u8, opcode_r_rm: u8, opcode_rm_imm32: u8, opcode_rm_imm8: u8,
                      reg_opcode: u8) {
        if vec_len(operands) != 2 {
          return
        }

        let src = operands[0]
        let dst = operands[1]

        match (src, dst) {
          # alu reg, reg
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(dst_reg, src_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, opcode_rm_r)
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }

          # alu imm, reg
          (Operand::Imm(val), Operand::Reg(dst_reg)) => {
            let rex = build_rex_r(dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }

            if val >= -128 && val <= 127 {
              vec_push(bytes, opcode_rm_imm8)  # 83 /r
              vec_push(bytes, build_modrm(3, reg_opcode, dst_reg.code))
              vec_push(bytes, val as u8)
            } else {
              vec_push(bytes, opcode_rm_imm32)  # 81 /r
              vec_push(bytes, build_modrm(3, reg_opcode, dst_reg.code))
              append_imm32(bytes, val as i32)
            }
          }

          # alu mem, reg
          (Operand::Mem(mem), Operand::Reg(dst_reg)) => {
            encode_mem_reg(bytes, relocs, mem, dst_reg, opcode_r_rm, true)
          }

          # alu reg, mem
          (Operand::Reg(src_reg), Operand::Mem(mem)) => {
            encode_reg_mem(bytes, relocs, src_reg, mem, opcode_rm_r, true)
          }

          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # IMUL/IDIV ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_imul(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) == 1 {
          # imul r/m64 (rdx:rax = rax * r/m64)
          match operands[0] {
            Operand::Reg(reg) => {
              let rex = build_rex_r(reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0xF7)
              vec_push(bytes, build_modrm(3, 5, reg.code))
            }
            _ => {}
          }
        } else if vec_len(operands) == 2 {
          # imul r64, r/m64
          match (operands[0], operands[1]) {
            (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
              let rex = build_rex_rr(src_reg, dst_reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0x0F)
              vec_push(bytes, 0xAF)
              vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
            }
            _ => {}
          }
        }
      }

      rule encode_idiv(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Reg(reg) => {
            let rex = build_rex_r(reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0xF7)
            vec_push(bytes, build_modrm(3, 7, reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # UNARY OPERATIONS (neg, not, inc, dec)
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_unary(operands: vec<Operand>, bytes: vec<u8>, opcode: u8, reg_opcode: u8) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Reg(reg) => {
            let rex = build_rex_r(reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, opcode)
            vec_push(bytes, build_modrm(3, reg_opcode, reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # SHIFT OPERATIONS
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_shift(operands: vec<Operand>, bytes: vec<u8>, reg_opcode: u8) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          # shift imm8, reg
          (Operand::Imm(count), Operand::Reg(reg)) => {
            let rex = build_rex_r(reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            if count == 1 {
              vec_push(bytes, 0xD1)  # Shift by 1
            } else {
              vec_push(bytes, 0xC1)  # Shift by imm8
            }
            vec_push(bytes, build_modrm(3, reg_opcode, reg.code))
            if count != 1 {
              vec_push(bytes, count as u8)
            }
          }
          # shift cl, reg
          (Operand::Reg(cl_reg), Operand::Reg(reg)) => {
            if cl_reg.name == "cl" {
              let rex = build_rex_r(reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0xD3)  # Shift by CL
              vec_push(bytes, build_modrm(3, reg_opcode, reg.code))
            }
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # TEST ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_test(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(dst_reg, src_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x85)  # TEST r/m64, r64
            vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # JUMP ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_jmp(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Label(label) => {
            # Always use rel32 for simplicity
            vec_push(bytes, 0xE9)  # JMP rel32
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }
          Operand::Reg(reg) => {
            # JMP r/m64 (indirect jump)
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0xFF)
            vec_push(bytes, build_modrm(3, 4, reg.code))
          }
          _ => {}
        }
      }

      rule encode_jcc(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>,
                      opcode_rel32: u8, opcode_rel8: u8) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Label(label) => {
            # Use rel32 form (0F 8x)
            vec_push(bytes, 0x0F)
            vec_push(bytes, opcode_rel32)
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # CALL ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_call(operands: vec<Operand>, bytes: vec<u8>, relocs: vec<InstrRelocation>) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Label(label) => {
            vec_push(bytes, 0xE8)  # CALL rel32
            vec_push(relocs, InstrRelocation {
              offset: vec_len(bytes) as u8,
              symbol: label,
              reloc_type: RelocationType::R_X86_64_PC32,
              addend: -4
            })
            append_imm32(bytes, 0)  # Placeholder
          }
          Operand::Reg(reg) => {
            # CALL r/m64 (indirect call)
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0xFF)
            vec_push(bytes, build_modrm(3, 2, reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # SETCC ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_setcc(operands: vec<Operand>, bytes: vec<u8>, opcode: u8) {
        if vec_len(operands) != 1 {
          return
        }

        match operands[0] {
          Operand::Reg(reg) => {
            if reg.is_extended {
              vec_push(bytes, 0x41)  # REX.B
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, opcode)
            vec_push(bytes, build_modrm(3, 0, reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MOVZX/MOVSX ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_movzx(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0xB6)  # MOVZX r64, r/m8
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      rule encode_movsx(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, 0xBE)  # MOVSX r64, r/m8
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MOVSXD ENCODING (Sign-extend dword to qword)
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_movsxd(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x63)  # MOVSXD r64, r/m32
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # XCHG ENCODING
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_xchg(operands: vec<Operand>, bytes: vec<u8>) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            # Special case: xchg rax, reg uses short form
            if dst_reg.name == "rax" && !src_reg.is_extended {
              vec_push(bytes, 0x48)  # REX.W
              vec_push(bytes, 0x90 + src_reg.code)  # XCHG rax, r64
            } else if src_reg.name == "rax" && !dst_reg.is_extended {
              vec_push(bytes, 0x48)  # REX.W
              vec_push(bytes, 0x90 + dst_reg.code)  # XCHG rax, r64
            } else {
              # General form: XCHG r/m64, r64
              let rex = build_rex_rr(dst_reg, src_reg, true)
              if rex != 0 {
                vec_push(bytes, rex)
              }
              vec_push(bytes, 0x87)  # XCHG r/m64, r64
              vec_push(bytes, build_modrm(3, src_reg.code, dst_reg.code))
            }
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # CMOVCC ENCODING (Conditional Move)
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_cmovcc(operands: vec<Operand>, bytes: vec<u8>, opcode: u8) {
        if vec_len(operands) != 2 {
          return
        }

        match (operands[0], operands[1]) {
          (Operand::Reg(src_reg), Operand::Reg(dst_reg)) => {
            let rex = build_rex_rr(src_reg, dst_reg, true)
            if rex != 0 {
              vec_push(bytes, rex)
            }
            vec_push(bytes, 0x0F)
            vec_push(bytes, opcode)  # CMOVcc r64, r/m64
            vec_push(bytes, build_modrm(3, dst_reg.code, src_reg.code))
          }
          _ => {}
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MEMORY ADDRESSING HELPERS
      # ─────────────────────────────────────────────────────────────────────────

      rule encode_mem_reg(bytes: vec<u8>, relocs: vec<InstrRelocation>,
                          mem: MemoryOperand, reg: RegisterInfo, opcode: u8, is_64bit: boolean) {
        # Build REX prefix
        let rex = build_rex_mem_reg(mem, reg, is_64bit)
        if rex != 0 {
          vec_push(bytes, rex)
        }

        vec_push(bytes, opcode)

        # Encode addressing mode
        encode_memory_modrm_sib(bytes, relocs, mem, reg.code)
      }

      rule encode_reg_mem(bytes: vec<u8>, relocs: vec<InstrRelocation>,
                          reg: RegisterInfo, mem: MemoryOperand, opcode: u8, is_64bit: boolean) {
        # Build REX prefix
        let rex = build_rex_mem_reg(mem, reg, is_64bit)
        if rex != 0 {
          vec_push(bytes, rex)
        }

        vec_push(bytes, opcode)

        # Encode addressing mode
        encode_memory_modrm_sib(bytes, relocs, mem, reg.code)
      }

      rule encode_memory_modrm_sib(bytes: vec<u8>, relocs: vec<InstrRelocation>,
                                    mem: MemoryOperand, reg_code: u8) {
        if mem.is_rip_relative || mem.base == "" {
          # RIP-relative or absolute addressing
          vec_push(bytes, build_modrm(0, reg_code, 5))  # mod=00, r/m=101 (RIP-relative)
          append_imm32(bytes, mem.displacement)
          return
        }

        let base_code = map_get(state.reg_codes, mem.base)
        let base_extended = map_get(state.reg_extended, mem.base)
        let needs_sib = mem.index != "" || mem.base == "rsp" || mem.base == "r12"

        # Determine mod field based on displacement
        let mod_field = 0u8
        if mem.displacement == 0 && mem.base != "rbp" && mem.base != "r13" {
          mod_field = 0  # No displacement
        } else if mem.displacement >= -128 && mem.displacement <= 127 {
          mod_field = 1  # 8-bit displacement
        } else {
          mod_field = 2  # 32-bit displacement
        }

        if needs_sib {
          # Need SIB byte
          let rm_field = 4u8  # SIB follows
          vec_push(bytes, build_modrm(mod_field, reg_code, rm_field))

          # Build SIB byte
          let scale = match mem.scale {
            1 => 0u8
            2 => 1u8
            4 => 2u8
            8 => 3u8
            _ => 0u8
          }

          let index_code = if mem.index != "" {
            map_get(state.reg_codes, mem.index)
          } else {
            4  # No index (100)
          }

          vec_push(bytes, (scale << 6) | (index_code << 3) | base_code)
        } else {
          vec_push(bytes, build_modrm(mod_field, reg_code, base_code))
        }

        # Add displacement
        if mod_field == 1 {
          vec_push(bytes, mem.displacement as u8)
        } else if mod_field == 2 {
          append_imm32(bytes, mem.displacement)
        } else if mem.base == "rbp" || mem.base == "r13" {
          # Special case: rbp/r13 with no displacement needs disp8=0
          vec_push(bytes, 0)
        }
      }

      # ─────────────────────────────────────────────────────────────────────────
      # REX PREFIX HELPERS
      # ─────────────────────────────────────────────────────────────────────────

      rule build_rex_rr(rm_reg: RegisterInfo, r_reg: RegisterInfo, is_64bit: boolean) -> u8 {
        let w = if is_64bit { 1u8 } else { 0u8 }
        let r = if r_reg.is_extended { 1u8 } else { 0u8 }
        let b = if rm_reg.is_extended { 1u8 } else { 0u8 }

        if w == 0 && r == 0 && b == 0 {
          return 0  # No REX needed
        }
        return 0x40 | (w << 3) | (r << 2) | b
      }

      rule build_rex_r(reg: RegisterInfo, is_64bit: boolean) -> u8 {
        let w = if is_64bit { 1u8 } else { 0u8 }
        let b = if reg.is_extended { 1u8 } else { 0u8 }

        if w == 0 && b == 0 {
          return 0
        }
        return 0x40 | (w << 3) | b
      }

      rule build_rex_mem_reg(mem: MemoryOperand, reg: RegisterInfo, is_64bit: boolean) -> u8 {
        let w = if is_64bit { 1u8 } else { 0u8 }
        let r = if reg.is_extended { 1u8 } else { 0u8 }
        let x = if mem.index != "" && map_get(state.reg_extended, mem.index) { 1u8 } else { 0u8 }
        let b = if mem.base != "" && map_get(state.reg_extended, mem.base) { 1u8 } else { 0u8 }

        if w == 0 && r == 0 && x == 0 && b == 0 {
          return 0
        }
        return 0x40 | (w << 3) | (r << 2) | (x << 1) | b
      }

      # ─────────────────────────────────────────────────────────────────────────
      # MODR/M AND IMMEDIATE HELPERS
      # ─────────────────────────────────────────────────────────────────────────

      rule build_modrm(mod_field: u8, reg: u8, rm: u8) -> u8 {
        return (mod_field << 6) | ((reg & 0x7) << 3) | (rm & 0x7)
      }

      rule append_imm8(bytes: vec<u8>, val: i8) {
        vec_push(bytes, val as u8)
      }

      rule append_imm32(bytes: vec<u8>, val: i32) {
        vec_push(bytes, (val & 0xFF) as u8)
        vec_push(bytes, ((val >> 8) & 0xFF) as u8)
        vec_push(bytes, ((val >> 16) & 0xFF) as u8)
        vec_push(bytes, ((val >> 24) & 0xFF) as u8)
      }

      rule append_imm64(bytes: vec<u8>, val: i64) {
        vec_push(bytes, (val & 0xFF) as u8)
        vec_push(bytes, ((val >> 8) & 0xFF) as u8)
        vec_push(bytes, ((val >> 16) & 0xFF) as u8)
        vec_push(bytes, ((val >> 24) & 0xFF) as u8)
        vec_push(bytes, ((val >> 32) & 0xFF) as u8)
        vec_push(bytes, ((val >> 40) & 0xFF) as u8)
        vec_push(bytes, ((val >> 48) & 0xFF) as u8)
        vec_push(bytes, ((val >> 56) & 0xFF) as u8)
      }

      # ─────────────────────────────────────────────────────────────────────────
      # UTILITY HELPERS
      # ─────────────────────────────────────────────────────────────────────────

      rule estimate_instruction_size(mnemonic: string, operands: vec<Operand>) -> u32 {
        # Conservative estimate for instruction sizes
        match mnemonic {
          "ret" | "nop" | "hlt" => 1
          "syscall" | "ud2" => 2
          "cqo" | "cdq" => 2
          "push" | "pop" => 2
          _ => 7  # Maximum typical instruction size (REX + opcode + modrm + sib + disp32)
        }
      }

      rule get_current_section_offset() -> u32 {
        match state.current_section {
          ".text" => vec_len(state.text_section.data)
          ".rodata" => vec_len(state.rodata_section.data)
          ".data" => vec_len(state.data_section.data)
          ".bss" => vec_len(state.bss_section.data)
          _ => 0
        }
      }

      rule get_current_section_mut() -> Section {
        match state.current_section {
          ".text" => state.text_section
          ".rodata" => state.rodata_section
          ".data" => state.data_section
          ".bss" => state.bss_section
          _ => state.text_section
        }
      }

      rule get_section_by_name_mut(name: string) -> Section {
        match name {
          ".text" => state.text_section
          ".rodata" => state.rodata_section
          ".data" => state.data_section
          ".bss" => state.bss_section
          _ => state.text_section
        }
      }

      rule parse_number_value(s: string) -> i64 {
        if starts_with(s, "0x") || starts_with(s, "0X") {
          return parse_hex(string_slice(s, 2, string_len(s)))
        }
        return parse_i64(s)
      }

      rule is_numeric_string(s: string) -> boolean {
        if string_len(s) == 0 {
          return false
        }
        let first = char_at(s, 0)
        return first == '-' || first == '+' || (first >= '0' && first <= '9')
      }

      rule string_to_bytes(s: string) -> vec<u8> {
        let result: vec<u8> = vec_new()
        let i = 0
        let len = string_len(s)

        # Skip surrounding quotes if present
        if len >= 2 && (char_at(s, 0) == '"' || char_at(s, 0) == '\'') {
          i = 1
          len = len - 1
        }

        while i < len {
          let c = char_at(s, i)
          if c == '\\' && i + 1 < len {
            let next = char_at(s, i + 1)
            match next {
              'n' => { vec_push(result, 10u8); i = i + 2 }
              'r' => { vec_push(result, 13u8); i = i + 2 }
              't' => { vec_push(result, 9u8); i = i + 2 }
              '0' => { vec_push(result, 0u8); i = i + 2 }
              '\\' => { vec_push(result, 92u8); i = i + 2 }
              '"' => { vec_push(result, 34u8); i = i + 2 }
              '\'' => { vec_push(result, 39u8); i = i + 2 }
              _ => { vec_push(result, c as u8); i = i + 1 }
            }
          } else {
            vec_push(result, c as u8)
            i = i + 1
          }
        }
        return result
      }

      rule i64_to_le_bytes(val: i64) -> vec<u8> {
        let result: vec<u8> = vec_new()
        append_imm64(result, val)
        return result
      }
    }
  }

  # ═══════════════════════════════════════════════════════════════════════════
  # TOPOLOGY
  # ═══════════════════════════════════════════════════════════════════════════

  topology {
    spawn assembler as Assembler

    # Input: Receive assembly from Code Generator
    socket asm_in -> Assembler (frequency: asm_instruction)
    socket asm_data_in -> Assembler (frequency: asm_data)
    socket asm_section_in -> Assembler (frequency: asm_section)
    socket codegen_done -> Assembler (frequency: codegen_complete)

    # Output: Send machine code to Linker
    socket Assembler -> machine_code_out (frequency: machine_code)
    socket Assembler -> reloc_out (frequency: relocation)
    socket Assembler -> symbol_out (frequency: symbol_def)
    socket Assembler -> section_out (frequency: section_info)
    socket Assembler -> asm_done (frequency: asm_complete)
    socket Assembler -> asm_errors (frequency: asm_error)
  }
}
